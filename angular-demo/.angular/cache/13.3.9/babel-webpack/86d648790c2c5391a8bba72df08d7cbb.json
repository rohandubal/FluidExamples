{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { DriverHeader } from \"@fluidframework/driver-definitions\";\n/**\n * Default endpoint port. Will be used by the service if the consumer does not specify a port.\n */\n\nexport const defaultTinyliciousPort = 7070;\n/**\n * Default endpoint URL base. Will be used by the service if the consumer does not specify an endpoint.\n */\n\nexport const defaultTinyliciousEndpoint = \"http://localhost\";\n/**\n * InsecureTinyliciousUrlResolver knows how to get the URLs to the service (in this case Tinylicious) to use\n * for a given request.  This particular implementation has a goal to avoid imposing requirements on the app's\n * URL shape, so it expects the request url to have this format (as opposed to a more traditional URL):\n * documentId/containerRelativePathing\n */\n\nexport class InsecureTinyliciousUrlResolver {\n  constructor(port = defaultTinyliciousPort, endpoint = defaultTinyliciousEndpoint) {\n    this.tinyliciousEndpoint = `${endpoint}:${port}`;\n    this.fluidProtocolEndpoint = this.tinyliciousEndpoint.replace(/(^\\w+:|^)\\/\\//, \"fluid://\");\n  }\n\n  resolve(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a; // determine whether the request is for creating of a new container.\n      // such request has the `createNew` header set to true and doesn't have a container ID.\n\n\n      if (request.headers && request.headers[DriverHeader.createNew] === true) {\n        // honor the document ID passed by the application via the create request\n        // otherwise use the reserved keyword to let the driver generate the ID.\n        // TODO: deprecate this capability for tinylicious as the r11s driver will stop using the document ID\n        // in create requests.\n        const newDocumentId = (_a = request.url) !== null && _a !== void 0 ? _a : \"new\";\n        return {\n          endpoints: {\n            deltaStorageUrl: `${_this.tinyliciousEndpoint}/deltas/tinylicious/${newDocumentId}`,\n            ordererUrl: _this.tinyliciousEndpoint,\n            storageUrl: `${_this.tinyliciousEndpoint}/repos/tinylicious`\n          },\n          // id is a mandatory attribute, but it's ignored by the driver for new container requests.\n          id: request.url,\n          // tokens attribute is redundant as all tokens are generated via ITokenProvider\n          tokens: {},\n          type: \"fluid\",\n          url: `${_this.fluidProtocolEndpoint}/tinylicious/${newDocumentId}`\n        };\n      } // for an existing container we'll parse the request URL to determine the document ID.\n\n\n      const url = request.url.replace(`${_this.tinyliciousEndpoint}/`, \"\");\n      const documentId = url.split(\"/\")[0];\n      const encodedDocId = encodeURIComponent(documentId);\n      const documentRelativePath = url.slice(documentId.length);\n      const documentUrl = `${_this.fluidProtocolEndpoint}/tinylicious/${encodedDocId}${documentRelativePath}`;\n      const deltaStorageUrl = `${_this.tinyliciousEndpoint}/deltas/tinylicious/${encodedDocId}`;\n      const storageUrl = `${_this.tinyliciousEndpoint}/repos/tinylicious`;\n      const response = {\n        endpoints: {\n          deltaStorageUrl,\n          ordererUrl: _this.tinyliciousEndpoint,\n          storageUrl\n        },\n        id: documentId,\n        tokens: {},\n        type: \"fluid\",\n        url: documentUrl\n      };\n      return response;\n    })();\n  }\n\n  getAbsoluteUrl(resolvedUrl, relativeUrl) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const documentId = decodeURIComponent(resolvedUrl.url.replace(`${_this2.fluidProtocolEndpoint}/tinylicious/`, \"\"));\n      /*\n       * The detached container flow will ultimately call getAbsoluteUrl() with the resolved.url produced by\n       * resolve().  The container expects getAbsoluteUrl's return value to be a URL that can then be roundtripped\n       * back through resolve() again, and get the same result again.  So we'll return a \"URL\" with the same format\n       * described above.\n       */\n\n      return `${documentId}/${relativeUrl}`;\n    })();\n  }\n\n}\nexport const createTinyliciousCreateNewRequest = documentId => ({\n  url: documentId !== null && documentId !== void 0 ? documentId : \"\",\n  headers: {\n    [DriverHeader.createNew]: true\n  }\n}); //# sourceMappingURL=insecureTinyliciousUrlResolver.js.map","map":null,"metadata":{},"sourceType":"module"}