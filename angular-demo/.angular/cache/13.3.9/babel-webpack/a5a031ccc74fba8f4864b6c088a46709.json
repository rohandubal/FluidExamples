{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { UnassignedSequenceNumber } from \"./constants\";\nimport { combine, createMap } from \"./properties\";\nexport class PropertiesManager {\n  constructor() {\n    this.pendingRewriteCount = 0;\n  }\n\n  ackPendingProperties(annotateOp) {\n    var _a, _b;\n\n    if (annotateOp.combiningOp && annotateOp.combiningOp.name === \"rewrite\") {\n      this.pendingRewriteCount--;\n    }\n\n    for (const key of Object.keys(annotateOp.props)) {\n      if (((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) !== undefined) {\n        assert(this.pendingKeyUpdateCount[key] > 0, 0x05c\n        /* \"Trying to update more annotate props than do exist!\" */\n        );\n        this.pendingKeyUpdateCount[key]--;\n\n        if (((_b = this.pendingKeyUpdateCount) === null || _b === void 0 ? void 0 : _b[key]) === 0) {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete this.pendingKeyUpdateCount[key];\n        }\n      }\n    }\n  }\n\n  addProperties(oldProps, newProps, op, seq, collaborating = false) {\n    var _a;\n\n    if (!this.pendingKeyUpdateCount) {\n      this.pendingKeyUpdateCount = createMap();\n    } // There are outstanding local rewrites, so block all non-local changes\n\n\n    if (this.pendingRewriteCount > 0 && seq !== UnassignedSequenceNumber && collaborating) {\n      return undefined;\n    }\n\n    const rewrite = op && op.name === \"rewrite\";\n    const combiningOp = !rewrite ? op ? op : undefined : undefined;\n\n    const shouldModifyKey = key => {\n      var _a;\n\n      if (seq === UnassignedSequenceNumber || ((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) === undefined || combiningOp) {\n        return true;\n      }\n\n      return false;\n    };\n\n    const deltas = {};\n\n    if (rewrite) {\n      if (collaborating && seq === UnassignedSequenceNumber) {\n        this.pendingRewriteCount++;\n      } // We are re-writing so delete all the properties\n      // not in the new props\n\n\n      for (const key of Object.keys(oldProps)) {\n        if (!newProps[key] && shouldModifyKey(key)) {\n          deltas[key] = oldProps[key]; // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n\n          delete oldProps[key];\n        }\n      }\n    }\n\n    for (const key of Object.keys(newProps)) {\n      if (collaborating) {\n        if (seq === UnassignedSequenceNumber) {\n          if (((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) === undefined) {\n            this.pendingKeyUpdateCount[key] = 0;\n          }\n\n          this.pendingKeyUpdateCount[key]++;\n        } else if (!shouldModifyKey(key)) {\n          continue;\n        }\n      }\n\n      const previousValue = oldProps[key]; // The delta should be null if undefined, as thats how we encode delete\n\n      deltas[key] = previousValue === undefined ? null : previousValue;\n      let newValue;\n\n      if (combiningOp) {\n        newValue = combine(combiningOp, previousValue, newValue, seq);\n      } else {\n        newValue = newProps[key];\n      }\n\n      if (newValue === null) {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete oldProps[key];\n      } else {\n        oldProps[key] = newValue;\n      }\n    }\n\n    return deltas;\n  }\n\n  copyTo(oldProps, newProps, newManager) {\n    if (oldProps) {\n      if (!newProps) {\n        // eslint-disable-next-line no-param-reassign\n        newProps = createMap();\n      }\n\n      if (!newManager) {\n        throw new Error(\"Must provide new PropertyManager\");\n      }\n\n      for (const key of Object.keys(oldProps)) {\n        newProps[key] = oldProps[key];\n      }\n\n      newManager.pendingRewriteCount = this.pendingRewriteCount;\n      newManager.pendingKeyUpdateCount = createMap();\n\n      for (const key of Object.keys(this.pendingKeyUpdateCount)) {\n        newManager.pendingKeyUpdateCount[key] = this.pendingKeyUpdateCount[key];\n      }\n    }\n\n    return newProps;\n  }\n\n  hasPendingProperties() {\n    return this.pendingRewriteCount > 0 || Object.keys(this.pendingKeyUpdateCount).length > 0;\n  }\n\n} //# sourceMappingURL=segmentPropertiesManager.js.map","map":null,"metadata":{},"sourceType":"module"}