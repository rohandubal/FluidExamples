{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { RedBlackTree } from \"./collections\";\nimport { UnassignedSequenceNumber } from \"./constants\";\nimport { compareNumbers, toRemovalInfo } from \"./mergeTree\";\n/**\n * Returns the partial length whose sequence number is\n * the greatest sequence number within a that is\n * less than or equal to key.\n * @param a - array of partial segment lengths\n * @param key - sequence number\n */\n\nfunction latestLEQ(a, key) {\n  let best = -1;\n  let lo = 0;\n  let hi = a.length - 1;\n\n  while (lo <= hi) {\n    const mid = lo + Math.floor((hi - lo) / 2);\n\n    if (a[mid].seq <= key) {\n      if (best < 0 || a[best].seq < a[mid].seq) {\n        best = mid;\n      }\n\n      lo = mid + 1;\n    } else {\n      hi = mid - 1;\n    }\n  }\n\n  return best;\n}\n/**\n * Keep track of partial sums of segment lengths for all sequence numbers\n * in the current collaboration window (if any).  Only used during active\n * collaboration.\n */\n\n\nexport let PartialSequenceLengths = /*#__PURE__*/(() => {\n  class PartialSequenceLengths {\n    constructor(minSeq) {\n      this.minSeq = minSeq;\n      this.minLength = 0;\n      this.segmentCount = 0;\n      this.partialLengths = [];\n      this.clientSeqNumbers = [];\n    }\n\n    static combine(mergeTree, block, collabWindow, recur = false) {\n      return PartialSequenceLengths.combineBranch(mergeTree, block, collabWindow, recur);\n    }\n    /**\n     * Combine the partial lengths of block's children\n     * @param block - an interior node; it is assumed that each interior node child of this block\n     * has its partials up to date\n     * @param collabWindow - segment window of the segment tree containing textSegmentBlock\n     */\n\n\n    static combineBranch(mergeTree, block, collabWindow, recur = false) {\n      let combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);\n      PartialSequenceLengths.fromLeaves(combinedPartialLengths, block, collabWindow);\n      let prevPartial;\n\n      function cloneOverlapRemoveClients(oldTree) {\n        if (!oldTree) {\n          return undefined;\n        }\n\n        const newTree = new RedBlackTree(compareNumbers);\n        oldTree.map(bProp => {\n          newTree.put(bProp.data.clientId, Object.assign({}, bProp.data));\n          return true;\n        });\n        return newTree;\n      }\n\n      function combineOverlapClients(a, b) {\n        const overlapRemoveClientsA = a.overlapRemoveClients;\n\n        if (overlapRemoveClientsA) {\n          if (b.overlapRemoveClients) {\n            b.overlapRemoveClients.map(bProp => {\n              const aProp = overlapRemoveClientsA.get(bProp.key);\n\n              if (aProp) {\n                aProp.data.seglen += bProp.data.seglen;\n              } else {\n                overlapRemoveClientsA.put(bProp.data.clientId, Object.assign({}, bProp.data));\n              }\n\n              return true;\n            });\n          }\n        } else {\n          a.overlapRemoveClients = cloneOverlapRemoveClients(b.overlapRemoveClients);\n        }\n      }\n\n      function addNext(partialLength) {\n        const seq = partialLength.seq;\n        let pLen = 0;\n\n        if (prevPartial) {\n          if (prevPartial.seq === partialLength.seq) {\n            prevPartial.seglen += partialLength.seglen;\n            prevPartial.len += partialLength.seglen;\n            combineOverlapClients(prevPartial, partialLength);\n            return;\n          } else {\n            pLen = prevPartial.len; // Previous sequence number is finished\n\n            combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);\n          }\n        }\n\n        prevPartial = {\n          clientId: partialLength.clientId,\n          len: pLen + partialLength.seglen,\n          overlapRemoveClients: cloneOverlapRemoveClients(partialLength.overlapRemoveClients),\n          seglen: partialLength.seglen,\n          seq\n        };\n        combinedPartialLengths.partialLengths.push(prevPartial);\n      }\n\n      const childPartials = [];\n\n      for (let i = 0; i < block.childCount; i++) {\n        const child = block.children[i];\n\n        if (!child.isLeaf()) {\n          const childBlock = child;\n\n          if (recur) {\n            childBlock.partialLengths = PartialSequenceLengths.combine(mergeTree, childBlock, collabWindow, true);\n          } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n          childPartials.push(childBlock.partialLengths);\n        }\n      }\n\n      let childPartialsLen = childPartials.length;\n\n      if (childPartialsLen !== 0) {\n        // Some children are interior nodes\n        if (combinedPartialLengths.partialLengths.length > 0) {\n          // Some children were leaves; add combined partials from these segments\n          childPartials.push(combinedPartialLengths);\n          childPartialsLen++;\n          combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);\n        }\n\n        const indices = new Array(childPartialsLen);\n        const childPartialsCounts = new Array(childPartialsLen);\n\n        for (let i = 0; i < childPartialsLen; i++) {\n          indices[i] = 0;\n          childPartialsCounts[i] = childPartials[i].partialLengths.length;\n          combinedPartialLengths.minLength += childPartials[i].minLength;\n          combinedPartialLengths.segmentCount += childPartials[i].segmentCount;\n        }\n\n        let outerIndexOfEarliest = 0;\n        let earliestPartialLength;\n\n        while (outerIndexOfEarliest >= 0) {\n          outerIndexOfEarliest = -1;\n\n          for (let k = 0; k < childPartialsLen; k++) {\n            // Find next earliest sequence number\n            if (indices[k] < childPartialsCounts[k]) {\n              const cpLen = childPartials[k].partialLengths[indices[k]]; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n              if (outerIndexOfEarliest < 0 || cpLen.seq < earliestPartialLength.seq) {\n                outerIndexOfEarliest = k;\n                earliestPartialLength = cpLen;\n              }\n            }\n          }\n\n          if (outerIndexOfEarliest >= 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            addNext(earliestPartialLength);\n            indices[outerIndexOfEarliest]++;\n          }\n        } // Add client entry for last partial, if any\n\n\n        if (prevPartial) {\n          combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);\n        }\n      } // TODO: incremental zamboni during build\n\n\n      if (PartialSequenceLengths.options.zamboni) {\n        combinedPartialLengths.zamboni(collabWindow);\n      }\n\n      if (PartialSequenceLengths.options.verify) {\n        combinedPartialLengths.verify();\n      }\n\n      return combinedPartialLengths;\n    }\n\n    static fromLeaves(combinedPartialLengths, block, collabWindow) {\n      combinedPartialLengths.minLength = 0;\n      combinedPartialLengths.segmentCount = block.childCount;\n\n      function seqLTE(seq, minSeq) {\n        return seq !== undefined && seq !== UnassignedSequenceNumber && seq <= minSeq;\n      }\n\n      for (let i = 0; i < block.childCount; i++) {\n        const child = block.children[i];\n\n        if (child.isLeaf()) {\n          // Leaf segment\n          const segment = child;\n\n          if (seqLTE(segment.seq, collabWindow.minSeq)) {\n            combinedPartialLengths.minLength += segment.cachedLength;\n          } else {\n            if (segment.seq !== UnassignedSequenceNumber) {\n              PartialSequenceLengths.insertSegment(combinedPartialLengths, segment);\n            }\n          }\n\n          const removalInfo = toRemovalInfo(segment);\n\n          if (seqLTE(removalInfo === null || removalInfo === void 0 ? void 0 : removalInfo.removedSeq, collabWindow.minSeq)) {\n            combinedPartialLengths.minLength -= segment.cachedLength;\n          } else {\n            if (removalInfo !== undefined && removalInfo.removedSeq !== UnassignedSequenceNumber) {\n              PartialSequenceLengths.insertSegment(combinedPartialLengths, segment, removalInfo);\n            }\n          }\n        }\n      } // Post-process correctly-ordered partials computing sums and creating\n      // lists for each present client id\n\n\n      const seqPartials = combinedPartialLengths.partialLengths;\n      const seqPartialsLen = seqPartials.length;\n      let prevLen = 0;\n\n      for (let i = 0; i < seqPartialsLen; i++) {\n        seqPartials[i].len = prevLen + seqPartials[i].seglen;\n        prevLen = seqPartials[i].len;\n        combinedPartialLengths.addClientSeqNumberFromPartial(seqPartials[i]);\n      }\n\n      if (PartialSequenceLengths.options.verify) {\n        combinedPartialLengths.verify();\n      }\n    }\n\n    static getOverlapClients(overlapClientIds, seglen) {\n      const bst = new RedBlackTree(compareNumbers);\n\n      for (const clientId of overlapClientIds) {\n        bst.put(clientId, {\n          clientId,\n          seglen\n        });\n      }\n\n      return bst;\n    }\n\n    static accumulateRemoveClientOverlap(partialLength, overlapRemoveClientIds, seglen) {\n      if (partialLength.overlapRemoveClients) {\n        for (const clientId of overlapRemoveClientIds) {\n          const overlapClientNode = partialLength.overlapRemoveClients.get(clientId);\n\n          if (!overlapClientNode) {\n            partialLength.overlapRemoveClients.put(clientId, {\n              clientId,\n              seglen\n            });\n          } else {\n            overlapClientNode.data.seglen += seglen;\n          }\n        }\n      } else {\n        partialLength.overlapRemoveClients = PartialSequenceLengths.getOverlapClients(overlapRemoveClientIds, seglen);\n      }\n    }\n\n    static insertSegment(combinedPartialLengths, segment, removalInfo) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      let seq = segment.seq;\n      let segmentLen = segment.cachedLength;\n      let clientId = segment.clientId;\n      let removeClientOverlap;\n\n      if (removalInfo) {\n        seq = removalInfo.removedSeq;\n        segmentLen = -segmentLen; // this code still assume removed client id and\n        // overlap clients are separate. so we need to pull\n        // then apart first.\n\n        clientId = removalInfo.removedClientIds[0];\n        removeClientOverlap = removalInfo.removedClientIds.length > 1 ? removalInfo.removedClientIds.slice(1) : undefined;\n      }\n\n      const seqPartials = combinedPartialLengths.partialLengths;\n      const seqPartialsLen = seqPartials.length; // Find the first entry with sequence number greater or equal to seq\n\n      let indexFirstGTE = 0;\n\n      for (; indexFirstGTE < seqPartialsLen; indexFirstGTE++) {\n        if (seqPartials[indexFirstGTE].seq >= seq) {\n          break;\n        }\n      }\n\n      if (indexFirstGTE < seqPartialsLen && seqPartials[indexFirstGTE].seq === seq) {\n        seqPartials[indexFirstGTE].seglen += segmentLen;\n\n        if (removeClientOverlap) {\n          PartialSequenceLengths.accumulateRemoveClientOverlap(seqPartials[indexFirstGTE], removeClientOverlap, segmentLen);\n        }\n      } else {\n        let pLen;\n\n        if (removeClientOverlap) {\n          const overlapClients = PartialSequenceLengths.getOverlapClients(removeClientOverlap, segmentLen);\n          pLen = {\n            seq,\n            clientId,\n            len: 0,\n            seglen: segmentLen,\n            overlapRemoveClients: overlapClients\n          };\n        } else {\n          pLen = {\n            seq,\n            clientId,\n            len: 0,\n            seglen: segmentLen\n          };\n        }\n\n        if (indexFirstGTE < seqPartialsLen) {\n          // Shift entries with greater sequence numbers\n          // TODO: investigate performance improvement using BST\n          for (let k = seqPartialsLen; k > indexFirstGTE; k--) {\n            seqPartials[k] = seqPartials[k - 1];\n          }\n\n          seqPartials[indexFirstGTE] = pLen;\n        } else {\n          seqPartials.push(pLen);\n        }\n      }\n    }\n\n    static addSeq(partialLengths, seq, seqSeglen, clientId) {\n      let seqPartialLen;\n      let penultPartialLen;\n      let leqIndex = latestLEQ(partialLengths, seq);\n\n      if (leqIndex >= 0) {\n        const pLen = partialLengths[leqIndex];\n\n        if (pLen.seq === seq) {\n          seqPartialLen = pLen;\n          leqIndex = latestLEQ(partialLengths, seq - 1);\n\n          if (leqIndex >= 0) {\n            penultPartialLen = partialLengths[leqIndex];\n          }\n        } else {\n          penultPartialLen = pLen;\n        }\n      }\n\n      if (seqPartialLen === undefined) {\n        // len will be assigned below, making this assertion true.\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        seqPartialLen = {\n          clientId,\n          seglen: seqSeglen,\n          seq\n        };\n        partialLengths.push(seqPartialLen);\n      } else {\n        seqPartialLen.seglen = seqSeglen; // Assert client id matches\n      }\n\n      if (penultPartialLen !== undefined) {\n        seqPartialLen.len = seqPartialLen.seglen + penultPartialLen.len;\n      } else {\n        seqPartialLen.len = seqPartialLen.seglen;\n      }\n    } // Assume: seq is latest sequence number; no structural change to sub-tree, but a segment\n    // with sequence number seq has been added within the sub-tree\n    // TODO: assert client id matches\n\n\n    update(mergeTree, node, seq, clientId, collabWindow) {\n      let seqSeglen = 0;\n      let segCount = 0; // Compute length for seq across children\n\n      for (let i = 0; i < node.childCount; i++) {\n        const child = node.children[i];\n\n        if (!child.isLeaf()) {\n          const childBlock = child; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n          const branchPartialLengths = childBlock.partialLengths;\n          const partialLengths = branchPartialLengths.partialLengths;\n          const seqIndex = latestLEQ(partialLengths, seq);\n\n          if (seqIndex >= 0) {\n            const leqPartial = partialLengths[seqIndex];\n\n            if (leqPartial.seq === seq) {\n              seqSeglen += leqPartial.seglen;\n            }\n          }\n\n          segCount += branchPartialLengths.segmentCount;\n        } else {\n          const segment = child;\n          const removalInfo = toRemovalInfo(segment);\n\n          if (segment.seq === seq) {\n            if ((removalInfo === null || removalInfo === void 0 ? void 0 : removalInfo.removedSeq) !== seq) {\n              seqSeglen += segment.cachedLength;\n            }\n          } else {\n            if ((removalInfo === null || removalInfo === void 0 ? void 0 : removalInfo.removedSeq) === seq) {\n              seqSeglen -= segment.cachedLength;\n            }\n          }\n\n          segCount++;\n        }\n      }\n\n      this.segmentCount = segCount;\n      PartialSequenceLengths.addSeq(this.partialLengths, seq, seqSeglen, clientId);\n\n      if (this.clientSeqNumbers[clientId] === undefined) {\n        this.clientSeqNumbers[clientId] = [];\n      }\n\n      PartialSequenceLengths.addSeq(this.clientSeqNumbers[clientId], seq, seqSeglen);\n\n      if (PartialSequenceLengths.options.zamboni) {\n        this.zamboni(collabWindow);\n      }\n\n      if (PartialSequenceLengths.options.verify) {\n        this.verify();\n      }\n    }\n\n    getPartialLength(refSeq, clientId) {\n      let pLen = this.minLength;\n      const seqIndex = latestLEQ(this.partialLengths, refSeq);\n      const cliLatestIndex = this.cliLatest(clientId);\n      const cliSeq = this.clientSeqNumbers[clientId];\n\n      if (seqIndex >= 0) {\n        // Add the partial length up to refSeq\n        pLen += this.partialLengths[seqIndex].len;\n\n        if (cliLatestIndex >= 0) {\n          const cliLatest = cliSeq[cliLatestIndex];\n\n          if (cliLatest.seq > refSeq) {\n            // The client has local edits after refSeq, add in the length adjustments\n            pLen += cliLatest.len;\n            const precedingCliIndex = this.cliLatestLEQ(clientId, refSeq);\n\n            if (precedingCliIndex >= 0) {\n              pLen -= cliSeq[precedingCliIndex].len;\n            }\n          }\n        }\n      } else {\n        // RefSeq is before any of the partial lengths\n        // so just add in all local edits of that client (which should all be after the refSeq)\n        if (cliLatestIndex >= 0) {\n          const cliLatest = cliSeq[cliLatestIndex];\n          pLen += cliLatest.len;\n        }\n      }\n\n      return pLen;\n    }\n\n    toString(glc, indentCount = 0) {\n      let buf = \"\";\n\n      for (const partial of this.partialLengths) {\n        buf += `(${partial.seq},${partial.len}) `;\n      } // eslint-disable-next-line @typescript-eslint/no-for-in-array, no-restricted-syntax\n\n\n      for (const clientId in this.clientSeqNumbers) {\n        if (this.clientSeqNumbers[clientId].length > 0) {\n          buf += `Client `;\n\n          if (glc) {\n            buf += `${glc(+clientId)}`;\n          } else {\n            buf += `${clientId}`;\n          }\n\n          buf += \"[\";\n\n          for (const partial of this.clientSeqNumbers[clientId]) {\n            buf += `(${partial.seq},${partial.len})`;\n          }\n\n          buf += \"]\";\n        }\n      }\n\n      buf = `min(seq ${this.minSeq}): ${this.minLength}; sc: ${this.segmentCount};${buf}`;\n      return buf;\n    } // Clear away partial sums for sequence numbers earlier than the current window\n\n\n    zamboni(segmentWindow) {\n      function copyDown(partialLengths) {\n        const mindex = latestLEQ(partialLengths, segmentWindow.minSeq);\n        let minLength = 0;\n\n        if (mindex >= 0) {\n          minLength = partialLengths[mindex].len;\n          const seqCount = partialLengths.length;\n\n          if (mindex <= seqCount - 1) {\n            // Still some entries remaining\n            const remainingCount = seqCount - mindex - 1; // Copy down\n\n            for (let i = 0; i < remainingCount; i++) {\n              partialLengths[i] = partialLengths[i + mindex + 1];\n              partialLengths[i].len -= minLength;\n            }\n\n            partialLengths.length = remainingCount;\n          }\n        }\n\n        return minLength;\n      }\n\n      this.minLength += copyDown(this.partialLengths); // eslint-disable-next-line @typescript-eslint/no-for-in-array, guard-for-in, no-restricted-syntax\n\n      for (const clientId in this.clientSeqNumbers) {\n        const cliPartials = this.clientSeqNumbers[clientId];\n\n        if (cliPartials) {\n          copyDown(cliPartials);\n        }\n      }\n    }\n\n    addClientSeqNumber(clientId, seq, seglen) {\n      if (this.clientSeqNumbers[clientId] === undefined) {\n        this.clientSeqNumbers[clientId] = [];\n      }\n\n      const cli = this.clientSeqNumbers[clientId];\n      let pLen = seglen;\n\n      if (cli.length > 0) {\n        pLen += cli[cli.length - 1].len;\n      }\n\n      cli.push({\n        seq,\n        len: pLen,\n        seglen\n      });\n    } // Assumes sequence number already coalesced\n\n\n    addClientSeqNumberFromPartial(partialLength) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.addClientSeqNumber(partialLength.clientId, partialLength.seq, partialLength.seglen);\n\n      if (partialLength.overlapRemoveClients) {\n        partialLength.overlapRemoveClients.map(oc => {\n          this.addClientSeqNumber(oc.data.clientId, partialLength.seq, oc.data.seglen);\n          return true;\n        });\n      }\n    }\n\n    cliLatestLEQ(clientId, refSeq) {\n      const cliSeqs = this.clientSeqNumbers[clientId];\n\n      if (cliSeqs) {\n        return latestLEQ(cliSeqs, refSeq);\n      } else {\n        return -1;\n      }\n    }\n\n    cliLatest(clientId) {\n      const cliSeqs = this.clientSeqNumbers[clientId];\n\n      if (cliSeqs && cliSeqs.length > 0) {\n        return cliSeqs.length - 1;\n      } else {\n        return -1;\n      }\n    } // Debug only\n\n\n    verifyPartialLengths(partialLengths, clientPartials) {\n      if (partialLengths.length === 0) {\n        return 0;\n      }\n\n      let lastSeqNum = 0;\n      let accumSegLen = 0;\n      let count = 0;\n\n      for (const partialLength of partialLengths) {\n        // Count total number of partial length\n        count++; // Sequence number should be larger or equal to minseq\n\n        assert(this.minSeq <= partialLength.seq, 0x054\n        /* \"Sequence number less than minSeq!\" */\n        ); // Sequence number should be sorted\n\n        assert(lastSeqNum < partialLength.seq, 0x055\n        /* \"Sequence number is not sorted!\" */\n        );\n        lastSeqNum = partialLength.seq; // Len is a accumulation of all the seglen adjustments\n\n        accumSegLen += partialLength.seglen;\n\n        if (accumSegLen !== partialLength.len) {\n          assert(false, 0x056\n          /* \"Unexpected total for accumulation of all seglen adjustments!\" */\n          );\n        }\n\n        if (clientPartials) {// Client partials used to track local edits so we can account for them some refSeq.\n          // But the information we keep track of are since minSeq, so we keep track of more history\n          // then needed, and some of them doesn't make sense to be used for length calculations\n          // e.g. if you have this sequence, where the minSeq is #5 because of other clients\n          //    seq 10: client 1: insert seg #1\n          //    seq 11: client 2: delete seg #2 refseq: 10\n          // minLength is 0, we would have keep a record of seglen: -1 for clientPartialLengths for client 2\n          // So if you ask for partial length for client 2 @ seq 5, we will have return -1.\n          // However, that combination is invalid, since we should never see any ops with refseq < 10 for\n          // client 2 after seq 11.\n        } else {\n          // Len adjustment should not make length negative\n          if (this.minLength + partialLength.len < 0) {\n            assert(false, 0x057\n            /* \"Negative length after length adjustment!\" */\n            );\n          }\n        }\n\n        if (partialLength.overlapRemoveClients) {\n          // Only the flat partialLengths can have overlapRemoveClients, the per client view shouldn't\n          assert(!clientPartials, 0x058\n          /* \"Both overlapRemoveClients and clientPartials are set!\" */\n          ); // Each overlap client count as one\n\n          count += partialLength.overlapRemoveClients.size();\n        }\n      }\n\n      return count;\n    }\n\n    verify() {\n      if (this.clientSeqNumbers) {\n        let cliCount = 0;\n\n        for (const cliSeq of this.clientSeqNumbers) {\n          if (cliSeq) {\n            cliCount += this.verifyPartialLengths(cliSeq, true);\n          }\n        } // If we have client view, we should have the flat view\n\n\n        assert(!!this.partialLengths, 0x059\n        /* \"Client view exists but flat view does not!\" */\n        );\n        const flatCount = this.verifyPartialLengths(this.partialLengths, false); // The number of partial lengths on the client view and flat view should be the same\n\n        assert(flatCount === cliCount, 0x05a\n        /* \"Mismatch between number of partial lengths on client and flat views!\" */\n        );\n      } else {\n        // If we don't have a client view, we shouldn't have the flat view either\n        assert(!this.partialLengths, 0x05b\n        /* \"Flat view exists but client view does not!\" */\n        );\n      }\n    }\n\n  }\n\n  PartialSequenceLengths.options = {\n    verify: false,\n    zamboni: true\n  }; //# sourceMappingURL=partialLengths.js.map\n\n  return PartialSequenceLengths;\n})();","map":null,"metadata":{},"sourceType":"module"}