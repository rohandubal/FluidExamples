{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { v4 as uuid } from \"uuid\";\nimport { LoaderHeader } from \"@fluidframework/container-definitions\";\nimport { ChildLogger, DebugLogger, loggerToMonitoringContext, mixinMonitoringContext, PerformanceEvent, sessionStorageConfigProvider } from \"@fluidframework/telemetry-utils\";\nimport { ensureFluidResolvedUrl, MultiUrlResolver, MultiDocumentServiceFactory } from \"@fluidframework/driver-utils\";\nimport { Container } from \"./container\";\nimport { parseUrl } from \"./utils\";\nimport { pkgVersion } from \"./packageVersion\";\n\nfunction canUseCache(request) {\n  if (request.headers === undefined) {\n    return true;\n  }\n\n  return request.headers[LoaderHeader.cache] !== false;\n}\n\nexport class RelativeLoader {\n  constructor(container, loader) {\n    this.container = container;\n    this.loader = loader;\n  }\n\n  get IFluidRouter() {\n    return this;\n  }\n\n  resolve(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c, _d, _e;\n\n      if (request.url.startsWith(\"/\")) {\n        if (canUseCache(request)) {\n          return _this.container;\n        } else {\n          const resolvedUrl = _this.container.resolvedUrl;\n          ensureFluidResolvedUrl(resolvedUrl);\n          const container = yield Container.load(_this.loader, {\n            canReconnect: (_a = request.headers) === null || _a === void 0 ? void 0 : _a[LoaderHeader.reconnect],\n            clientDetailsOverride: (_b = request.headers) === null || _b === void 0 ? void 0 : _b[LoaderHeader.clientDetails],\n            resolvedUrl: Object.assign({}, resolvedUrl),\n            version: (_d = (_c = request.headers) === null || _c === void 0 ? void 0 : _c[LoaderHeader.version]) !== null && _d !== void 0 ? _d : undefined,\n            loadMode: (_e = request.headers) === null || _e === void 0 ? void 0 : _e[LoaderHeader.loadMode]\n          });\n          return container;\n        }\n      }\n\n      if (_this.loader === undefined) {\n        throw new Error(\"Cannot resolve external containers\");\n      }\n\n      return _this.loader.resolve(request);\n    })();\n  }\n\n  request(request) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (request.url.startsWith(\"/\")) {\n        const container = yield _this2.resolve(request);\n        return container.request(request);\n      }\n\n      if (_this2.loader === undefined) {\n        return {\n          status: 404,\n          value: \"Cannot request external containers\",\n          mimeType: \"plain/text\"\n        };\n      }\n\n      return _this2.loader.request(request);\n    })();\n  }\n\n}\n\nfunction createCachedResolver(resolver) {\n  const cacheResolver = Object.create(resolver);\n  const resolveCache = new Map();\n\n  cacheResolver.resolve = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (request) {\n      if (!canUseCache(request)) {\n        return resolver.resolve(request);\n      }\n\n      if (!resolveCache.has(request.url)) {\n        resolveCache.set(request.url, resolver.resolve(request));\n      }\n\n      return resolveCache.get(request.url);\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  return cacheResolver;\n}\n/**\n * Manages Fluid resource loading\n */\n\n\nexport class Loader {\n  constructor(loaderProps) {\n    var _a, _b;\n\n    this.containers = new Map();\n    const scope = Object.assign({}, loaderProps.scope);\n\n    if (((_a = loaderProps.options) === null || _a === void 0 ? void 0 : _a.provideScopeLoader) !== false) {\n      scope.ILoader = this;\n    }\n\n    const telemetryProps = {\n      loaderId: uuid(),\n      loaderVersion: pkgVersion\n    };\n    const subMc = mixinMonitoringContext(DebugLogger.mixinDebugLogger(\"fluid:telemetry\", loaderProps.logger, {\n      all: telemetryProps\n    }), sessionStorageConfigProvider.value, loaderProps.configProvider);\n    this.services = {\n      urlResolver: createCachedResolver(MultiUrlResolver.create(loaderProps.urlResolver)),\n      documentServiceFactory: MultiDocumentServiceFactory.create(loaderProps.documentServiceFactory),\n      codeLoader: loaderProps.codeLoader,\n      options: (_b = loaderProps.options) !== null && _b !== void 0 ? _b : {},\n      scope,\n      subLogger: subMc.logger,\n      detachedBlobStorage: loaderProps.detachedBlobStorage\n    };\n    this.mc = loggerToMonitoringContext(ChildLogger.create(this.services.subLogger, \"Loader\"));\n  }\n\n  get IFluidRouter() {\n    return this;\n  }\n\n  createDetachedContainer(codeDetails) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const container = yield Container.createDetached(_this3, codeDetails);\n\n      if (_this3.cachingEnabled) {\n        container.once(\"attached\", () => {\n          ensureFluidResolvedUrl(container.resolvedUrl);\n          const parsedUrl = parseUrl(container.resolvedUrl.url);\n\n          if (parsedUrl !== undefined) {\n            _this3.addToContainerCache(parsedUrl.id, Promise.resolve(container));\n          }\n        });\n      }\n\n      return container;\n    })();\n  }\n\n  rehydrateDetachedContainerFromSnapshot(snapshot) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      return Container.rehydrateDetachedFromSnapshot(_this4, snapshot);\n    })();\n  }\n\n  resolve(request, pendingLocalState) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const eventName = pendingLocalState === undefined ? \"Resolve\" : \"ResolveWithPendingState\";\n      return PerformanceEvent.timedExecAsync(_this5.mc.logger, {\n        eventName\n      }, /*#__PURE__*/_asyncToGenerator(function* () {\n        const resolved = yield _this5.resolveCore(request, pendingLocalState !== undefined ? JSON.parse(pendingLocalState) : undefined);\n        return resolved.container;\n      }));\n    })();\n  }\n\n  request(request) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      return PerformanceEvent.timedExecAsync(_this6.mc.logger, {\n        eventName: \"Request\"\n      }, /*#__PURE__*/_asyncToGenerator(function* () {\n        const resolved = yield _this6.resolveCore(request);\n        return resolved.container.request(Object.assign(Object.assign({}, request), {\n          url: `${resolved.parsed.path}${resolved.parsed.query}`\n        }));\n      }));\n    })();\n  }\n\n  getKeyForContainerCache(request, parsedUrl) {\n    var _a;\n\n    const key = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a[LoaderHeader.version]) !== undefined ? `${parsedUrl.id}@${request.headers[LoaderHeader.version]}` : parsedUrl.id;\n    return key;\n  }\n\n  addToContainerCache(key, containerP) {\n    this.containers.set(key, containerP);\n    containerP.then(container => {\n      // If the container is closed or becomes closed after we resolve it, remove it from the cache.\n      if (container.closed) {\n        this.containers.delete(key);\n      } else {\n        container.once(\"closed\", () => {\n          this.containers.delete(key);\n        });\n      }\n    }).catch(error => {});\n  }\n\n  resolveCore(request, pendingLocalState) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const resolvedAsFluid = yield _this7.services.urlResolver.resolve(request);\n      ensureFluidResolvedUrl(resolvedAsFluid); // Parse URL into data stores\n\n      const parsed = parseUrl(resolvedAsFluid.url);\n\n      if (parsed === undefined) {\n        throw new Error(`Invalid URL ${resolvedAsFluid.url}`);\n      }\n\n      if (pendingLocalState !== undefined) {\n        const parsedPendingUrl = parseUrl(pendingLocalState.url);\n\n        if ((parsedPendingUrl === null || parsedPendingUrl === void 0 ? void 0 : parsedPendingUrl.id) !== parsed.id || (parsedPendingUrl === null || parsedPendingUrl === void 0 ? void 0 : parsedPendingUrl.path.replace(/\\/$/, \"\")) !== parsed.path.replace(/\\/$/, \"\")) {\n          const message = `URL ${resolvedAsFluid.url} does not match pending state URL ${pendingLocalState.url}`;\n          throw new Error(message);\n        }\n      }\n\n      const {\n        canCache,\n        fromSequenceNumber\n      } = _this7.parseHeader(parsed, request);\n\n      const shouldCache = pendingLocalState !== undefined ? false : canCache;\n      let container;\n\n      if (shouldCache) {\n        const key = _this7.getKeyForContainerCache(request, parsed);\n\n        const maybeContainer = yield _this7.containers.get(key);\n\n        if (maybeContainer !== undefined) {\n          container = maybeContainer;\n        } else {\n          const containerP = _this7.loadContainer(request, resolvedAsFluid);\n\n          _this7.addToContainerCache(key, containerP);\n\n          container = yield containerP;\n        }\n      } else {\n        container = yield _this7.loadContainer(request, resolvedAsFluid, pendingLocalState);\n      }\n\n      if (container.deltaManager.lastSequenceNumber <= fromSequenceNumber) {\n        yield new Promise((resolve, reject) => {\n          function opHandler(message) {\n            if (message.sequenceNumber > fromSequenceNumber) {\n              resolve();\n              container.removeListener(\"op\", opHandler);\n            }\n          }\n\n          container.on(\"op\", opHandler);\n        });\n      }\n\n      return {\n        container,\n        parsed\n      };\n    })();\n  }\n\n  get cachingEnabled() {\n    return this.services.options.cache !== false;\n  }\n\n  canCacheForRequest(headers) {\n    return this.cachingEnabled && headers[LoaderHeader.cache] !== false;\n  }\n\n  parseHeader(parsed, request) {\n    var _a, _b;\n\n    let fromSequenceNumber = -1;\n    request.headers = (_a = request.headers) !== null && _a !== void 0 ? _a : {};\n    const headerSeqNum = request.headers[LoaderHeader.sequenceNumber];\n\n    if (headerSeqNum !== undefined) {\n      fromSequenceNumber = headerSeqNum;\n    } // If set in both query string and headers, use query string\n\n\n    request.headers[LoaderHeader.version] = (_b = parsed.version) !== null && _b !== void 0 ? _b : request.headers[LoaderHeader.version];\n    const canCache = this.canCacheForRequest(request.headers);\n    return {\n      canCache,\n      fromSequenceNumber\n    };\n  }\n\n  loadContainer(request, resolved, pendingLocalState) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c, _d, _e;\n\n      return Container.load(_this8, {\n        canReconnect: (_a = request.headers) === null || _a === void 0 ? void 0 : _a[LoaderHeader.reconnect],\n        clientDetailsOverride: (_b = request.headers) === null || _b === void 0 ? void 0 : _b[LoaderHeader.clientDetails],\n        resolvedUrl: resolved,\n        version: (_d = (_c = request.headers) === null || _c === void 0 ? void 0 : _c[LoaderHeader.version]) !== null && _d !== void 0 ? _d : undefined,\n        loadMode: (_e = request.headers) === null || _e === void 0 ? void 0 : _e[LoaderHeader.loadMode]\n      }, pendingLocalState);\n    })();\n  }\n\n} //# sourceMappingURL=loader.js.map","map":null,"metadata":{},"sourceType":"module"}