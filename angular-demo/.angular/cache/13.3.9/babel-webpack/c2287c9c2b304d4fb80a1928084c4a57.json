{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, LazyPromise } from \"@fluidframework/common-utils\";\nimport { cloneGCData } from \"@fluidframework/garbage-collector\";\nimport { gcBlobKey } from \"@fluidframework/runtime-definitions\";\nimport { SummarizerNode } from \"./summarizerNode\";\nimport { SummaryNode } from \"./summarizerNodeUtils\"; // Extend SummaryNode to add used routes tracking to it.\n\nclass SummaryNodeWithGC extends SummaryNode {\n  constructor(serializedUsedRoutes, summary) {\n    super(summary);\n    this.serializedUsedRoutes = serializedUsedRoutes;\n  }\n\n}\n/**\n * Extends the functionality of SummarizerNode to manage this node's garbage collection data:\n * - Adds a new API `getGCData` to return GC data of this node.\n * - Caches the result of `getGCData` to be used if nothing changes between summaries.\n * - Manages the used routes of this node. These are used to identify if this node is referenced in the document\n *   and to determine if the node's used state changed since last summary.\n * - Adds trackState param to summarize. If trackState is false, it bypasses the SummarizerNode and calls\n *   directly into summarizeInternal method.\n */\n\n\nexport class SummarizerNodeWithGC extends SummarizerNode {\n  /**\n   * Do not call constructor directly.\n   * Use createRootSummarizerNodeWithGC to create root node, or createChild to create child nodes.\n   */\n  constructor(logger, summarizeFn, config, changeSequenceNumber,\n  /** Undefined means created without summary */\n  latestSummary, initialSummary, wipSummaryLogger, getGCDataFn, getBaseGCDetailsFn) {\n    super(logger, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (fullTree, _trackState, telemetryContext) {\n        return summarizeFn(fullTree, true\n        /* trackState */\n        , telemetryContext);\n      });\n\n      return function (_x, _x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }(), config, changeSequenceNumber, latestSummary, initialSummary, wipSummaryLogger);\n    this.summarizeFn = summarizeFn;\n    this.getGCDataFn = getGCDataFn; // Keeps track of whether we have loaded the base details to ensure that we on;y do it once.\n\n    this.baseGCDetailsLoaded = false; // Set used routes to have self route by default. This makes the node referenced by default. This is done to ensure\n    // that this node is not marked as collected when running GC has been disabled. Once, the option to disable GC is\n    // removed (from runGC flag in IContainerRuntimeOptions), this should be changed to be have no routes by default.\n\n    this.usedRoutes = [\"\"];\n    this.gcDisabled = config.gcDisabled === true;\n    this.baseGCDetailsP = new LazyPromise( /*#__PURE__*/_asyncToGenerator(function* () {\n      var _a;\n\n      return (_a = yield getBaseGCDetailsFn === null || getBaseGCDetailsFn === void 0 ? void 0 : getBaseGCDetailsFn()) !== null && _a !== void 0 ? _a : {\n        usedRoutes: []\n      };\n    }));\n  }\n  /**\n   * @deprecated - Renamed to getBaseGCDetails.\n   */\n\n\n  getGCSummaryDetails() {\n    return this.getBaseGCDetails();\n  } // Returns the GC details to be added to this node's summary and is used to initialize new nodes' GC state.\n\n\n  getBaseGCDetails() {\n    return {\n      gcData: this.gcData,\n      usedRoutes: this.usedRoutes,\n      unrefTimestamp: this.unreferencedTimestampMs\n    };\n  }\n  /**\n   * Loads state from this node's initial GC summary details. This contains the following data from the last summary\n   * seen by the server for this client:\n   * - usedRoutes: This is used to figure out if the used state of this node changed since last summary.\n   * - gcData: The garbage collection data of this node that is required for running GC.\n   */\n\n\n  loadBaseGCDetails() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const baseGCDetails = yield _this.baseGCDetailsP; // Possible race - If there were parallel calls to loadBaseGCDetails, we want to make sure that we only update\n      // the state from the base details only once.\n\n      if (_this.baseGCDetailsLoaded) {\n        return;\n      }\n\n      _this.baseGCDetailsLoaded = true; // If the GC details has GC data, initialize our GC data from it.\n\n      if (baseGCDetails.gcData !== undefined) {\n        _this.gcData = cloneGCData(baseGCDetails.gcData);\n      } // Sort the used routes because we compare them with the current used routes to check if they changed between\n      // summaries. Both are sorted so that the order of elements is the same.\n\n\n      _this.referenceUsedRoutes = (_a = baseGCDetails.usedRoutes) === null || _a === void 0 ? void 0 : _a.sort();\n      _this.unreferencedTimestampMs = baseGCDetails.unrefTimestamp;\n    })();\n  }\n\n  summarize(fullTree, trackState = true, telemetryContext) {\n    var _superprop_getSummarize = () => super.summarize,\n        _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // If GC is not disabled and we are tracking a summary, GC should have run and updated the used routes for this\n      // summary by calling updateUsedRoutes which sets wipSerializedUsedRoutes.\n      if (!_this2.gcDisabled && _this2.isTrackingInProgress()) {\n        assert(_this2.wipSerializedUsedRoutes !== undefined, 0x1b1\n        /* \"wip used routes should be set if tracking a summary\" */\n        );\n      } // If trackState is true, get summary from base summarizer node which tracks summary state.\n      // If trackState is false, get summary from summarizeInternal.\n\n\n      return trackState ? _superprop_getSummarize().call(_this2, fullTree, true\n      /* trackState */\n      , telemetryContext) : _this2.summarizeFn(fullTree, trackState, telemetryContext);\n    })();\n  }\n  /**\n   * Returns the GC data of this node. If nothing has changed since last summary, it tries to reuse the data from\n   * the previous summary. Else, it gets new GC data from the underlying Fluid object.\n   * @param fullGC - true to bypass optimizations and force full generation of GC data.\n   */\n\n\n  getGCData(fullGC = false) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      assert(!_this3.gcDisabled, 0x1b2\n      /* \"Getting GC data should not be called when GC is disabled!\" */\n      );\n      assert(_this3.getGCDataFn !== undefined, 0x1b3\n      /* \"GC data cannot be retrieved without getGCDataFn\" */\n      ); // Load GC details from the initial summary, if not already loaded. If this is the first time this function is\n      // called and the node's data has not changed since last summary, the GC data in initial details is returned.\n\n      yield _this3.loadBaseGCDetails(); // If there is no new data since last summary and we have GC data from the previous run, return it. We may not\n      // have data from previous GC run for clients with older summary format before GC was added. They won't have\n      // GC details in their initial summary.\n\n      if (!fullGC && !_this3.hasDataChanged() && _this3.gcData !== undefined) {\n        return cloneGCData(_this3.gcData);\n      }\n\n      const gcData = yield _this3.getGCDataFn(fullGC);\n      _this3.gcData = cloneGCData(gcData);\n      return gcData;\n    })();\n  }\n  /**\n   * Called during the start of a summary. Updates the work-in-progress used routes.\n   */\n\n\n  startSummary(referenceSequenceNumber, summaryLogger) {\n    // If GC is disabled, skip setting wip used routes since we should not track GC state.\n    if (!this.gcDisabled) {\n      assert(this.wipSerializedUsedRoutes === undefined, 0x1b4\n      /* \"We should not already be tracking used routes when to track a new summary\" */\n      );\n    }\n\n    super.startSummary(referenceSequenceNumber, summaryLogger);\n  }\n  /**\n   * Called after summary has been uploaded to the server. Add the work-in-progress state to the pending\n   * summary queue. We track this until we get an ack from the server for this summary.\n   */\n\n\n  completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion) {\n    let wipSerializedUsedRoutes; // If GC is disabled, don't set wip used routes.\n\n    if (!this.gcDisabled) {\n      wipSerializedUsedRoutes = this.wipSerializedUsedRoutes;\n      assert(wipSerializedUsedRoutes !== undefined, 0x1b5\n      /* \"We should have been tracking used routes\" */\n      );\n    }\n\n    super.completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion); // If GC is disabled, skip setting pending summary with GC state.\n\n    if (!this.gcDisabled) {\n      const summaryNode = this.pendingSummaries.get(proposalHandle);\n\n      if (summaryNode !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const summaryNodeWithGC = new SummaryNodeWithGC(wipSerializedUsedRoutes, summaryNode);\n        this.pendingSummaries.set(proposalHandle, summaryNodeWithGC);\n      }\n    }\n  }\n  /**\n   * Clears the work-in-progress state.\n   */\n\n\n  clearSummary() {\n    this.wipSerializedUsedRoutes = undefined;\n    super.clearSummary();\n  }\n  /**\n   * Called when we get an ack from the server for a summary we sent. Update the reference state of this node\n   * from the state in the pending summary queue.\n   */\n\n\n  refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber) {\n    // If GC is disabled, skip setting referenced used routes since we are not tracking GC state.\n    if (!this.gcDisabled) {\n      const summaryNode = this.pendingSummaries.get(proposalHandle);\n\n      if (summaryNode !== undefined) {\n        this.referenceUsedRoutes = JSON.parse(summaryNode.serializedUsedRoutes);\n      }\n    }\n\n    return super.refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber);\n  }\n  /**\n   * Called when we need to upload the reference state from the given summary. Read the GC blob and get the state\n   * to upload from it.\n   */\n\n\n  refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob) {\n    var _superprop_getRefreshLatestSummaryFromSnapshot = () => super.refreshLatestSummaryFromSnapshot,\n        _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // If GC is disabled, skip setting referenced used routes since we are not tracking GC state.\n      if (!_this4.gcDisabled) {\n        const gcDetailsBlob = snapshotTree.blobs[gcBlobKey];\n\n        if (gcDetailsBlob !== undefined) {\n          const gcDetails = yield readAndParseBlob(gcDetailsBlob); // Possible re-entrancy. If we have already seen a summary later than this one, ignore it.\n\n          if (_this4.referenceSequenceNumber >= referenceSequenceNumber) {\n            return;\n          }\n\n          _this4.referenceUsedRoutes = gcDetails.usedRoutes;\n        }\n      }\n\n      return _superprop_getRefreshLatestSummaryFromSnapshot().call(_this4, referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob);\n    })();\n  }\n  /**\n   * Override the createChild method to return an instance of SummarizerNodeWithGC.\n   */\n\n\n  createChild(\n  /** Summarize function */\n  summarizeInternalFn,\n  /** Initial id or path part of this node */\n  id,\n  /**\n   * Information needed to create the node.\n   * If it is from a base summary, it will assert that a summary has been seen.\n   * Attach information if it is created from an attach op.\n   */\n  createParam, config = {}, getGCDataFn, getBaseGCDetailsFn) {\n    var _a;\n\n    assert(!this.children.has(id), 0x1b6\n    /* \"Create SummarizerNode child already exists\" */\n    );\n    const createDetails = this.getCreateDetailsForChild(id, createParam);\n    const child = new SummarizerNodeWithGC(this.defaultLogger, summarizeInternalFn, Object.assign(Object.assign({}, config), {\n      // Propagate our gcDisabled state to the child if its not explicity specified in child's config.\n      gcDisabled: (_a = config.gcDisabled) !== null && _a !== void 0 ? _a : this.gcDisabled\n    }), createDetails.changeSequenceNumber, createDetails.latestSummary, createDetails.initialSummary, this.wipSummaryLogger, getGCDataFn, getBaseGCDetailsFn); // There may be additional state that has to be updated in this child. For example, if a summary is being\n    // tracked, the child's summary tracking state needs to be updated too.\n\n    this.maybeUpdateChildState(child);\n    this.children.set(id, child);\n    return child;\n  }\n  /**\n   * Deletes the child node with the given id.\n   */\n\n\n  deleteChild(id) {\n    this.children.delete(id);\n  }\n  /**\n   * Override the getChild method to return an instance of SummarizerNodeWithGC.\n   */\n\n\n  getChild(id) {\n    return this.children.get(id);\n  }\n\n  isReferenced() {\n    return this.usedRoutes.includes(\"\") || this.usedRoutes.includes(\"/\");\n  }\n\n  updateUsedRoutes(usedRoutes, gcTimestamp) {\n    // Sort the given routes before updating. This will ensure that the routes compared in hasUsedStateChanged()\n    // are in the same order.\n    this.usedRoutes = usedRoutes.sort(); // If GC is not disabled and we are tracking a summary, update the work-in-progress used routes so that it can\n    // be tracked for this summary.\n\n    if (!this.gcDisabled && this.isTrackingInProgress()) {\n      this.wipSerializedUsedRoutes = JSON.stringify(this.usedRoutes);\n    }\n\n    if (this.isReferenced()) {\n      this.unreferencedTimestampMs = undefined;\n      return;\n    } // If this node just became unreferenced, update its unreferencedTimestampMs.\n\n\n    if (this.unreferencedTimestampMs === undefined) {\n      this.unreferencedTimestampMs = gcTimestamp;\n    }\n  }\n  /**\n   * Override the hasChanged method. If this node data or its used state changed, the node is considered changed.\n   */\n\n\n  hasChanged() {\n    return this.hasDataChanged() || this.hasUsedStateChanged();\n  }\n  /**\n   * This tells whether the data in this node has changed or not.\n   */\n\n\n  hasDataChanged() {\n    return super.hasChanged();\n  }\n  /**\n   * This tells whether the used state of this node has changed since last successful summary. If the used routes\n   * of this node changed, its used state is considered changed. Basically, if this node or any of its child nodes\n   * was previously used and became unused (or vice versa), its used state has changed.\n   */\n\n\n  hasUsedStateChanged() {\n    // If GC is disabled, we are not tracking used state, return false.\n    if (this.gcDisabled) {\n      return false;\n    }\n\n    return this.referenceUsedRoutes === undefined || JSON.stringify(this.usedRoutes) !== JSON.stringify(this.referenceUsedRoutes);\n  }\n\n}\n/**\n * Creates a root summarizer node with GC functionality built-in.\n * @param logger - Logger to use within SummarizerNode\n * @param summarizeInternalFn - Function to generate summary\n * @param changeSequenceNumber - Sequence number of latest change to new node/subtree\n * @param referenceSequenceNumber - Reference sequence number of last acked summary,\n * or undefined if not loaded from summary\n * @param config - Configure behavior of summarizer node\n * @param getGCDataFn - Function to get the GC data of this node\n * @param baseGCDetailsP - Function to get the initial GC details of this node\n */\n\nexport const createRootSummarizerNodeWithGC = (logger, summarizeInternalFn, changeSequenceNumber, referenceSequenceNumber, config = {}, getGCDataFn, getBaseGCDetailsFn) => new SummarizerNodeWithGC(logger, summarizeInternalFn, config, changeSequenceNumber, referenceSequenceNumber === undefined ? undefined : SummaryNode.createForRoot(referenceSequenceNumber), undefined\n/* initialSummary */\n, undefined\n/* wipSummaryLogger */\n, getGCDataFn, getBaseGCDetailsFn); //# sourceMappingURL=summarizerNodeWithGc.js.map","map":null,"metadata":{},"sourceType":"module"}