{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n// eslint-disable-next-line import/no-internal-modules\nimport merge from \"lodash/merge\";\nimport { v4 as uuid } from \"uuid\";\nimport { assert, performance, unreachableCase } from \"@fluidframework/common-utils\";\nimport { AttachState, isFluidCodeDetails } from \"@fluidframework/container-definitions\";\nimport { DataCorruptionError, extractSafePropertiesFromMessage, GenericError, UsageError } from \"@fluidframework/container-utils\";\nimport { readAndParse, OnlineStatus, isOnline, ensureFluidResolvedUrl, combineAppAndProtocolSummary, runWithRetry, isFluidResolvedUrl, isRuntimeMessage, isUnpackedRuntimeMessage } from \"@fluidframework/driver-utils\";\nimport { ProtocolOpHandlerWithClientValidation } from \"@fluidframework/protocol-base\";\nimport { MessageType, SummaryType } from \"@fluidframework/protocol-definitions\";\nimport { ChildLogger, EventEmitterWithErrorHandling, PerformanceEvent, raiseConnectedEvent, TelemetryLogger, connectedEventName, disconnectedEventName, normalizeError, loggerToMonitoringContext, wrapError } from \"@fluidframework/telemetry-utils\";\nimport { Audience } from \"./audience\";\nimport { ContainerContext } from \"./containerContext\";\nimport { ReconnectMode, getPackageName } from \"./contracts\";\nimport { DeltaManager } from \"./deltaManager\";\nimport { DeltaManagerProxy } from \"./deltaManagerProxy\";\nimport { RelativeLoader } from \"./loader\";\nimport { pkgVersion } from \"./packageVersion\";\nimport { ConnectionStateHandler } from \"./connectionStateHandler\";\nimport { RetriableDocumentStorageService } from \"./retriableDocumentStorageService\";\nimport { ProtocolTreeStorageService } from \"./protocolTreeDocumentStorageService\";\nimport { BlobOnlyStorage, ContainerStorageAdapter } from \"./containerStorageAdapter\";\nimport { getProtocolSnapshotTree, getSnapshotTreeFromSerializedContainer } from \"./utils\";\nimport { initQuorumValuesFromCodeDetails, getCodeDetailsFromQuorumValues, QuorumProxy } from \"./quorum\";\nimport { CollabWindowTracker } from \"./collabWindowTracker\";\nimport { ConnectionManager } from \"./connectionManager\";\nimport { ConnectionState } from \"./connectionState\";\nconst detachedContainerRefSeqNumber = 0;\nconst dirtyContainerEvent = \"dirty\";\nconst savedContainerEvent = \"saved\";\n/**\n * Waits until container connects to delta storage and gets up-to-date\n * Useful when resolving URIs and hitting 404, due to container being loaded from (stale) snapshot and not being\n * up to date. Host may chose to wait in such case and retry resolving URI.\n * Warning: Will wait infinitely for connection to establish if there is no connection.\n * May result in deadlock if Container.disconnect() is called and never followed by a call to Container.connect().\n * @returns true: container is up to date, it processed all the ops that were know at the time of first connection\n *          false: storage does not provide indication of how far the client is. Container processed\n *          all the ops known to it, but it maybe still behind.\n * @throws an error beginning with `\"Container closed\"` if the container is closed before it catches up.\n */\n\nexport function waitContainerToCatchUp(_x) {\n  return _waitContainerToCatchUp.apply(this, arguments);\n}\n\nfunction _waitContainerToCatchUp() {\n  _waitContainerToCatchUp = _asyncToGenerator(function* (container) {\n    // Make sure we stop waiting if container is closed.\n    if (container.closed) {\n      throw new UsageError(\"waitContainerToCatchUp: Container closed\");\n    }\n\n    return new Promise((resolve, reject) => {\n      const deltaManager = container.deltaManager;\n\n      const closedCallback = err => {\n        container.off(\"closed\", closedCallback);\n        const baseMessage = \"Container closed while waiting to catch up\";\n        reject(err !== undefined ? wrapError(err, innerMessage => new GenericError(`${baseMessage}: ${innerMessage}`)) : new GenericError(baseMessage));\n      };\n\n      container.on(\"closed\", closedCallback);\n\n      const waitForOps = () => {\n        assert(container.connectionState === ConnectionState.CatchingUp || container.connectionState === ConnectionState.Connected, 0x0cd\n        /* \"Container disconnected while waiting for ops!\" */\n        );\n        const hasCheckpointSequenceNumber = deltaManager.hasCheckpointSequenceNumber;\n        const connectionOpSeqNumber = deltaManager.lastKnownSeqNumber;\n        assert(deltaManager.lastSequenceNumber <= connectionOpSeqNumber, 0x266\n        /* \"lastKnownSeqNumber should never be below last processed sequence number\" */\n        );\n\n        if (deltaManager.lastSequenceNumber === connectionOpSeqNumber) {\n          container.off(\"closed\", closedCallback);\n          resolve(hasCheckpointSequenceNumber);\n          return;\n        }\n\n        const callbackOps = message => {\n          if (connectionOpSeqNumber <= message.sequenceNumber) {\n            container.off(\"closed\", closedCallback);\n            resolve(hasCheckpointSequenceNumber);\n            deltaManager.off(\"op\", callbackOps);\n          }\n        };\n\n        deltaManager.on(\"op\", callbackOps);\n      }; // We can leverage DeltaManager's \"connect\" event here and test for ConnectionState.Disconnected\n      // But that works only if service provides us checkPointSequenceNumber\n      // Our internal testing is based on R11S that does not, but almost all tests connect as \"write\" and\n      // use this function to catch up, so leveraging our own join op as a fence/barrier\n\n\n      if (container.connectionState === ConnectionState.Connected) {\n        waitForOps();\n        return;\n      }\n\n      const callback = () => {\n        container.off(connectedEventName, callback);\n        waitForOps();\n      };\n\n      container.on(connectedEventName, callback);\n\n      if (container.connectionState === ConnectionState.Disconnected) {\n        container.connect();\n      }\n    });\n  });\n  return _waitContainerToCatchUp.apply(this, arguments);\n}\n\nconst getCodeProposal = // eslint-disable-next-line @typescript-eslint/no-unsafe-return\nquorum => {\n  var _a;\n\n  return (_a = quorum.get(\"code\")) !== null && _a !== void 0 ? _a : quorum.get(\"code2\");\n};\n/**\n * Helper function to report to telemetry cases where operation takes longer than expected (1s)\n * @param logger - logger to use\n * @param eventName - event name\n * @param action - functor to call and measure\n */\n\n\nfunction ReportIfTooLong(_x2, _x3, _x4) {\n  return _ReportIfTooLong.apply(this, arguments);\n}\n\nfunction _ReportIfTooLong() {\n  _ReportIfTooLong = _asyncToGenerator(function* (logger, eventName, action) {\n    const event = PerformanceEvent.start(logger, {\n      eventName\n    });\n    const props = yield action();\n\n    if (event.duration > 1000) {\n      event.end(props);\n    }\n  });\n  return _ReportIfTooLong.apply(this, arguments);\n}\n\nconst summarizerClientType = \"summarizer\";\nexport let Container = /*#__PURE__*/(() => {\n  class Container extends EventEmitterWithErrorHandling {\n    constructor(loader, config) {\n      var _a, _b;\n\n      super((name, error) => {\n        this.mc.logger.sendErrorEvent({\n          eventName: \"ContainerEventHandlerException\",\n          name: typeof name === \"string\" ? name : undefined\n        }, error);\n      });\n      this.loader = loader; // Tells if container can reconnect on losing fist connection\n      // If false, container gets closed on loss of connection.\n\n      this._canReconnect = true;\n      this._lifecycleState = \"loading\";\n      this._attachState = AttachState.Detached;\n      /** During initialization we pause the inbound queues. We track this state to ensure we only call resume once */\n\n      this.inboundQueuePausedFromInit = true;\n      this.firstConnection = true;\n      this.connectionTransitionTimes = [];\n      this.messageCountAfterDisconnection = 0;\n      this.attachStarted = false;\n      this._dirtyContainer = false;\n      this.setAutoReconnectTime = performance.now();\n      this._audience = new Audience();\n      this.clientDetailsOverride = config.clientDetailsOverride;\n      this._resolvedUrl = config.resolvedUrl;\n\n      if (config.canReconnect !== undefined) {\n        this._canReconnect = config.canReconnect;\n      } // Create logger for data stores to use\n\n\n      const type = this.client.details.type;\n      const interactive = this.client.details.capabilities.interactive;\n      const clientType = `${interactive ? \"interactive\" : \"noninteractive\"}${type !== undefined && type !== \"\" ? `/${type}` : \"\"}`; // Need to use the property getter for docId because for detached flow we don't have the docId initially.\n      // We assign the id later so property getter is used.\n\n      this.subLogger = ChildLogger.create(loader.services.subLogger, undefined, {\n        all: {\n          clientType,\n          containerId: uuid(),\n          docId: () => {\n            var _a, _b;\n\n            return (_b = (_a = this._resolvedUrl) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : undefined;\n          },\n          containerAttachState: () => this._attachState,\n          containerLifecycleState: () => this._lifecycleState,\n          containerConnectionState: () => ConnectionState[this.connectionState],\n          serializedContainer: config.serializedContainerState !== undefined\n        },\n        // we need to be judicious with our logging here to avoid generating too much data\n        // all data logged here should be broadly applicable, and not specific to a\n        // specific error or class of errors\n        error: {\n          // load information to associate errors with the specific load point\n          dmInitialSeqNumber: () => {\n            var _a;\n\n            return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.initialSequenceNumber;\n          },\n          dmLastProcessedSeqNumber: () => {\n            var _a;\n\n            return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.lastSequenceNumber;\n          },\n          dmLastKnownSeqNumber: () => {\n            var _a;\n\n            return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.lastKnownSeqNumber;\n          },\n          containerLoadedFromVersionId: () => {\n            var _a;\n\n            return (_a = this.loadedFromVersion) === null || _a === void 0 ? void 0 : _a.id;\n          },\n          containerLoadedFromVersionDate: () => {\n            var _a;\n\n            return (_a = this.loadedFromVersion) === null || _a === void 0 ? void 0 : _a.date;\n          },\n          // message information to associate errors with the specific execution state\n          // dmLastMsqSeqNumber: if present, same as dmLastProcessedSeqNumber\n          dmLastMsqSeqNumber: () => {\n            var _a, _b;\n\n            return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.sequenceNumber;\n          },\n          dmLastMsqSeqTimestamp: () => {\n            var _a, _b;\n\n            return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.timestamp;\n          },\n          dmLastMsqSeqClientId: () => {\n            var _a, _b;\n\n            return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.clientId;\n          },\n          connectionStateDuration: () => performance.now() - this.connectionTransitionTimes[this.connectionState]\n        }\n      }); // Prefix all events in this file with container-loader\n\n      this.mc = loggerToMonitoringContext(ChildLogger.create(this.subLogger, \"Container\"));\n      const summarizeProtocolTree = (_a = this.mc.config.getBoolean(\"Fluid.Container.summarizeProtocolTree\")) !== null && _a !== void 0 ? _a : this.loader.services.options.summarizeProtocolTree;\n      this.options = Object.assign(Object.assign({}, this.loader.services.options), {\n        summarizeProtocolTree\n      });\n      this.connectionStateHandler = new ConnectionStateHandler({\n        quorumClients: () => {\n          var _a;\n\n          return (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.quorum;\n        },\n        logConnectionStateChangeTelemetry: (value, oldState, reason) => this.logConnectionStateChangeTelemetry(value, oldState, reason),\n        shouldClientJoinWrite: () => this._deltaManager.connectionManager.shouldJoinWrite(),\n        maxClientLeaveWaitTime: this.loader.services.options.maxClientLeaveWaitTime,\n        logConnectionIssue: (eventName, details) => {\n          // We get here when socket does not receive any ops on \"write\" connection, including\n          // its own join op. Attempt recovery option.\n          this._deltaManager.logConnectionIssue(Object.assign({\n            eventName,\n            duration: performance.now() - this.connectionTransitionTimes[ConnectionState.CatchingUp]\n          }, details === undefined ? {} : {\n            details: JSON.stringify(details)\n          }));\n        },\n        connectionStateChanged: () => {\n          // Fire events only if container is fully loaded and not closed\n          if (this._lifecycleState === \"loaded\") {\n            this.propagateConnectionState();\n          }\n        }\n      }, this.mc.logger, (_b = config.serializedContainerState) === null || _b === void 0 ? void 0 : _b.clientId);\n      this.on(savedContainerEvent, () => {\n        this.connectionStateHandler.containerSaved();\n      });\n      this._deltaManager = this.createDeltaManager();\n      this._storage = new ContainerStorageAdapter(() => {\n        if (this.attachState !== AttachState.Attached) {\n          if (this.loader.services.detachedBlobStorage !== undefined) {\n            return new BlobOnlyStorage(this.loader.services.detachedBlobStorage, this.mc.logger);\n          }\n\n          this.mc.logger.sendErrorEvent({\n            eventName: \"NoRealStorageInDetachedContainer\"\n          });\n          throw new Error(\"Real storage calls not allowed in Unattached container\");\n        }\n\n        return this.storageService;\n      });\n      const isDomAvailable = typeof document === \"object\" && document !== null && typeof document.addEventListener === \"function\" && document.addEventListener !== null; // keep track of last time page was visible for telemetry\n\n      if (isDomAvailable) {\n        this.lastVisible = document.hidden ? performance.now() : undefined;\n\n        this.visibilityEventHandler = () => {\n          if (document.hidden) {\n            this.lastVisible = performance.now();\n          } else {\n            // settimeout so this will hopefully fire after disconnect event if being hidden caused it\n            setTimeout(() => {\n              this.lastVisible = undefined;\n            }, 0);\n          }\n        };\n\n        document.addEventListener(\"visibilitychange\", this.visibilityEventHandler);\n      } // We observed that most users of platform do not check Container.connected event on load, causing bugs.\n      // As such, we are raising events when new listener pops up.\n      // Note that we can raise both \"disconnected\" & \"connect\" events at the same time,\n      // if we are in connecting stage.\n\n\n      this.on(\"newListener\", (event, listener) => {\n        // Fire events on the end of JS turn, giving a chance for caller to be in consistent state.\n        Promise.resolve().then(() => {\n          switch (event) {\n            case dirtyContainerEvent:\n              if (this._dirtyContainer) {\n                listener();\n              }\n\n              break;\n\n            case savedContainerEvent:\n              if (!this._dirtyContainer) {\n                listener();\n              }\n\n              break;\n\n            case connectedEventName:\n              if (this.connected) {\n                listener(this.clientId);\n              }\n\n              break;\n\n            case disconnectedEventName:\n              if (!this.connected) {\n                listener();\n              }\n\n              break;\n\n            default:\n          }\n        }).catch(error => {\n          this.mc.logger.sendErrorEvent({\n            eventName: \"RaiseConnectedEventError\"\n          }, error);\n        });\n      });\n    }\n    /**\n     * Load an existing container.\n     */\n\n\n    static load(loader, loadOptions, pendingLocalState) {\n      return _asyncToGenerator(function* () {\n        const container = new Container(loader, {\n          clientDetailsOverride: loadOptions.clientDetailsOverride,\n          resolvedUrl: loadOptions.resolvedUrl,\n          canReconnect: loadOptions.canReconnect,\n          serializedContainerState: pendingLocalState\n        });\n        return PerformanceEvent.timedExecAsync(container.mc.logger, {\n          eventName: \"Load\"\n        }, /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (event) {\n            return new Promise((resolve, reject) => {\n              var _a, _b;\n\n              const version = loadOptions.version;\n              const defaultMode = {\n                opsBeforeReturn: \"cached\"\n              }; // if we have pendingLocalState, anything we cached is not useful and we shouldn't wait for connection\n              // to return container, so ignore this value and use undefined for opsBeforeReturn\n\n              const mode = pendingLocalState ? Object.assign(Object.assign({}, (_a = loadOptions.loadMode) !== null && _a !== void 0 ? _a : defaultMode), {\n                opsBeforeReturn: undefined\n              }) : (_b = loadOptions.loadMode) !== null && _b !== void 0 ? _b : defaultMode;\n\n              const onClosed = err => {\n                // pre-0.58 error message: containerClosedWithoutErrorDuringLoad\n                reject(err !== null && err !== void 0 ? err : new GenericError(\"Container closed without error during load\"));\n              };\n\n              container.on(\"closed\", onClosed);\n              container.load(version, mode, pendingLocalState).finally(() => {\n                container.removeListener(\"closed\", onClosed);\n              }).then(props => {\n                event.end(Object.assign(Object.assign({}, props), loadOptions.loadMode));\n                resolve(container);\n              }, error => {\n                const err = normalizeError(error); // Depending where error happens, we can be attempting to connect to web socket\n                // and continuously retrying (consider offline mode)\n                // Host has no container to close, so it's prudent to do it here\n\n                container.close(err);\n                onClosed(err);\n              });\n            });\n          });\n\n          return function (_x5) {\n            return _ref.apply(this, arguments);\n          };\n        }(), {\n          start: true,\n          end: true,\n          cancel: \"generic\"\n        });\n      })();\n    }\n    /**\n     * Create a new container in a detached state.\n     */\n\n\n    static createDetached(loader, codeDetails) {\n      return _asyncToGenerator(function* () {\n        const container = new Container(loader, {});\n        return PerformanceEvent.timedExecAsync(container.mc.logger, {\n          eventName: \"CreateDetached\"\n        }, /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (_event) {\n            yield container.createDetached(codeDetails);\n            return container;\n          });\n\n          return function (_x6) {\n            return _ref2.apply(this, arguments);\n          };\n        }(), {\n          start: true,\n          end: true,\n          cancel: \"generic\"\n        });\n      })();\n    }\n    /**\n     * Create a new container in a detached state that is initialized with a\n     * snapshot from a previous detached container.\n     */\n\n\n    static rehydrateDetachedFromSnapshot(loader, snapshot) {\n      return _asyncToGenerator(function* () {\n        const container = new Container(loader, {});\n        return PerformanceEvent.timedExecAsync(container.mc.logger, {\n          eventName: \"RehydrateDetachedFromSnapshot\"\n        }, /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(function* (_event) {\n            const deserializedSummary = JSON.parse(snapshot);\n            yield container.rehydrateDetachedFromSnapshot(deserializedSummary);\n            return container;\n          });\n\n          return function (_x7) {\n            return _ref3.apply(this, arguments);\n          };\n        }(), {\n          start: true,\n          end: true,\n          cancel: \"generic\"\n        });\n      })();\n    }\n\n    setLoaded() {\n      // It's conceivable the container could be closed when this is called\n      // Only transition states if currently loading\n      if (this._lifecycleState === \"loading\") {\n        // Propagate current connection state through the system.\n        this.propagateConnectionState();\n        this._lifecycleState = \"loaded\";\n      }\n    }\n\n    get closed() {\n      return this._lifecycleState === \"closing\" || this._lifecycleState === \"closed\";\n    }\n\n    get storage() {\n      return this._storage;\n    }\n\n    get storageService() {\n      if (this._storageService === undefined) {\n        throw new Error(\"Attempted to access storageService before it was defined\");\n      }\n\n      return this._storageService;\n    }\n\n    get context() {\n      if (this._context === undefined) {\n        throw new GenericError(\"Attempted to access context before it was defined\");\n      }\n\n      return this._context;\n    }\n\n    get protocolHandler() {\n      if (this._protocolHandler === undefined) {\n        throw new Error(\"Attempted to access protocolHandler before it was defined\");\n      }\n\n      return this._protocolHandler;\n    }\n\n    get connectionMode() {\n      return this._deltaManager.connectionManager.connectionMode;\n    }\n\n    get IFluidRouter() {\n      return this;\n    }\n\n    get resolvedUrl() {\n      return this._resolvedUrl;\n    }\n\n    get loadedFromVersion() {\n      return this._loadedFromVersion;\n    }\n\n    get readOnlyInfo() {\n      return this._deltaManager.readOnlyInfo;\n    }\n\n    get closeSignal() {\n      return this._deltaManager.closeAbortController.signal;\n    }\n    /**\n     * Tracks host requiring read-only mode.\n     */\n\n\n    forceReadonly(readonly) {\n      this._deltaManager.connectionManager.forceReadonly(readonly);\n    }\n\n    get deltaManager() {\n      return this._deltaManager;\n    }\n\n    get connectionState() {\n      return this.connectionStateHandler.connectionState;\n    }\n\n    get connected() {\n      return this.connectionStateHandler.connected;\n    }\n    /**\n     * Service configuration details. If running in offline mode will be undefined otherwise will contain service\n     * configuration details returned as part of the initial connection.\n     */\n\n\n    get serviceConfiguration() {\n      return this._deltaManager.serviceConfiguration;\n    }\n    /**\n     * The server provided id of the client.\n     * Set once this.connected is true, otherwise undefined\n     */\n\n\n    get clientId() {\n      return this.connectionStateHandler.clientId;\n    }\n    /**\n     * The server provided claims of the client.\n     * Set once this.connected is true, otherwise undefined\n     */\n\n\n    get scopes() {\n      return this._deltaManager.connectionManager.scopes;\n    }\n\n    get clientDetails() {\n      return this._deltaManager.clientDetails;\n    }\n    /**\n     * Get the code details that are currently specified for the container.\n     * @returns The current code details if any are specified, undefined if none are specified.\n     */\n\n\n    getSpecifiedCodeDetails() {\n      return this.getCodeDetailsFromQuorum();\n    }\n    /**\n     * Get the code details that were used to load the container.\n     * @returns The code details that were used to load the container if it is loaded, undefined if it is not yet\n     * loaded.\n     */\n\n\n    getLoadedCodeDetails() {\n      var _a;\n\n      return (_a = this._context) === null || _a === void 0 ? void 0 : _a.codeDetails;\n    }\n    /**\n     * Retrieves the audience associated with the document\n     */\n\n\n    get audience() {\n      return this._audience;\n    }\n    /**\n     * Returns true if container is dirty.\n     * Which means data loss if container is closed at that same moment\n     * Most likely that happens when there is no network connection to ordering service\n     */\n\n\n    get isDirty() {\n      return this._dirtyContainer;\n    }\n\n    get serviceFactory() {\n      return this.loader.services.documentServiceFactory;\n    }\n\n    get urlResolver() {\n      return this.loader.services.urlResolver;\n    }\n\n    get scope() {\n      return this.loader.services.scope;\n    }\n\n    get codeLoader() {\n      return this.loader.services.codeLoader;\n    }\n    /**\n     * Retrieves the quorum associated with the document\n     */\n\n\n    getQuorum() {\n      return this.protocolHandler.quorum;\n    }\n\n    close(error) {\n      // 1. Ensure that close sequence is exactly the same no matter if it's initiated by host or by DeltaManager\n      // 2. We need to ensure that we deliver disconnect event to runtime properly. See connectionStateChanged\n      //    handler. We only deliver events if container fully loaded. Transitioning from \"loading\" ->\n      //    \"closing\" will lose that info (can also solve by tracking extra state).\n      this._deltaManager.close(error);\n\n      assert(this.connectionState === ConnectionState.Disconnected, 0x0cf\n      /* \"disconnect event was not raised!\" */\n      );\n      assert(this._lifecycleState === \"closed\", 0x314\n      /* Container properly closed */\n      );\n    }\n\n    closeCore(error) {\n      var _a, _b, _c, _d;\n\n      assert(!this.closed, 0x315\n      /* re-entrancy */\n      );\n\n      try {\n        // Ensure that we raise all key events even if one of these throws\n        try {\n          // Raise event first, to ensure we capture _lifecycleState before transition.\n          // This gives us a chance to know what errors happened on open vs. on fully loaded container.\n          this.mc.logger.sendTelemetryEvent({\n            eventName: \"ContainerClose\",\n            category: error === undefined ? \"generic\" : \"error\"\n          }, error);\n          this._lifecycleState = \"closing\";\n          (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.close();\n          this.connectionStateHandler.dispose();\n          (_b = this._context) === null || _b === void 0 ? void 0 : _b.dispose(error !== undefined ? new Error(error.message) : undefined);\n          (_c = this._storageService) === null || _c === void 0 ? void 0 : _c.dispose(); // Notify storage about critical errors. They may be due to disconnect between client & server knowledge\n          // about file, like file being overwritten in storage, but client having stale local cache.\n          // Driver need to ensure all caches are cleared on critical errors\n\n          (_d = this.service) === null || _d === void 0 ? void 0 : _d.dispose(error);\n        } catch (exception) {\n          this.mc.logger.sendErrorEvent({\n            eventName: \"ContainerCloseException\"\n          }, exception);\n        }\n\n        this.emit(\"closed\", error);\n        this.removeAllListeners();\n\n        if (this.visibilityEventHandler !== undefined) {\n          document.removeEventListener(\"visibilitychange\", this.visibilityEventHandler);\n        }\n      } finally {\n        this._lifecycleState = \"closed\";\n      }\n    }\n\n    closeAndGetPendingLocalState() {\n      // runtime matches pending ops to successful ones by clientId and client seq num, so we need to close the\n      // container at the same time we get pending state, otherwise this container could reconnect and resubmit with\n      // a new clientId and a future container using stale pending state without the new clientId would resubmit them\n      assert(this.attachState === AttachState.Attached, 0x0d1\n      /* \"Container should be attached before close\" */\n      );\n      assert(this.resolvedUrl !== undefined && this.resolvedUrl.type === \"fluid\", 0x0d2\n      /* \"resolved url should be valid Fluid url\" */\n      );\n      assert(!!this._protocolHandler, 0x2e3\n      /* \"Must have a valid protocol handler instance\" */\n      );\n      assert(this._protocolHandler.attributes.term !== undefined, 0x30b\n      /* Must have a valid protocol handler instance */\n      );\n      const pendingState = {\n        pendingRuntimeState: this.context.getPendingLocalState(),\n        url: this.resolvedUrl.url,\n        protocol: this.protocolHandler.getProtocolState(),\n        term: this._protocolHandler.attributes.term,\n        clientId: this.clientId\n      };\n      this.close();\n      return JSON.stringify(pendingState);\n    }\n\n    get attachState() {\n      return this._attachState;\n    }\n\n    serialize() {\n      assert(this.attachState === AttachState.Detached, 0x0d3\n      /* \"Should only be called in detached container\" */\n      );\n      const appSummary = this.context.createSummary();\n      const protocolSummary = this.captureProtocolSummary();\n      const combinedSummary = combineAppAndProtocolSummary(appSummary, protocolSummary);\n\n      if (this.loader.services.detachedBlobStorage && this.loader.services.detachedBlobStorage.size > 0) {\n        combinedSummary.tree[\".hasAttachmentBlobs\"] = {\n          type: SummaryType.Blob,\n          content: \"true\"\n        };\n      }\n\n      return JSON.stringify(combinedSummary);\n    }\n\n    attach(request) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        yield PerformanceEvent.timedExecAsync(_this.mc.logger, {\n          eventName: \"Attach\"\n        }, /*#__PURE__*/_asyncToGenerator(function* () {\n          if (_this._lifecycleState !== \"loaded\") {\n            // pre-0.58 error message: containerNotValidForAttach\n            throw new UsageError(`The Container is not in a valid state for attach [${_this._lifecycleState}]`);\n          } // If container is already attached or attach is in progress, throw an error.\n\n\n          assert(_this._attachState === AttachState.Detached && !_this.attachStarted, 0x205\n          /* \"attach() called more than once\" */\n          );\n          _this.attachStarted = true; // If attachment blobs were uploaded in detached state we will go through a different attach flow\n\n          const hasAttachmentBlobs = _this.loader.services.detachedBlobStorage !== undefined && _this.loader.services.detachedBlobStorage.size > 0;\n\n          try {\n            assert(_this.deltaManager.inbound.length === 0, 0x0d6\n            /* \"Inbound queue should be empty when attaching\" */\n            );\n            let summary;\n\n            if (!hasAttachmentBlobs) {\n              // Get the document state post attach - possibly can just call attach but we need to change the\n              // semantics around what the attach means as far as async code goes.\n              const appSummary = _this.context.createSummary();\n\n              const protocolSummary = _this.captureProtocolSummary();\n\n              summary = combineAppAndProtocolSummary(appSummary, protocolSummary); // Set the state as attaching as we are starting the process of attaching container.\n              // This should be fired after taking the summary because it is the place where we are\n              // starting to attach the container to storage.\n              // Also, this should only be fired in detached container.\n\n              _this._attachState = AttachState.Attaching;\n\n              _this.context.notifyAttaching(getSnapshotTreeFromSerializedContainer(summary));\n            } // Actually go and create the resolved document\n\n\n            const createNewResolvedUrl = yield _this.urlResolver.resolve(request);\n            ensureFluidResolvedUrl(createNewResolvedUrl);\n\n            if (_this.service === undefined) {\n              assert(_this.client.details.type !== summarizerClientType, 0x2c4\n              /* \"client should not be summarizer before container is created\" */\n              );\n              _this.service = yield runWithRetry( /*#__PURE__*/_asyncToGenerator(function* () {\n                return _this.serviceFactory.createContainer(summary, createNewResolvedUrl, _this.subLogger, false);\n              }), \"containerAttach\", _this.mc.logger, {\n                cancel: _this.closeSignal\n              });\n            }\n\n            const resolvedUrl = _this.service.resolvedUrl;\n            ensureFluidResolvedUrl(resolvedUrl);\n            _this._resolvedUrl = resolvedUrl;\n            yield _this.connectStorageService();\n\n            if (hasAttachmentBlobs) {\n              // upload blobs to storage\n              assert(!!_this.loader.services.detachedBlobStorage, 0x24e\n              /* \"assertion for type narrowing\" */\n              ); // build a table mapping IDs assigned locally to IDs assigned by storage and pass it to runtime to\n              // support blob handles that only know about the local IDs\n\n              const redirectTable = new Map(); // if new blobs are added while uploading, upload them too\n\n              while (redirectTable.size < _this.loader.services.detachedBlobStorage.size) {\n                const newIds = _this.loader.services.detachedBlobStorage.getBlobIds().filter(id => !redirectTable.has(id));\n\n                for (const id of newIds) {\n                  const blob = yield _this.loader.services.detachedBlobStorage.readBlob(id);\n                  const response = yield _this.storageService.createBlob(blob);\n                  redirectTable.set(id, response.id);\n                }\n              } // take summary and upload\n\n\n              const appSummary = _this.context.createSummary(redirectTable);\n\n              const protocolSummary = _this.captureProtocolSummary();\n\n              summary = combineAppAndProtocolSummary(appSummary, protocolSummary);\n              _this._attachState = AttachState.Attaching;\n\n              _this.context.notifyAttaching(getSnapshotTreeFromSerializedContainer(summary));\n\n              yield _this.storageService.uploadSummaryWithContext(summary, {\n                referenceSequenceNumber: 0,\n                ackHandle: undefined,\n                proposalHandle: undefined\n              });\n            }\n\n            _this._attachState = AttachState.Attached;\n\n            _this.emit(\"attached\"); // Propagate current connection state through the system.\n\n\n            _this.propagateConnectionState();\n\n            if (!_this.closed) {\n              _this.resumeInternal({\n                fetchOpsFromStorage: false,\n                reason: \"createDetached\"\n              });\n            }\n          } catch (error) {\n            // add resolved URL on error object so that host has the ability to find this document and delete it\n            const newError = normalizeError(error);\n            const resolvedUrl = _this.resolvedUrl;\n\n            if (isFluidResolvedUrl(resolvedUrl)) {\n              newError.addTelemetryProperties({\n                resolvedUrl: resolvedUrl.url\n              });\n            }\n\n            _this.close(newError);\n\n            throw newError;\n          }\n        }), {\n          start: true,\n          end: true,\n          cancel: \"generic\"\n        });\n      })();\n    }\n\n    request(path) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        return PerformanceEvent.timedExecAsync(_this2.mc.logger, {\n          eventName: \"Request\"\n        }, /*#__PURE__*/_asyncToGenerator(function* () {\n          return _this2.context.request(path);\n        }), {\n          end: true,\n          cancel: \"error\"\n        });\n      })();\n    }\n\n    setAutoReconnectInternal(mode) {\n      const currentMode = this._deltaManager.connectionManager.reconnectMode;\n\n      if (currentMode === mode) {\n        return;\n      }\n\n      const now = performance.now();\n      const duration = now - this.setAutoReconnectTime;\n      this.setAutoReconnectTime = now;\n      this.mc.logger.sendTelemetryEvent({\n        eventName: mode === ReconnectMode.Enabled ? \"AutoReconnectEnabled\" : \"AutoReconnectDisabled\",\n        connectionMode: this.connectionMode,\n        connectionState: ConnectionState[this.connectionState],\n        duration\n      });\n\n      this._deltaManager.connectionManager.setAutoReconnect(mode);\n    }\n\n    connect() {\n      if (this.closed) {\n        throw new UsageError(`The Container is closed and cannot be connected`);\n      } else if (this._attachState !== AttachState.Attached) {\n        throw new UsageError(`The Container is not attached and cannot be connected`);\n      } else if (!this.connected) {\n        // Note: no need to fetch ops as we do it preemptively as part of DeltaManager.attachOpHandler().\n        // If there is gap, we will learn about it once connected, but the gap should be small (if any),\n        // assuming that connect() is called quickly after initial container boot.\n        this.connectInternal({\n          reason: \"DocumentConnect\",\n          fetchOpsFromStorage: false\n        });\n      }\n    }\n\n    connectInternal(args) {\n      assert(!this.closed, 0x2c5\n      /* \"Attempting to connect() a closed Container\" */\n      );\n      assert(this._attachState === AttachState.Attached, 0x2c6\n      /* \"Attempting to connect() a container that is not attached\" */\n      ); // Resume processing ops and connect to delta stream\n\n      this.resumeInternal(args); // Set Auto Reconnect Mode\n\n      const mode = ReconnectMode.Enabled;\n      this.setAutoReconnectInternal(mode);\n    }\n\n    disconnect() {\n      if (this.closed) {\n        throw new UsageError(`The Container is closed and cannot be disconnected`);\n      } else {\n        this.disconnectInternal();\n      }\n    }\n\n    disconnectInternal() {\n      assert(!this.closed, 0x2c7\n      /* \"Attempting to disconnect() a closed Container\" */\n      ); // Set Auto Reconnect Mode\n\n      const mode = ReconnectMode.Disabled;\n      this.setAutoReconnectInternal(mode);\n    }\n\n    resumeInternal(args) {\n      assert(!this.closed, 0x0d9\n      /* \"Attempting to connect() a closed DeltaManager\" */\n      ); // Resume processing ops\n\n      if (this.inboundQueuePausedFromInit) {\n        this.inboundQueuePausedFromInit = false;\n\n        this._deltaManager.inbound.resume();\n\n        this._deltaManager.inboundSignal.resume();\n      } // Ensure connection to web socket\n\n\n      this.connectToDeltaStream(args);\n    }\n\n    getAbsoluteUrl(relativeUrl) {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        var _a;\n\n        if (_this3.resolvedUrl === undefined) {\n          return undefined;\n        }\n\n        return _this3.urlResolver.getAbsoluteUrl(_this3.resolvedUrl, relativeUrl, getPackageName((_a = _this3._context) === null || _a === void 0 ? void 0 : _a.codeDetails));\n      })();\n    }\n\n    proposeCodeDetails(codeDetails) {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!isFluidCodeDetails(codeDetails)) {\n          throw new Error(\"Provided codeDetails are not IFluidCodeDetails\");\n        }\n\n        if (_this4.codeLoader.IFluidCodeDetailsComparer) {\n          const comparison = yield _this4.codeLoader.IFluidCodeDetailsComparer.compare(codeDetails, _this4.getCodeDetailsFromQuorum());\n\n          if (comparison !== undefined && comparison <= 0) {\n            throw new Error(\"Proposed code details should be greater than the current\");\n          }\n        }\n\n        return _this4.protocolHandler.quorum.propose(\"code\", codeDetails).then(() => true).catch(() => false);\n      })();\n    }\n\n    processCodeProposal() {\n      var _this5 = this;\n\n      return _asyncToGenerator(function* () {\n        const codeDetails = _this5.getCodeDetailsFromQuorum();\n\n        yield Promise.all([_this5.deltaManager.inbound.pause(), _this5.deltaManager.inboundSignal.pause()]);\n\n        if ((yield _this5.context.satisfies(codeDetails)) === true) {\n          _this5.deltaManager.inbound.resume();\n\n          _this5.deltaManager.inboundSignal.resume();\n\n          return;\n        } // pre-0.58 error message: existingContextDoesNotSatisfyIncomingProposal\n\n\n        _this5.close(new GenericError(\"Existing context does not satisfy incoming proposal\"));\n      })();\n    }\n\n    getVersion(version) {\n      var _this6 = this;\n\n      return _asyncToGenerator(function* () {\n        const versions = yield _this6.storageService.getVersions(version, 1);\n        return versions[0];\n      })();\n    }\n\n    recordConnectStartTime() {\n      if (this.connectionTransitionTimes[ConnectionState.Disconnected] === undefined) {\n        this.connectionTransitionTimes[ConnectionState.Disconnected] = performance.now();\n      }\n    }\n\n    connectToDeltaStream(args) {\n      this.recordConnectStartTime(); // All agents need \"write\" access, including summarizer.\n\n      if (!this._canReconnect || !this.client.details.capabilities.interactive) {\n        args.mode = \"write\";\n      }\n\n      this._deltaManager.connect(args);\n    }\n    /**\n     * Load container.\n     *\n     * @param specifiedVersion - one of the following\n     *   - undefined - fetch latest snapshot\n     *   - otherwise, version sha to load snapshot\n     */\n\n\n    load(specifiedVersion, loadMode, pendingLocalState) {\n      var _this7 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this7._resolvedUrl === undefined) {\n          throw new Error(\"Attempting to load without a resolved url\");\n        }\n\n        _this7.service = yield _this7.serviceFactory.createDocumentService(_this7._resolvedUrl, _this7.subLogger, _this7.client.details.type === summarizerClientType); // Ideally we always connect as \"read\" by default.\n        // Currently that works with SPO & r11s, because we get \"write\" connection when connecting to non-existing file.\n        // We should not rely on it by (one of them will address the issue, but we need to address both)\n        // 1) switching create new flow to one where we create file by posting snapshot\n        // 2) Fixing quorum workflows (have retry logic)\n        // That all said, \"read\" does not work with memorylicious workflows (that opens two simultaneous\n        // connections to same file) in two ways:\n        // A) creation flow breaks (as one of the clients \"sees\" file as existing, and hits #2 above)\n        // B) Once file is created, transition from view-only connection to write does not work - some bugs to be fixed.\n\n        const connectionArgs = {\n          reason: \"DocumentOpen\",\n          mode: \"write\",\n          fetchOpsFromStorage: false\n        }; // Start websocket connection as soon as possible. Note that there is no op handler attached yet, but the\n        // DeltaManager is resilient to this and will wait to start processing ops until after it is attached.\n\n        if (loadMode.deltaConnection === undefined) {\n          _this7.connectToDeltaStream(connectionArgs);\n        }\n\n        if (!pendingLocalState) {\n          yield _this7.connectStorageService();\n        } else {\n          // if we have pendingLocalState we can load without storage; don't wait for connection\n          _this7.connectStorageService().catch(error => _this7.close(error));\n        }\n\n        _this7._attachState = AttachState.Attached; // Fetch specified snapshot.\n\n        const {\n          snapshot,\n          versionId\n        } = pendingLocalState === undefined ? yield _this7.fetchSnapshotTree(specifiedVersion) : {\n          snapshot: undefined,\n          versionId: undefined\n        };\n        assert(snapshot !== undefined || pendingLocalState !== undefined, 0x237\n        /* \"Snapshot should exist\" */\n        );\n        const attributes = pendingLocalState === undefined ? yield _this7.getDocumentAttributes(_this7.storageService, snapshot) : {\n          sequenceNumber: pendingLocalState.protocol.sequenceNumber,\n          minimumSequenceNumber: pendingLocalState.protocol.minimumSequenceNumber,\n          term: pendingLocalState.term\n        };\n        let opsBeforeReturnP; // Attach op handlers to finish initialization and be able to start processing ops\n        // Kick off any ops fetching if required.\n\n        switch (loadMode.opsBeforeReturn) {\n          case undefined:\n            // Start prefetch, but not set opsBeforeReturnP - boot is not blocked by it!\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            _this7.attachDeltaManagerOpHandler(attributes, loadMode.deltaConnection !== \"none\" ? \"all\" : \"none\");\n\n            break;\n\n          case \"cached\":\n            opsBeforeReturnP = _this7.attachDeltaManagerOpHandler(attributes, \"cached\");\n            break;\n\n          case \"all\":\n            opsBeforeReturnP = _this7.attachDeltaManagerOpHandler(attributes, \"all\");\n            break;\n\n          default:\n            unreachableCase(loadMode.opsBeforeReturn);\n        } // ...load in the existing quorum\n        // Initialize the protocol handler\n\n\n        _this7._protocolHandler = pendingLocalState === undefined ? yield _this7.initializeProtocolStateFromSnapshot(attributes, _this7.storageService, snapshot) : yield _this7.initializeProtocolState(attributes, pendingLocalState.protocol.members, pendingLocalState.protocol.proposals, pendingLocalState.protocol.values);\n\n        const codeDetails = _this7.getCodeDetailsFromQuorum();\n\n        yield _this7.instantiateContext(true, // existing\n        codeDetails, snapshot, pendingLocalState === null || pendingLocalState === void 0 ? void 0 : pendingLocalState.pendingRuntimeState); // We might have hit some failure that did not manifest itself in exception in this flow,\n        // do not start op processing in such case - static version of Container.load() will handle it correctly.\n\n        if (!_this7.closed) {\n          if (opsBeforeReturnP !== undefined) {\n            _this7._deltaManager.inbound.resume();\n\n            yield ReportIfTooLong(_this7.mc.logger, \"WaitOps\", /*#__PURE__*/_asyncToGenerator(function* () {\n              yield opsBeforeReturnP;\n              return {};\n            }));\n            yield ReportIfTooLong(_this7.mc.logger, \"WaitOpProcessing\", /*#__PURE__*/_asyncToGenerator(function* () {\n              return _this7._deltaManager.inbound.waitTillProcessingDone();\n            })); // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n            _this7._deltaManager.inbound.pause();\n          }\n\n          switch (loadMode.deltaConnection) {\n            case undefined:\n            case \"delayed\":\n              assert(_this7.inboundQueuePausedFromInit, 0x346\n              /* inboundQueuePausedFromInit should be true */\n              );\n              _this7.inboundQueuePausedFromInit = false;\n\n              _this7._deltaManager.inbound.resume();\n\n              _this7._deltaManager.inboundSignal.resume();\n\n              break;\n\n            case \"none\":\n              break;\n\n            default:\n              unreachableCase(loadMode.deltaConnection);\n          }\n        } // Safety net: static version of Container.load() should have learned about it through \"closed\" handler.\n        // But if that did not happen for some reason, fail load for sure.\n        // Otherwise we can get into situations where container is closed and does not try to connect to ordering\n        // service, but caller does not know that (callers do expect container to be not closed on successful path\n        // and listen only on \"closed\" event)\n\n\n        if (_this7.closed) {\n          throw new Error(\"Container was closed while load()\");\n        } // Internal context is fully loaded at this point\n\n\n        _this7.setLoaded();\n\n        return {\n          sequenceNumber: attributes.sequenceNumber,\n          version: versionId,\n          dmLastProcessedSeqNumber: _this7._deltaManager.lastSequenceNumber,\n          dmLastKnownSeqNumber: _this7._deltaManager.lastKnownSeqNumber\n        };\n      })();\n    }\n\n    createDetached(source) {\n      var _this8 = this;\n\n      return _asyncToGenerator(function* () {\n        const attributes = {\n          sequenceNumber: detachedContainerRefSeqNumber,\n          term: 1,\n          minimumSequenceNumber: 0\n        };\n        yield _this8.attachDeltaManagerOpHandler(attributes); // Need to just seed the source data in the code quorum. Quorum itself is empty\n\n        const qValues = initQuorumValuesFromCodeDetails(source);\n        _this8._protocolHandler = yield _this8.initializeProtocolState(attributes, [], // members\n        [], // proposals\n        qValues); // The load context - given we seeded the quorum - will be great\n\n        yield _this8.instantiateContextDetached(false);\n\n        _this8.setLoaded();\n      })();\n    }\n\n    rehydrateDetachedFromSnapshot(detachedContainerSnapshot) {\n      var _this9 = this;\n\n      return _asyncToGenerator(function* () {\n        if (detachedContainerSnapshot.tree[\".hasAttachmentBlobs\"] !== undefined) {\n          assert(!!_this9.loader.services.detachedBlobStorage && _this9.loader.services.detachedBlobStorage.size > 0, 0x250\n          /* \"serialized container with attachment blobs must be rehydrated with detached blob storage\" */\n          );\n          delete detachedContainerSnapshot.tree[\".hasAttachmentBlobs\"];\n        }\n\n        const snapshotTree = getSnapshotTreeFromSerializedContainer(detachedContainerSnapshot);\n\n        _this9._storage.loadSnapshotForRehydratingContainer(snapshotTree);\n\n        const attributes = yield _this9.getDocumentAttributes(_this9._storage, snapshotTree);\n        yield _this9.attachDeltaManagerOpHandler(attributes); // Initialize the protocol handler\n\n        const baseTree = getProtocolSnapshotTree(snapshotTree);\n        const qValues = yield readAndParse(_this9._storage, baseTree.blobs.quorumValues);\n        const codeDetails = getCodeDetailsFromQuorumValues(qValues);\n        _this9._protocolHandler = yield _this9.initializeProtocolState(attributes, [], // members\n        [], // proposals\n        codeDetails !== undefined ? initQuorumValuesFromCodeDetails(codeDetails) : []);\n        yield _this9.instantiateContextDetached(true, // existing\n        snapshotTree);\n\n        _this9.setLoaded();\n      })();\n    }\n\n    connectStorageService() {\n      var _this10 = this;\n\n      return _asyncToGenerator(function* () {\n        var _a, _b;\n\n        if (_this10._storageService !== undefined) {\n          return;\n        }\n\n        assert(_this10.service !== undefined, 0x1ef\n        /* \"services must be defined\" */\n        );\n        const storageService = yield _this10.service.connectToStorage();\n        _this10._storageService = new RetriableDocumentStorageService(storageService, _this10.mc.logger);\n\n        if (_this10.options.summarizeProtocolTree === true) {\n          _this10.mc.logger.sendTelemetryEvent({\n            eventName: \"summarizeProtocolTreeEnabled\"\n          });\n\n          _this10._storageService = new ProtocolTreeStorageService(_this10._storageService, () => _this10.captureProtocolSummary());\n        } // ensure we did not lose that policy in the process of wrapping\n\n\n        assert(((_a = storageService.policies) === null || _a === void 0 ? void 0 : _a.minBlobSize) === ((_b = _this10.storageService.policies) === null || _b === void 0 ? void 0 : _b.minBlobSize), 0x0e0\n        /* \"lost minBlobSize policy\" */\n        );\n      })();\n    }\n\n    getDocumentAttributes(storage, tree) {\n      return _asyncToGenerator(function* () {\n        if (tree === undefined) {\n          return {\n            minimumSequenceNumber: 0,\n            sequenceNumber: 0,\n            term: 1\n          };\n        } // Backward compatibility: old docs would have \".attributes\" instead of \"attributes\"\n\n\n        const attributesHash = \".protocol\" in tree.trees ? tree.trees[\".protocol\"].blobs.attributes : tree.blobs[\".attributes\"];\n        const attributes = yield readAndParse(storage, attributesHash); // Backward compatibility for older summaries with no term\n\n        if (attributes.term === undefined) {\n          attributes.term = 1;\n        }\n\n        return attributes;\n      })();\n    }\n\n    initializeProtocolStateFromSnapshot(attributes, storage, snapshot) {\n      var _this11 = this;\n\n      return _asyncToGenerator(function* () {\n        let members = [];\n        let proposals = [];\n        let values = [];\n\n        if (snapshot !== undefined) {\n          const baseTree = getProtocolSnapshotTree(snapshot);\n          [members, proposals, values] = yield Promise.all([readAndParse(storage, baseTree.blobs.quorumMembers), readAndParse(storage, baseTree.blobs.quorumProposals), readAndParse(storage, baseTree.blobs.quorumValues)]);\n        }\n\n        const protocolHandler = yield _this11.initializeProtocolState(attributes, members, proposals, values);\n        return protocolHandler;\n      })();\n    }\n\n    initializeProtocolState(attributes, members, proposals, values) {\n      var _this12 = this;\n\n      return _asyncToGenerator(function* () {\n        const protocol = new ProtocolOpHandlerWithClientValidation(attributes.minimumSequenceNumber, attributes.sequenceNumber, attributes.term, members, proposals, values, (key, value) => _this12.submitMessage(MessageType.Propose, {\n          key,\n          value\n        }));\n        const protocolLogger = ChildLogger.create(_this12.subLogger, \"ProtocolHandler\");\n        protocol.quorum.on(\"error\", error => {\n          protocolLogger.sendErrorEvent(error);\n        }); // Track membership changes and update connection state accordingly\n\n        _this12.connectionStateHandler.initProtocol(protocol);\n\n        protocol.quorum.on(\"addProposal\", proposal => {\n          if (proposal.key === \"code\" || proposal.key === \"code2\") {\n            _this12.emit(\"codeDetailsProposed\", proposal.value, proposal);\n          }\n        });\n        protocol.quorum.on(\"approveProposal\", (sequenceNumber, key, value) => {\n          if (key === \"code\" || key === \"code2\") {\n            if (!isFluidCodeDetails(value)) {\n              _this12.mc.logger.sendErrorEvent({\n                eventName: \"CodeProposalNotIFluidCodeDetails\"\n              });\n            }\n\n            _this12.processCodeProposal().catch(error => {\n              _this12.close(normalizeError(error));\n\n              throw error;\n            });\n          }\n        });\n        return protocol;\n      })();\n    }\n\n    captureProtocolSummary() {\n      const quorumSnapshot = this.protocolHandler.snapshot();\n      const summary = {\n        tree: {\n          attributes: {\n            content: JSON.stringify(this.protocolHandler.attributes),\n            type: SummaryType.Blob\n          },\n          quorumMembers: {\n            content: JSON.stringify(quorumSnapshot.members),\n            type: SummaryType.Blob\n          },\n          quorumProposals: {\n            content: JSON.stringify(quorumSnapshot.proposals),\n            type: SummaryType.Blob\n          },\n          quorumValues: {\n            content: JSON.stringify(quorumSnapshot.values),\n            type: SummaryType.Blob\n          }\n        },\n        type: SummaryType.Tree\n      };\n      return summary;\n    }\n\n    getCodeDetailsFromQuorum() {\n      const quorum = this.protocolHandler.quorum;\n      const pkg = getCodeProposal(quorum);\n      return pkg;\n    }\n\n    get client() {\n      var _a;\n\n      const client = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.client) !== undefined ? this.options.client : {\n        details: {\n          capabilities: {\n            interactive: true\n          }\n        },\n        mode: \"read\",\n        permission: [],\n        scopes: [],\n        user: {\n          id: \"\"\n        }\n      };\n\n      if (this.clientDetailsOverride !== undefined) {\n        merge(client.details, this.clientDetailsOverride);\n      }\n\n      client.details.environment = [client.details.environment, ` loaderVersion:${pkgVersion}`].join(\";\");\n      return client;\n    }\n    /**\n     * Returns true if connection is active, i.e. it's \"write\" connection and\n     * container runtime was notified about this connection (i.e. we are up-to-date and could send ops).\n     * This happens after client received its own joinOp and thus is in the quorum.\n     * If it's not true, runtime is not in position to send ops.\n     */\n\n\n    activeConnection() {\n      return this.connectionState === ConnectionState.Connected && this.connectionMode === \"write\";\n    }\n\n    createDeltaManager() {\n      const serviceProvider = () => this.service;\n\n      const deltaManager = new DeltaManager(serviceProvider, ChildLogger.create(this.subLogger, \"DeltaManager\"), () => this.activeConnection(), props => new ConnectionManager(serviceProvider, this.client, this._canReconnect, ChildLogger.create(this.subLogger, \"ConnectionManager\"), props)); // Disable inbound queues as Container is not ready to accept any ops until we are fully loaded!\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n      deltaManager.inbound.pause(); // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n      deltaManager.inboundSignal.pause();\n      deltaManager.on(\"connect\", (details, opsBehind) => {\n        var _a; // Back-compat for new client and old server.\n\n\n        this._audience.clear();\n\n        for (const priorClient of (_a = details.initialClients) !== null && _a !== void 0 ? _a : []) {\n          this._audience.addMember(priorClient.clientId, priorClient.client);\n        }\n\n        this.connectionStateHandler.receivedConnectEvent(this.connectionMode, details);\n      });\n      deltaManager.on(\"disconnect\", reason => {\n        var _a;\n\n        (_a = this.collabWindowTracker) === null || _a === void 0 ? void 0 : _a.stopSequenceNumberUpdate();\n        this.connectionStateHandler.receivedDisconnectEvent(reason);\n      });\n      deltaManager.on(\"throttled\", warning => {\n        const warn = warning; // Some \"warning\" events come from outside the container and are logged\n        // elsewhere (e.g. summarizing container). We shouldn't log these here.\n\n        if (warn.logged !== true) {\n          this.logContainerError(warn);\n        }\n\n        this.emit(\"warning\", warn);\n      });\n      deltaManager.on(\"readonly\", readonly => {\n        this.emit(\"readonly\", readonly);\n      });\n      deltaManager.on(\"closed\", error => {\n        this.closeCore(error);\n      });\n      return deltaManager;\n    }\n\n    attachDeltaManagerOpHandler(attributes, prefetchType) {\n      var _this13 = this;\n\n      return _asyncToGenerator(function* () {\n        var _a;\n\n        return _this13._deltaManager.attachOpHandler(attributes.minimumSequenceNumber, attributes.sequenceNumber, (_a = attributes.term) !== null && _a !== void 0 ? _a : 1, {\n          process: message => _this13.processRemoteMessage(message),\n          processSignal: message => {\n            _this13.processSignal(message);\n          }\n        }, prefetchType);\n      })();\n    }\n\n    logConnectionStateChangeTelemetry(value, oldState, reason) {\n      var _a; // Log actual event\n\n\n      const time = performance.now();\n      this.connectionTransitionTimes[value] = time;\n      const duration = time - this.connectionTransitionTimes[oldState];\n      let durationFromDisconnected;\n      let connectionInitiationReason;\n      let autoReconnect;\n      let checkpointSequenceNumber;\n      let opsBehind;\n\n      if (value === ConnectionState.Disconnected) {\n        autoReconnect = this._deltaManager.connectionManager.reconnectMode;\n      } else {\n        if (value === ConnectionState.Connected) {\n          durationFromDisconnected = time - this.connectionTransitionTimes[ConnectionState.Disconnected];\n          durationFromDisconnected = TelemetryLogger.formatTick(durationFromDisconnected);\n        } else {\n          // This info is of most interest on establishing connection only.\n          checkpointSequenceNumber = this.deltaManager.lastKnownSeqNumber;\n\n          if (this.deltaManager.hasCheckpointSequenceNumber) {\n            opsBehind = checkpointSequenceNumber - this.deltaManager.lastSequenceNumber;\n          }\n        }\n\n        if (this.firstConnection) {\n          connectionInitiationReason = \"InitialConnect\";\n        } else {\n          connectionInitiationReason = \"AutoReconnect\";\n        }\n      }\n\n      this.mc.logger.sendPerformanceEvent(Object.assign({\n        eventName: `ConnectionStateChange_${ConnectionState[value]}`,\n        from: ConnectionState[oldState],\n        duration,\n        durationFromDisconnected,\n        reason,\n        connectionInitiationReason,\n        pendingClientId: this.connectionStateHandler.pendingClientId,\n        clientId: this.clientId,\n        autoReconnect,\n        opsBehind,\n        online: OnlineStatus[isOnline()],\n        lastVisible: this.lastVisible !== undefined ? performance.now() - this.lastVisible : undefined,\n        checkpointSequenceNumber,\n        quorumSize: (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.quorum.getMembers().size\n      }, this._deltaManager.connectionProps));\n\n      if (value === ConnectionState.Connected) {\n        this.firstConnection = false;\n      }\n    }\n\n    propagateConnectionState() {\n      var _a;\n\n      const logOpsOnReconnect = this.connectionState === ConnectionState.Connected && !this.firstConnection && this.connectionMode === \"write\";\n\n      if (logOpsOnReconnect) {\n        this.messageCountAfterDisconnection = 0;\n      }\n\n      const state = this.connectionState === ConnectionState.Connected; // Both protocol and context should not be undefined if we got so far.\n\n      if (((_a = this._context) === null || _a === void 0 ? void 0 : _a.disposed) === false) {\n        this.context.setConnectionState(state, this.clientId);\n      }\n\n      this.protocolHandler.setConnectionState(state, this.clientId);\n      raiseConnectedEvent(this.mc.logger, this, state, this.clientId);\n\n      if (logOpsOnReconnect) {\n        this.mc.logger.sendTelemetryEvent({\n          eventName: \"OpsSentOnReconnect\",\n          count: this.messageCountAfterDisconnection\n        });\n      }\n    }\n\n    submitContainerMessage(type, contents, batch, metadata) {\n      const outboundMessageType = type;\n\n      switch (outboundMessageType) {\n        case MessageType.Operation:\n        case MessageType.RemoteHelp:\n          break;\n\n        case MessageType.Summarize:\n          {\n            // github #6451: this is only needed for staging so the server\n            // know when the protocol tree is included\n            // this can be removed once all clients send\n            // protocol tree by default\n            const summary = contents;\n\n            if (summary.details === undefined) {\n              summary.details = {};\n            }\n\n            summary.details.includesProtocolTree = this.options.summarizeProtocolTree === true;\n            break;\n          }\n\n        default:\n          this.close(new GenericError(\"invalidContainerSubmitOpType\", undefined\n          /* error */\n          , {\n            messageType: type\n          }));\n          return -1;\n      }\n\n      return this.submitMessage(type, contents, batch, metadata);\n    }\n\n    submitMessage(type, contents, batch, metadata) {\n      var _a;\n\n      if (this.connectionState !== ConnectionState.Connected) {\n        this.mc.logger.sendErrorEvent({\n          eventName: \"SubmitMessageWithNoConnection\",\n          type\n        });\n        return -1;\n      }\n\n      this.messageCountAfterDisconnection += 1;\n      (_a = this.collabWindowTracker) === null || _a === void 0 ? void 0 : _a.stopSequenceNumberUpdate();\n      return this._deltaManager.submit(type, contents, batch, metadata);\n    }\n\n    processRemoteMessage(message) {\n      const local = this.clientId === message.clientId; // Allow the protocol handler to process the message\n\n      let result = {\n        immediateNoOp: false\n      };\n\n      try {\n        result = this.protocolHandler.processMessage(message, local);\n      } catch (error) {\n        this.close(wrapError(error, errorMessage => new DataCorruptionError(errorMessage, extractSafePropertiesFromMessage(message))));\n      } // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\n\n      if (isUnpackedRuntimeMessage(message) && !isRuntimeMessage(message)) {\n        this.mc.logger.sendTelemetryEvent({\n          eventName: \"UnpackedRuntimeMessage\",\n          type: message.type\n        });\n      } // Forward non system messages to the loaded runtime for processing\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\n\n      if (isRuntimeMessage(message) || isUnpackedRuntimeMessage(message)) {\n        this.context.process(message, local, undefined);\n      } // Inactive (not in quorum or not writers) clients don't take part in the minimum sequence number calculation.\n\n\n      if (this.activeConnection()) {\n        if (this.collabWindowTracker === undefined) {\n          // Note that config from first connection will be used for this container's lifetime.\n          // That means that if relay service changes settings, such changes will impact only newly booted\n          // clients.\n          // All existing will continue to use settings they got earlier.\n          assert(this.serviceConfiguration !== undefined, 0x2e4\n          /* \"there should be service config for active connection\" */\n          );\n          this.collabWindowTracker = new CollabWindowTracker((type, contents) => {\n            assert(this.activeConnection(), 0x241\n            /* \"disconnect should result in stopSequenceNumberUpdate() call\" */\n            );\n            this.submitMessage(type, contents);\n          }, this.serviceConfiguration.noopTimeFrequency, this.serviceConfiguration.noopCountFrequency);\n        }\n\n        this.collabWindowTracker.scheduleSequenceNumberUpdate(message, result.immediateNoOp === true);\n      }\n\n      this.emit(\"op\", message);\n      return result;\n    }\n\n    submitSignal(message) {\n      this._deltaManager.submitSignal(JSON.stringify(message));\n    }\n\n    processSignal(message) {\n      // No clientId indicates a system signal message.\n      if (message.clientId === null) {\n        const innerContent = message.content;\n\n        if (innerContent.type === MessageType.ClientJoin) {\n          const newClient = innerContent.content;\n\n          this._audience.addMember(newClient.clientId, newClient.client);\n        } else if (innerContent.type === MessageType.ClientLeave) {\n          const leftClientId = innerContent.content;\n\n          this._audience.removeMember(leftClientId);\n        }\n      } else {\n        const local = this.clientId === message.clientId;\n        this.context.processSignal(message, local);\n      }\n    }\n    /**\n     * Get the most recent snapshot, or a specific version.\n     * @param specifiedVersion - The specific version of the snapshot to retrieve\n     * @returns The snapshot requested, or the latest snapshot if no version was specified, plus version ID\n     */\n\n\n    fetchSnapshotTree(specifiedVersion) {\n      var _this14 = this;\n\n      return _asyncToGenerator(function* () {\n        var _a;\n\n        const version = yield _this14.getVersion(specifiedVersion !== null && specifiedVersion !== void 0 ? specifiedVersion : null);\n\n        if (version === undefined && specifiedVersion !== undefined) {\n          // We should have a defined version to load from if specified version requested\n          _this14.mc.logger.sendErrorEvent({\n            eventName: \"NoVersionFoundWhenSpecified\",\n            id: specifiedVersion\n          });\n        }\n\n        _this14._loadedFromVersion = version;\n        const snapshot = (_a = yield _this14.storageService.getSnapshotTree(version)) !== null && _a !== void 0 ? _a : undefined;\n\n        if (snapshot === undefined && version !== undefined) {\n          _this14.mc.logger.sendErrorEvent({\n            eventName: \"getSnapshotTreeFailed\",\n            id: version.id\n          });\n        }\n\n        return {\n          snapshot,\n          versionId: version === null || version === void 0 ? void 0 : version.id\n        };\n      })();\n    }\n\n    instantiateContextDetached(existing, snapshot) {\n      var _this15 = this;\n\n      return _asyncToGenerator(function* () {\n        const codeDetails = _this15.getCodeDetailsFromQuorum();\n\n        if (codeDetails === undefined) {\n          throw new Error(\"pkg should be provided in create flow!!\");\n        }\n\n        yield _this15.instantiateContext(existing, codeDetails, snapshot);\n      })();\n    }\n\n    instantiateContext(existing, codeDetails, snapshot, pendingLocalState) {\n      var _this16 = this;\n\n      return _asyncToGenerator(function* () {\n        var _a;\n\n        assert(((_a = _this16._context) === null || _a === void 0 ? void 0 : _a.disposed) !== false, 0x0dd\n        /* \"Existing context not disposed\" */\n        ); // The relative loader will proxy requests to '/' to the loader itself assuming no non-cache flags\n        // are set. Global requests will still go directly to the loader\n\n        const loader = new RelativeLoader(_this16, _this16.loader);\n        _this16._context = yield ContainerContext.createOrLoad(_this16, _this16.scope, _this16.codeLoader, codeDetails, snapshot, new DeltaManagerProxy(_this16._deltaManager), new QuorumProxy(_this16.protocolHandler.quorum), loader, (type, contents, batch, metadata) => _this16.submitContainerMessage(type, contents, batch, metadata), message => _this16.submitSignal(message), error => _this16.close(error), Container.version, dirty => _this16.updateDirtyContainerState(dirty), existing, pendingLocalState);\n\n        _this16.emit(\"contextChanged\", codeDetails);\n      })();\n    }\n\n    updateDirtyContainerState(dirty) {\n      if (this._dirtyContainer === dirty) {\n        return;\n      }\n\n      this._dirtyContainer = dirty;\n      this.emit(dirty ? dirtyContainerEvent : savedContainerEvent);\n    }\n\n    logContainerError(warning) {\n      this.mc.logger.sendErrorEvent({\n        eventName: \"ContainerWarning\"\n      }, warning);\n    }\n\n  }\n\n  Container.version = \"^0.1.0\"; //# sourceMappingURL=container.js.map\n\n  return Container;\n})();","map":null,"metadata":{},"sourceType":"module"}