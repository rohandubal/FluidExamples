{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventEmitter } from \"events\"; // eslint-disable-next-line import/no-internal-modules\n\nimport cloneDeep from \"lodash/cloneDeep\";\nimport { assert, TypedEventEmitter } from \"@fluidframework/common-utils\";\n/**\n * Structure for tracking proposals that have been sequenced but not approved yet.\n */\n\nclass PendingProposal {\n  constructor(sequenceNumber, key, value, local) {\n    this.sequenceNumber = sequenceNumber;\n    this.key = key;\n    this.value = value;\n    this.local = local;\n  }\n\n}\n/**\n * The QuorumClients is used to track members joining and leaving the collaboration session.\n */\n\n\nexport class QuorumClients extends TypedEventEmitter {\n  constructor(snapshot) {\n    super();\n    this.isDisposed = false;\n    this.members = new Map(snapshot);\n    this.snapshotCache = snapshot;\n  }\n\n  get disposed() {\n    return this.isDisposed;\n  }\n  /**\n   * Snapshots the current state of the QuorumClients\n   * @returns a snapshot of the clients in the quorum\n   */\n\n\n  snapshot() {\n    var _a;\n\n    (_a = this.snapshotCache) !== null && _a !== void 0 ? _a : this.snapshotCache = cloneDeep(Array.from(this.members));\n    return this.snapshotCache;\n  }\n  /**\n   * Adds a new client to the quorum\n   */\n\n\n  addMember(clientId, details) {\n    assert(!this.members.has(clientId), 0x1ce\n    /* clientId not found */\n    );\n    this.members.set(clientId, details);\n    this.emit(\"addMember\", clientId, details); // clear the cache\n\n    this.snapshotCache = undefined;\n  }\n  /**\n   * Removes a client from the quorum\n   */\n\n\n  removeMember(clientId) {\n    assert(this.members.has(clientId), 0x1cf\n    /* clientId not found */\n    );\n    this.members.delete(clientId);\n    this.emit(\"removeMember\", clientId); // clear the cache\n\n    this.snapshotCache = undefined;\n  }\n  /**\n   * Retrieves all the members in the quorum\n   */\n\n\n  getMembers() {\n    return new Map(this.members);\n  }\n  /**\n   * Retrieves a specific member of the quorum\n   */\n\n\n  getMember(clientId) {\n    return this.members.get(clientId);\n  }\n\n  dispose() {\n    this.isDisposed = true;\n  }\n\n}\n/**\n * The QuorumProposals holds a key/value store.  Proposed values become finalized in the store once all connected\n * clients have seen the proposal.\n */\n\nexport class QuorumProposals extends TypedEventEmitter {\n  constructor(snapshot, sendProposal) {\n    super();\n    this.sendProposal = sendProposal;\n    this.isDisposed = false; // Event emitter for changes to the environment that affect pending proposal promises.\n\n    this.stateEvents = new EventEmitter();\n    this.proposals = new Map(snapshot.proposals.map(([, proposal]) => {\n      return [proposal.sequenceNumber, new PendingProposal(proposal.sequenceNumber, proposal.key, proposal.value, false)];\n    }));\n    this.values = new Map(snapshot.values);\n    this.proposalsSnapshotCache = snapshot.proposals;\n    this.valuesSnapshotCache = snapshot.values;\n  }\n\n  get disposed() {\n    return this.isDisposed;\n  }\n  /**\n   * Snapshots the current state of the QuorumProposals\n   * @returns deep cloned arrays of proposals and values\n   */\n\n\n  snapshot() {\n    var _a, _b;\n\n    (_a = this.proposalsSnapshotCache) !== null && _a !== void 0 ? _a : this.proposalsSnapshotCache = Array.from(this.proposals).map(([sequenceNumber, proposal]) => [sequenceNumber, {\n      sequenceNumber,\n      key: proposal.key,\n      value: proposal.value\n    }, [] // rejections, which has been removed\n    ]);\n    (_b = this.valuesSnapshotCache) !== null && _b !== void 0 ? _b : this.valuesSnapshotCache = cloneDeep(Array.from(this.values));\n    return {\n      proposals: this.proposalsSnapshotCache,\n      values: this.valuesSnapshotCache\n    };\n  }\n  /**\n   * Returns whether the quorum has achieved a consensus for the given key.\n   */\n\n\n  has(key) {\n    return this.values.has(key);\n  }\n  /**\n   * Returns the consensus value for the given key\n   */\n\n\n  get(key) {\n    var _a;\n\n    return (_a = this.values.get(key)) === null || _a === void 0 ? void 0 : _a.value;\n  }\n  /**\n   * Returns additional data about the approved consensus value\n   * @deprecated Removed in recent protocol-definitions.  Use get() instead.\n   */\n\n\n  getApprovalData(key) {\n    const proposal = this.values.get(key);\n    return proposal ? cloneDeep(proposal) : undefined;\n  }\n  /**\n   * Proposes a new value. Returns a promise that will either:\n   * - Resolve when the proposal is accepted\n   * - Reject if the proposal fails to send or if the QuorumProposals is disposed\n   */\n\n\n  propose(key, value) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const clientSequenceNumber = _this.sendProposal(key, value);\n\n      if (clientSequenceNumber < 0) {\n        _this.emit(\"error\", {\n          eventName: \"ProposalInDisconnectedState\",\n          key\n        });\n\n        throw new Error(\"Can't propose in disconnected state\");\n      }\n\n      return new Promise((resolve, reject) => {\n        // The sequence number that our proposal was assigned and went pending.\n        // If undefined, then it's not sequenced yet.\n        let thisProposalSequenceNumber; // A proposal goes through two phases before this promise resolves:\n        // 1. Sequencing - waiting for the proposal to be ack'd by the server.\n        // 2. Approval - waiting for the proposal to be approved by connected clients.\n\n        const localProposalSequencedHandler = (sequencedCSN, sequenceNumber) => {\n          if (sequencedCSN === clientSequenceNumber) {\n            thisProposalSequenceNumber = sequenceNumber;\n\n            _this.stateEvents.off(\"localProposalSequenced\", localProposalSequencedHandler);\n\n            _this.stateEvents.off(\"disconnected\", disconnectedHandler);\n\n            _this.stateEvents.on(\"localProposalApproved\", localProposalApprovedHandler);\n          }\n        };\n\n        const localProposalApprovedHandler = sequenceNumber => {\n          // Proposals can be uniquely identified by the sequenceNumber they were assigned.\n          if (sequenceNumber === thisProposalSequenceNumber) {\n            resolve();\n            removeListeners();\n          }\n        }; // There are two error flows we consider:  disconnect and disposal.\n        // If we get disconnected before the proposal is sequenced, it has one of two possible futures:\n        // 1. We reconnect and see the proposal was sequenced in the meantime.\n        //    -> The promise can still resolve, once it is approved.\n        // 2. We reconnect and see the proposal was not sequenced in the meantime, so it will never sequence.\n        //    -> The promise rejects.\n\n\n        const disconnectedHandler = () => {\n          // If we haven't seen the ack by the time we disconnect, we hope to see it by the time we reconnect.\n          if (thisProposalSequenceNumber === undefined) {\n            _this.stateEvents.once(\"connected\", () => {\n              // If we don't see the ack by the time reconnection finishes, it failed to send.\n              if (thisProposalSequenceNumber === undefined) {\n                reject(new Error(\"Client disconnected without successfully sending proposal\"));\n                removeListeners();\n              }\n            });\n          }\n        }; // If the QuorumProposals is disposed of, we assume something catastrophic has happened\n        // All outstanding proposals are considered rejected.\n\n\n        const disposedHandler = () => {\n          reject(new Error(\"QuorumProposals was disposed\"));\n          removeListeners();\n        }; // Convenience function to clean up our listeners.\n\n\n        const removeListeners = () => {\n          _this.stateEvents.off(\"localProposalSequenced\", localProposalSequencedHandler);\n\n          _this.stateEvents.off(\"localProposalApproved\", localProposalApprovedHandler);\n\n          _this.stateEvents.off(\"disconnected\", disconnectedHandler);\n\n          _this.stateEvents.off(\"disposed\", disposedHandler);\n        };\n\n        _this.stateEvents.on(\"localProposalSequenced\", localProposalSequencedHandler);\n\n        _this.stateEvents.on(\"disconnected\", disconnectedHandler);\n\n        _this.stateEvents.on(\"disposed\", disposedHandler);\n      });\n    })();\n  }\n  /**\n   * Begins tracking a new proposal\n   */\n\n\n  addProposal(key, value, sequenceNumber, local, clientSequenceNumber) {\n    assert(!this.proposals.has(sequenceNumber), 0x1d0\n    /* sequenceNumber not found */\n    );\n    const proposal = new PendingProposal(sequenceNumber, key, value, local);\n    this.proposals.set(sequenceNumber, proposal); // Legacy event, from rejection support.  May still have some use for clients to learn that a proposal is\n    // likely to be approved soon.\n\n    this.emit(\"addProposal\", proposal);\n\n    if (local) {\n      this.stateEvents.emit(\"localProposalSequenced\", clientSequenceNumber, sequenceNumber);\n    } // clear the proposal cache\n\n\n    this.proposalsSnapshotCache = undefined;\n  }\n  /**\n   * Updates the minimum sequence number. If the MSN advances past the sequence number for any proposal then it\n   * becomes an approved value.\n   */\n\n\n  updateMinimumSequenceNumber(message) {\n    const msn = message.minimumSequenceNumber; // Accept proposals proposals whose sequenceNumber is <= the minimumSequenceNumber\n    // Return a sorted list of approved proposals. We sort so that we apply them in their sequence number order\n    // TODO this can be optimized if necessary to avoid the linear search+sort\n\n    const completed = [];\n\n    for (const [sequenceNumber, proposal] of this.proposals) {\n      if (sequenceNumber <= msn) {\n        completed.push(proposal);\n      }\n    }\n\n    completed.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n\n    for (const proposal of completed) {\n      const committedProposal = {\n        approvalSequenceNumber: message.sequenceNumber,\n        // No longer used.  We still stamp a -1 for compat with older versions of the quorum.\n        // Can be removed after 0.1035 and higher is ubiquitous.\n        commitSequenceNumber: -1,\n        key: proposal.key,\n        sequenceNumber: proposal.sequenceNumber,\n        value: proposal.value\n      };\n      this.values.set(committedProposal.key, committedProposal); // clear the values cache\n\n      this.valuesSnapshotCache = undefined;\n      this.emit(\"approveProposal\", committedProposal.sequenceNumber, committedProposal.key, committedProposal.value, committedProposal.approvalSequenceNumber);\n      this.proposals.delete(proposal.sequenceNumber); // clear the proposals cache\n\n      this.proposalsSnapshotCache = undefined;\n\n      if (proposal.local) {\n        this.stateEvents.emit(\"localProposalApproved\", proposal.sequenceNumber);\n      }\n    }\n  }\n\n  setConnectionState(connected) {\n    if (connected) {\n      this.stateEvents.emit(\"connected\");\n    } else {\n      this.stateEvents.emit(\"disconnected\");\n    }\n  }\n\n  dispose() {\n    this.isDisposed = true;\n    this.stateEvents.emit(\"disposed\");\n  }\n\n}\n/**\n * A quorum represents all clients currently within the collaboration window. As well as the values\n * they have agreed upon and any pending proposals.\n */\n\nexport class Quorum extends TypedEventEmitter {\n  constructor(members, proposals, values, sendProposal) {\n    super();\n    this.isDisposed = false;\n    this.quorumClients = new QuorumClients(members);\n    this.quorumClients.on(\"addMember\", (clientId, details) => {\n      this.emit(\"addMember\", clientId, details);\n    });\n    this.quorumClients.on(\"removeMember\", clientId => {\n      this.emit(\"removeMember\", clientId);\n    });\n    this.quorumProposals = new QuorumProposals({\n      proposals,\n      values\n    }, sendProposal);\n    this.quorumProposals.on(\"addProposal\", proposal => {\n      this.emit(\"addProposal\", proposal);\n    });\n    this.quorumProposals.on(\"approveProposal\", (sequenceNumber, key, value, approvalSequenceNumber) => {\n      this.emit(\"approveProposal\", sequenceNumber, key, value, approvalSequenceNumber);\n    });\n  }\n\n  get disposed() {\n    return this.isDisposed;\n  }\n\n  close() {\n    this.removeAllListeners();\n  }\n  /**\n   * Snapshots the entire quorum\n   * @returns a quorum snapshot\n   */\n\n\n  snapshot() {\n    const members = this.quorumClients.snapshot();\n    const {\n      proposals,\n      values\n    } = this.quorumProposals.snapshot();\n    return {\n      members,\n      proposals,\n      values\n    };\n  }\n  /**\n   * Returns whether the quorum has achieved a consensus for the given key.\n   */\n\n\n  has(key) {\n    return this.quorumProposals.has(key);\n  }\n  /**\n   * Returns the consensus value for the given key\n   */\n\n\n  get(key) {\n    return this.quorumProposals.get(key);\n  }\n  /**\n   * Returns additional data about the approved consensus value\n   * @deprecated Removed in recent protocol-definitions.  Use get() instead.\n   */\n\n\n  getApprovalData(key) {\n    return this.quorumProposals.getApprovalData(key);\n  }\n  /**\n   * Adds a new client to the quorum\n   */\n\n\n  addMember(clientId, details) {\n    this.quorumClients.addMember(clientId, details);\n  }\n  /**\n   * Removes a client from the quorum\n   */\n\n\n  removeMember(clientId) {\n    this.quorumClients.removeMember(clientId);\n  }\n  /**\n   * Retrieves all the members in the quorum\n   */\n\n\n  getMembers() {\n    return this.quorumClients.getMembers();\n  }\n  /**\n   * Retrieves a specific member of the quorum\n   */\n\n\n  getMember(clientId) {\n    return this.quorumClients.getMember(clientId);\n  }\n  /**\n   * Proposes a new value. Returns a promise that will resolve when the proposal is either accepted, or reject if\n   * the proposal fails to send.\n   */\n\n\n  propose(key, value) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2.quorumProposals.propose(key, value);\n    })();\n  }\n  /**\n   * Begins tracking a new proposal\n   */\n\n\n  addProposal(key, value, sequenceNumber, local, clientSequenceNumber) {\n    return this.quorumProposals.addProposal(key, value, sequenceNumber, local, clientSequenceNumber);\n  }\n  /**\n   * Updates the minimum sequence number. If the MSN advances past the sequence number for any proposal then it\n   * becomes an approved value.\n   */\n\n\n  updateMinimumSequenceNumber(message) {\n    this.quorumProposals.updateMinimumSequenceNumber(message);\n  }\n\n  setConnectionState(connected, clientId) {\n    this.quorumProposals.setConnectionState(connected);\n  }\n\n  dispose() {\n    throw new Error(\"Not implemented.\");\n    this.isDisposed = true;\n  }\n\n} //# sourceMappingURL=quorum.js.map","map":null,"metadata":{},"sourceType":"module"}