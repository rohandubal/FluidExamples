{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * A comparer for numbers\n */\nexport const NumberComparer = {\n  /**\n   * The compare function for numbers,\n   * @returns difference of the two number\n   */\n  compare: (a, b) => a - b,\n\n  /**\n   * The minimum value of a javascript number, which is Number.MIN_VALUE\n   */\n  min: Number.MIN_VALUE\n};\n/**\n * Ordered Heap data structure implementation\n */\n\nexport class Heap {\n  /**\n   * Creates an instance of Heap with comparer\n   * @param comp - a comparer that specify how elements are ordered\n   */\n  constructor(comp) {\n    this.comp = comp;\n    this.L = [{\n      value: comp.min,\n      position: 0\n    }];\n  }\n  /**\n   * Return the smallest element in the heap as determined by the order of the comparer\n   *\n   * @returns heap node containing the smallest element\n   */\n\n\n  peek() {\n    return this.L[1];\n  }\n  /**\n   * Get and remove the smallest element in the heap as determined by the order of the comparer\n   *\n   * @returns the smallest value in the heap\n   */\n\n\n  get() {\n    this.swap(1, this.count());\n    const x = this.L.pop();\n    this.fixdown(1);\n    return x.value;\n  }\n  /**\n   * Add a value to the heap\n   *\n   * @param x - value to add\n   * @returns the heap node that contains the value\n   */\n\n\n  add(x) {\n    const node = {\n      value: x,\n      position: this.L.length\n    };\n    this.L.push(node);\n    this.fixup(this.count());\n    return node;\n  }\n  /**\n   * Allows for heap to be updated after a node's value changes\n   */\n\n\n  update(node) {\n    const k = node.position;\n\n    if (this.isGreaterThanParent(k)) {\n      this.fixup(k);\n    } else {\n      this.fixdown(k);\n    }\n  }\n  /**\n   * Removes the given node from the heap\n   *\n   * @param node - the node to remove from the heap\n   */\n\n\n  remove(node) {\n    // Move the node we want to remove to the end of the array\n    const position = node.position;\n    this.swap(node.position, this.L.length - 1);\n    this.L.splice(this.L.length - 1); // Update the swapped node assuming we didn't remove the end of the list\n\n    if (position !== this.L.length) {\n      this.update(this.L[position]);\n    }\n  }\n  /**\n   * Get the number of elements in the Heap\n   *\n   * @returns the number of elements in the Heap\n   */\n\n\n  count() {\n    return this.L.length - 1;\n  }\n\n  fixup(pos) {\n    let k = pos;\n\n    while (this.isGreaterThanParent(k)) {\n      const parent = k >> 1;\n      this.swap(k, parent);\n      k = parent;\n    }\n  }\n\n  isGreaterThanParent(k) {\n    return k > 1 && this.comp.compare(this.L[k >> 1].value, this.L[k].value) > 0;\n  }\n\n  fixdown(pos) {\n    let k = pos;\n\n    while (k << 1 <= this.count()) {\n      let j = k << 1;\n\n      if (j < this.count() && this.comp.compare(this.L[j].value, this.L[j + 1].value) > 0) {\n        j++;\n      }\n\n      if (this.comp.compare(this.L[k].value, this.L[j].value) <= 0) {\n        break;\n      }\n\n      this.swap(k, j);\n      k = j;\n    }\n  }\n\n  swap(k, j) {\n    const tmp = this.L[k];\n    this.L[k] = this.L[j];\n    this.L[k].position = k;\n    this.L[j] = tmp;\n    this.L[j].position = j;\n  }\n\n} //# sourceMappingURL=heap.js.map","map":null,"metadata":{},"sourceType":"module"}