{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { DataCorruptionError } from \"@fluidframework/container-utils\";\nimport { readAndParse } from \"@fluidframework/driver-utils\";\nimport { ChildLogger, TelemetryDataTag, ThresholdCounter } from \"@fluidframework/telemetry-utils\";\nimport { attributesBlobKey, createServiceEndpoints, summarizeChannelAsync } from \"./channelContext\";\nexport let RemoteChannelContext = /*#__PURE__*/(() => {\n  class RemoteChannelContext {\n    constructor(runtime, dataStoreContext, storageService, submitFn, dirtyFn, addedGCOutboundReferenceFn, id, baseSnapshot, registry, extraBlobs, createSummarizerNode, getBaseGCDetails, attachMessageType) {\n      var _this = this;\n\n      this.runtime = runtime;\n      this.dataStoreContext = dataStoreContext;\n      this.id = id;\n      this.registry = registry;\n      this.attachMessageType = attachMessageType;\n      this.isLoaded = false;\n      this.pending = [];\n      assert(!this.id.includes(\"/\"), 0x310\n      /* Channel context ID cannot contain slashes */\n      );\n      this.subLogger = ChildLogger.create(this.runtime.logger, \"RemoteChannelContext\");\n      this.services = createServiceEndpoints(this.id, this.dataStoreContext.connected, submitFn, () => dirtyFn(this.id), addedGCOutboundReferenceFn, storageService, this.subLogger, baseSnapshot, extraBlobs);\n\n      const thisSummarizeInternal = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (fullTree, trackState, telemetryContext) {\n          return _this.summarizeInternal(fullTree, trackState, telemetryContext);\n        });\n\n        return function thisSummarizeInternal(_x, _x2, _x3) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      this.summarizerNode = createSummarizerNode(thisSummarizeInternal, /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (fullGC) {\n          return _this.getGCDataInternal(fullGC);\n        });\n\n        return function (_x4) {\n          return _ref2.apply(this, arguments);\n        };\n      }(), /*#__PURE__*/_asyncToGenerator(function* () {\n        return getBaseGCDetails();\n      }));\n      this.thresholdOpsCounter = new ThresholdCounter(RemoteChannelContext.pendingOpsCountThreshold, this.subLogger);\n    } // eslint-disable-next-line @typescript-eslint/promise-function-async\n\n\n    getChannel() {\n      if (this.channelP === undefined) {\n        this.channelP = this.loadChannel();\n      }\n\n      return this.channelP;\n    }\n\n    setConnectionState(connected, clientId) {\n      // Connection events are ignored if the data store is not yet loaded\n      if (!this.isLoaded) {\n        return;\n      }\n\n      this.services.deltaConnection.setConnectionState(connected);\n    }\n\n    applyStashedOp(message) {\n      assert(this.isLoaded, 0x194\n      /* \"Remote channel must be loaded when rebasing op\" */\n      );\n      return this.services.deltaConnection.applyStashedOp(message);\n    }\n\n    processOp(message, local, localOpMetadata) {\n      this.summarizerNode.invalidate(message.sequenceNumber);\n\n      if (this.isLoaded) {\n        this.services.deltaConnection.process(message, local, localOpMetadata);\n      } else {\n        assert(!local, 0x195\n        /* \"Remote channel must not be local when processing op\" */\n        );\n        assert(this.pending !== undefined, 0x23e\n        /* \"pending is undefined\" */\n        );\n        this.pending.push(message);\n        this.thresholdOpsCounter.sendIfMultiple(\"StorePendingOps\", this.pending.length);\n      }\n    }\n\n    reSubmit(content, localOpMetadata) {\n      assert(this.isLoaded, 0x196\n      /* \"Remote channel must be loaded when resubmitting op\" */\n      );\n      this.services.deltaConnection.reSubmit(content, localOpMetadata);\n    }\n\n    rollback(content, localOpMetadata) {\n      assert(this.isLoaded, 0x2f0\n      /* \"Remote channel must be loaded when rolling back op\" */\n      );\n      this.services.deltaConnection.rollback(content, localOpMetadata);\n    }\n    /**\n     * Returns a summary at the current sequence number.\n     * @param fullTree - true to bypass optimizations and force a full summary tree\n     * @param trackState - This tells whether we should track state from this summary.\n     * @param telemetryContext - summary data passed through the layers for telemetry purposes\n     */\n\n\n    summarize(fullTree = false, trackState = true, telemetryContext) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        return _this2.summarizerNode.summarize(fullTree, trackState, telemetryContext);\n      })();\n    }\n\n    summarizeInternal(fullTree, trackState, telemetryContext) {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        const channel = yield _this3.getChannel();\n        const summarizeResult = yield summarizeChannelAsync(channel, fullTree, trackState, telemetryContext);\n        return Object.assign(Object.assign({}, summarizeResult), {\n          id: _this3.id\n        });\n      })();\n    }\n\n    loadChannel() {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        assert(!_this4.isLoaded, 0x197\n        /* \"Remote channel must not already be loaded when loading\" */\n        );\n        let attributes;\n\n        if (yield _this4.services.objectStorage.contains(attributesBlobKey)) {\n          attributes = yield readAndParse(_this4.services.objectStorage, attributesBlobKey);\n        }\n\n        let factory; // this is a backward compatibility case where\n        // the attach message doesn't include\n        // the attributes. Since old attach messages\n        // will not have attributes we need to keep\n        // this as long as we support old attach messages\n\n        if (attributes === undefined) {\n          if (_this4.attachMessageType === undefined) {\n            // TODO: dataStoreId may require a different tag from PackageData #7488\n            throw new DataCorruptionError(\"channelTypeNotAvailable\", {\n              channelId: {\n                value: _this4.id,\n                tag: TelemetryDataTag.PackageData\n              },\n              dataStoreId: {\n                value: _this4.dataStoreContext.id,\n                tag: TelemetryDataTag.PackageData\n              },\n              dataStorePackagePath: _this4.dataStoreContext.packagePath.join(\"/\")\n            });\n          }\n\n          factory = _this4.registry.get(_this4.attachMessageType);\n\n          if (factory === undefined) {\n            // TODO: dataStoreId may require a different tag from PackageData #7488\n            throw new DataCorruptionError(\"channelFactoryNotRegisteredForAttachMessageType\", {\n              channelId: {\n                value: _this4.id,\n                tag: TelemetryDataTag.PackageData\n              },\n              dataStoreId: {\n                value: _this4.dataStoreContext.id,\n                tag: TelemetryDataTag.PackageData\n              },\n              dataStorePackagePath: _this4.dataStoreContext.packagePath.join(\"/\"),\n              channelFactoryType: _this4.attachMessageType\n            });\n          }\n\n          attributes = factory.attributes;\n        } else {\n          factory = _this4.registry.get(attributes.type);\n\n          if (factory === undefined) {\n            // TODO: dataStoreId may require a different tag from PackageData #7488\n            throw new DataCorruptionError(\"channelFactoryNotRegisteredForGivenType\", {\n              channelId: {\n                value: _this4.id,\n                tag: TelemetryDataTag.PackageData\n              },\n              dataStoreId: {\n                value: _this4.dataStoreContext.id,\n                tag: TelemetryDataTag.PackageData\n              },\n              dataStorePackagePath: _this4.dataStoreContext.packagePath.join(\"/\"),\n              channelFactoryType: attributes.type\n            });\n          }\n        } // Compare snapshot version to collaborative object version\n\n\n        if (attributes.snapshotFormatVersion !== undefined && attributes.snapshotFormatVersion !== factory.attributes.snapshotFormatVersion) {\n          _this4.subLogger.sendTelemetryEvent({\n            eventName: \"ChannelAttributesVersionMismatch\",\n            channelType: {\n              value: attributes.type,\n              tag: TelemetryDataTag.PackageData\n            },\n            channelSnapshotVersion: {\n              value: `${attributes.snapshotFormatVersion}@${attributes.packageVersion}`,\n              tag: TelemetryDataTag.PackageData\n            },\n            channelCodeVersion: {\n              value: `${factory.attributes.snapshotFormatVersion}@${factory.attributes.packageVersion}`,\n              tag: TelemetryDataTag.PackageData\n            }\n          });\n        }\n\n        const channel = yield factory.load(_this4.runtime, _this4.id, _this4.services, attributes); // Send all pending messages to the channel\n\n        assert(_this4.pending !== undefined, 0x23f\n        /* \"pending undefined\" */\n        );\n\n        for (const message of _this4.pending) {\n          _this4.services.deltaConnection.process(message, false, undefined\n          /* localOpMetadata */\n          );\n        }\n\n        _this4.thresholdOpsCounter.send(\"ProcessPendingOps\", _this4.pending.length); // Commit changes.\n\n\n        _this4.channel = channel;\n        _this4.pending = undefined;\n        _this4.isLoaded = true; // Because have some await between we created the service and here, the connection state might have changed\n        // and we don't propagate the connection state when we are not loaded.  So we have to set it again here.\n\n        _this4.services.deltaConnection.setConnectionState(_this4.dataStoreContext.connected);\n\n        return _this4.channel;\n      })();\n    }\n    /**\n     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this context.\n     * Each node has a set of outbound routes to other GC nodes in the document.\n     * If there is no new data in this context since the last summary, previous GC data is used.\n     * If there is new data, the GC data is generated again (by calling getGCDataInternal).\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n\n\n    getGCData(fullGC = false) {\n      var _this5 = this;\n\n      return _asyncToGenerator(function* () {\n        return _this5.summarizerNode.getGCData(fullGC);\n      })();\n    }\n    /**\n     * Generates the data used for garbage collection. This is called when there is new data since last summary. It\n     * loads the context and calls into the channel to get its GC data.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n\n\n    getGCDataInternal(fullGC = false) {\n      var _this6 = this;\n\n      return _asyncToGenerator(function* () {\n        const channel = yield _this6.getChannel();\n        return channel.getGCData(fullGC);\n      })();\n    }\n\n    updateUsedRoutes(usedRoutes, gcTimestamp) {\n      /**\n       * Currently, DDSes are always considered referenced and are not garbage collected. Update the summarizer node's\n       * used routes to contain a route to this channel context.\n       * Once we have GC at DDS level, this will be updated to use the passed usedRoutes. See -\n       * https://github.com/microsoft/FluidFramework/issues/4611\n       */\n      this.summarizerNode.updateUsedRoutes([\"\"]);\n    }\n\n  }\n\n  RemoteChannelContext.pendingOpsCountThreshold = 1000; //# sourceMappingURL=remoteChannelContext.js.map\n\n  return RemoteChannelContext;\n})();","map":null,"metadata":{},"sourceType":"module"}