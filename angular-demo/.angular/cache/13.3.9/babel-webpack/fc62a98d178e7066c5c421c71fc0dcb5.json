{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { makeHandlesSerializable, parseHandles, ValueType } from \"@fluidframework/shared-object-base\";\nimport { assert, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { makeSerializable, ValueTypeLocalValue } from \"./localValues\";\n/**\n * A DefaultMap is a map-like distributed data structure, supporting operations on values stored by\n * string key locations.\n *\n * Creation of values is implicit on access (either via `get` or a remote op application referring to\n * a collection that wasn't previously known)\n */\n\nexport class DefaultMap {\n  /**\n   * Create a new default map.\n   * @param serializer - The serializer to serialize / parse handles\n   * @param handle - The handle of the shared object using the kernel\n   * @param submitMessage - A callback to submit a message through the shared object\n   * @param type - The value type to create at values of this map\n   * @param eventEmitter - The object that will emit map events\n   */\n  constructor(serializer, handle, submitMessage, type, eventEmitter = new TypedEventEmitter()) {\n    this.serializer = serializer;\n    this.handle = handle;\n    this.submitMessage = submitMessage;\n    this.type = type;\n    this.eventEmitter = eventEmitter;\n    /**\n     * Mapping of op types to message handlers.\n     */\n\n    this.messageHandlers = new Map();\n    /**\n     * The in-memory data the map is storing.\n     */\n\n    this.data = new Map();\n    this.messageHandlers = this.getMessageHandlers();\n  }\n  /**\n   * The number of key/value pairs stored in the map.\n   */\n\n\n  get size() {\n    return this.data.size;\n  }\n  /**\n   * Get an iterator over the keys in this map.\n   * @returns The iterator\n   */\n\n\n  keys() {\n    return this.data.keys();\n  }\n  /**\n   * Get an iterator over the entries in this map.\n   * @returns The iterator\n   */\n\n\n  entries() {\n    const localEntriesIterator = this.data.entries();\n    const iterator = {\n      next() {\n        const nextVal = localEntriesIterator.next();\n        return nextVal.done ? {\n          value: undefined,\n          done: true\n        } : {\n          value: [nextVal.value[0], nextVal.value[1].value],\n          done: false\n        }; // Unpack the stored value\n      },\n\n      [Symbol.iterator]() {\n        return this;\n      }\n\n    };\n    return iterator;\n  }\n  /**\n   * Get an iterator over the values in this map.\n   * @returns The iterator\n   */\n\n\n  values() {\n    const localValuesIterator = this.data.values();\n    const iterator = {\n      next() {\n        const nextVal = localValuesIterator.next();\n        return nextVal.done ? {\n          value: undefined,\n          done: true\n        } : {\n          value: nextVal.value.value,\n          done: false\n        }; // Unpack the stored value\n      },\n\n      [Symbol.iterator]() {\n        return this;\n      }\n\n    };\n    return iterator;\n  }\n  /**\n   * Get an iterator over the entries in this map.\n   * @returns The iterator\n   */\n\n\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Executes the given callback on each entry in the map.\n   * @param callbackFn - Callback function\n   */\n\n\n  forEach(callbackFn) {\n    this.data.forEach((localValue, key, m) => {\n      callbackFn(localValue.value, key, m);\n    });\n  }\n  /**\n   * {@inheritDoc ISharedMap.get}\n   */\n\n\n  get(key) {\n    var _a;\n\n    const localValue = (_a = this.data.get(key)) !== null && _a !== void 0 ? _a : this.createCore(key, true);\n    return localValue.value;\n  }\n  /**\n   * Check if a key exists in the map.\n   * @param key - The key to check\n   * @returns True if the key exists, false otherwise\n   */\n\n\n  has(key) {\n    return this.data.has(key);\n  }\n  /**\n   * Serializes the data stored in the shared map to a JSON string\n   * @param serializer - The serializer to use to serialize handles in its values.\n   * @returns A JSON string containing serialized map data\n   */\n\n\n  getSerializedStorage(serializer) {\n    const serializableMapData = {};\n    this.data.forEach((localValue, key) => {\n      serializableMapData[key] = localValue.makeSerialized(serializer, this.handle);\n    });\n    return serializableMapData;\n  }\n\n  getSerializableStorage(serializer) {\n    const serializableMapData = {};\n    this.data.forEach((localValue, key) => {\n      serializableMapData[key] = makeSerializable(localValue, serializer, this.handle);\n    });\n    return serializableMapData;\n  }\n\n  serialize(serializer) {\n    return JSON.stringify(this.getSerializableStorage(serializer));\n  }\n  /**\n   * Populate the kernel with the given map data.\n   * @param data - A JSON string containing serialized map data\n   */\n\n\n  populateFromSerializable(json) {\n    for (const [key, serializable] of Object.entries(json)) {\n      // Back-compat: legacy documents may have handles to an intervalCollection map kernel.\n      // These collections should be empty, and ValueTypes are no longer supported.\n      if (serializable.type === ValueType[ValueType.Plain] || serializable.type === ValueType[ValueType.Shared]) {\n        continue;\n      } // Back-compat: Sequence previously arbitrarily prefixed all interval collection keys with\n      // \"intervalCollections/\". This would burden users trying to iterate the collection and\n      // access its value, as well as those trying to match a create message to its underlying\n      // collection. See https://github.com/microsoft/FluidFramework/issues/10557 for more context.\n\n\n      const normalizedKey = key.startsWith(\"intervalCollections/\") ? key.substring(20) : key;\n      const localValue = {\n        key: normalizedKey,\n        value: this.makeLocal(key, serializable)\n      };\n      this.data.set(localValue.key, localValue.value);\n    }\n  }\n\n  populate(json) {\n    this.populateFromSerializable(JSON.parse(json));\n  }\n  /**\n   * Submit the given op if a handler is registered.\n   * @param op - The operation to attempt to submit\n   * @param localOpMetadata - The local metadata associated with the op. This is kept locally by the runtime\n   * and not sent to the server. This will be sent back when this message is received back from the server. This is\n   * also sent if we are asked to resubmit the message.\n   * @returns True if the operation was submitted, false otherwise.\n   */\n\n\n  tryResubmitMessage(op, localOpMetadata) {\n    const type = op.type;\n    const handler = this.messageHandlers.get(type);\n\n    if (handler !== undefined) {\n      handler.resubmit(op, localOpMetadata);\n      return true;\n    }\n\n    return false;\n  }\n\n  tryGetStashedOpLocalMetadata(op) {\n    const type = op.type;\n\n    if (this.messageHandlers.has(type)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.messageHandlers.get(type).getStashedOpLocalMetadata(op);\n    }\n\n    throw new Error(\"no apply stashed op handler\");\n  }\n  /**\n   * Process the given op if a handler is registered.\n   * @param message - The message to process\n   * @param local - Whether the message originated from the local client\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @returns True if the operation was processed, false otherwise.\n   */\n\n\n  tryProcessMessage(op, local, message, localOpMetadata) {\n    const handler = this.messageHandlers.get(op.type);\n\n    if (handler !== undefined) {\n      handler.process(op, local, message, localOpMetadata);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Initializes a default ValueType at the provided key.\n   * Should be used when a map operation incurs creation.\n   * @param key - The key being initialized\n   * @param local - Whether the message originated from the local client\n   */\n\n\n  createCore(key, local) {\n    const localValue = new ValueTypeLocalValue(this.type.factory.load(this.makeMapValueOpEmitter(key), undefined), this.type);\n    const previousValue = this.data.get(key);\n    this.data.set(key, localValue);\n    const event = {\n      key,\n      previousValue\n    };\n    this.eventEmitter.emit(\"create\", event, local, this.eventEmitter);\n    return localValue;\n  }\n  /**\n   * The remote ISerializableValue we're receiving (either as a result of a load or an incoming set op) will\n   * have the information we need to create a real object, but will not be the real object yet.  For example,\n   * we might know it's a map and the map's ID but not have the actual map or its data yet.  makeLocal's\n   * job is to convert that information into a real object for local usage.\n   * @param key - The key that the caller intends to store the local value into (used for ops later).  But\n   * doesn't actually store the local value into that key.  So better not lie!\n   * @param serializable - The remote information that we can convert into a real object\n   * @returns The local value that was produced\n   */\n\n\n  makeLocal(key, serializable) {\n    assert(serializable.type !== ValueType[ValueType.Plain] && serializable.type !== ValueType[ValueType.Shared], 0x2e1\n    /* \"Support for plain value types removed.\" */\n    );\n    serializable.value = parseHandles(serializable.value, this.serializer);\n    const localValue = this.type.factory.load(this.makeMapValueOpEmitter(key), serializable.value);\n    return new ValueTypeLocalValue(localValue, this.type);\n  }\n  /**\n   * Get the message handlers for the map.\n   * @returns A map of string op names to IMapMessageHandlers for those ops\n   */\n\n\n  getMessageHandlers() {\n    const messageHandlers = new Map(); // Ops with type \"act\" describe actions taken by custom value type handlers of whatever item is\n    // being addressed.  These custom handlers can be retrieved from the ValueTypeLocalValue which has\n    // stashed its valueType (and therefore its handlers).  We also emit a valueChanged for anyone\n    // watching for manipulations of that item.\n\n    messageHandlers.set(\"act\", {\n      process: (op, local, message, localOpMetadata) => {\n        var _a;\n\n        const localValue = (_a = this.data.get(op.key)) !== null && _a !== void 0 ? _a : this.createCore(op.key, local);\n        const handler = localValue.getOpHandler(op.value.opName);\n        const previousValue = localValue.value;\n        const translatedValue = parseHandles(op.value.value, this.serializer);\n        handler.process(previousValue, translatedValue, local, message, localOpMetadata);\n        const event = {\n          key: op.key,\n          previousValue\n        };\n        this.eventEmitter.emit(\"valueChanged\", event, local, message, this.eventEmitter);\n      },\n      submit: (op, localOpMetadata) => {\n        this.submitMessage(op, localOpMetadata);\n      },\n      resubmit: (op, localOpMetadata) => {\n        const localValue = this.data.get(op.key);\n        const handler = localValue.getOpHandler(op.value.opName);\n        const {\n          rebasedOp,\n          rebasedLocalOpMetadata\n        } = handler.rebase(localValue.value, op.value, localOpMetadata);\n        this.submitMessage(Object.assign(Object.assign({}, op), {\n          value: rebasedOp\n        }), rebasedLocalOpMetadata);\n      },\n      getStashedOpLocalMetadata: op => {\n        assert(false, 0x016\n        /* \"apply stashed op not implemented for custom value type ops\" */\n        );\n      }\n    });\n    return messageHandlers;\n  }\n  /**\n   * Create an emitter for a value type to emit ops from the given key.\n   * @alpha\n   * @param key - The key of the map that the value type will be stored on\n   * @returns A value op emitter for the given key\n   */\n\n\n  makeMapValueOpEmitter(key) {\n    const emit = (opName, previousValue, params, localOpMetadata) => {\n      const translatedParams = makeHandlesSerializable(params, this.serializer, this.handle);\n      const op = {\n        key,\n        type: \"act\",\n        value: {\n          opName,\n          value: translatedParams\n        }\n      };\n      this.submitMessage(op, localOpMetadata);\n      const event = {\n        key,\n        previousValue\n      };\n      this.eventEmitter.emit(\"valueChanged\", event, true, null, this.eventEmitter);\n    };\n\n    return {\n      emit\n    };\n  }\n\n} //# sourceMappingURL=defaultMap.js.map","map":null,"metadata":{},"sourceType":"module"}