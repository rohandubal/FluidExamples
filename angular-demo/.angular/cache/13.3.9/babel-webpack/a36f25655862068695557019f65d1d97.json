{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { assert, Trace, unreachableCase } from \"@fluidframework/common-utils\";\nimport { LoggingError } from \"@fluidframework/telemetry-utils\";\nimport { RedBlackTree } from \"./collections\";\nimport { UnassignedSequenceNumber, UniversalSequenceNumber } from \"./constants\";\nimport { LocalReference } from \"./localReference\";\nimport { compareStrings, MergeTree } from \"./mergeTree\";\nimport { createAnnotateMarkerOp, createAnnotateRangeOp, createGroupOp, createInsertSegmentOp, createRemoveRangeOp } from \"./opBuilder\";\nimport { MergeTreeDeltaType } from \"./ops\";\nimport { SnapshotLegacy } from \"./snapshotlegacy\";\nimport { SnapshotLoader } from \"./snapshotLoader\";\nimport { MergeTreeTextHelper } from \"./textSegment\";\nimport { SnapshotV1 } from \"./snapshotV1\";\n\nfunction elapsedMicroseconds(trace) {\n  return trace.trace().duration * 1000;\n}\n\nexport class Client {\n  constructor( // Passing this callback would be unnecessary if Client were merged with SharedSegmentSequence\n  specToSegment, logger, options) {\n    this.specToSegment = specToSegment;\n    this.logger = logger;\n    this.measureOps = false;\n    this.accumTime = 0;\n    this.localTime = 0;\n    this.localOps = 0;\n    this.accumWindowTime = 0;\n    this.accumWindow = 0;\n    this.accumOps = 0;\n    this.maxWindowTime = 0;\n    this.clientNameToIds = new RedBlackTree(compareStrings);\n    this.shortClientIdMap = [];\n    this.pendingConsensus = new Map();\n    this.mergeTree = new MergeTree(options);\n  }\n\n  get mergeTreeDeltaCallback() {\n    return this.mergeTree.mergeTreeDeltaCallback;\n  }\n\n  set mergeTreeDeltaCallback(callback) {\n    this.mergeTree.mergeTreeDeltaCallback = callback;\n  }\n\n  get mergeTreeMaintenanceCallback() {\n    return this.mergeTree.mergeTreeMaintenanceCallback;\n  }\n\n  set mergeTreeMaintenanceCallback(callback) {\n    this.mergeTree.mergeTreeMaintenanceCallback = callback;\n  }\n  /**\n   * The merge tree maintains a queue of segment groups for each local operation.\n   * These segment groups track segments modified by an operation.\n   * This method peeks the tail of that queue, and returns the segments groups there.\n   * It is used to get the segment group(s) for the previous operations.\n   * @param count - The number segment groups to get peek from the tail of the queue. Default 1.\n   */\n\n\n  peekPendingSegmentGroups(count = 1) {\n    var _a, _b;\n\n    if (count === 1) {\n      return (_a = this.mergeTree.pendingSegments) === null || _a === void 0 ? void 0 : _a.last();\n    }\n\n    let taken = 0;\n    return (_b = this.mergeTree.pendingSegments) === null || _b === void 0 ? void 0 : _b.some(() => {\n      if (taken < count) {\n        taken++;\n        return true;\n      }\n\n      return false;\n    }, true);\n  }\n  /**\n   * Annotate a marker and call the callback on consensus.\n   * @param marker - The marker to annotate\n   * @param props - The properties to annotate the marker with\n   * @param consensusCallback - The callback called when consensus is reached\n   * @returns The annotate op if valid, otherwise undefined\n   */\n\n\n  annotateMarkerNotifyConsensus(marker, props, consensusCallback) {\n    const combiningOp = {\n      name: \"consensus\"\n    };\n    const annotateOp = this.annotateMarker(marker, props, combiningOp);\n\n    if (annotateOp) {\n      const consensusInfo = {\n        callback: consensusCallback,\n        marker\n      };\n      this.pendingConsensus.set(marker.getId(), consensusInfo);\n      return annotateOp;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Annotates the markers with the provided properties\n   * @param marker - The marker to annotate\n   * @param props - The properties to annotate the marker with\n   * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n   * @returns The annotate op if valid, otherwise undefined\n   */\n\n\n  annotateMarker(marker, props, combiningOp) {\n    const annotateOp = createAnnotateMarkerOp(marker, props, combiningOp);\n\n    if (this.applyAnnotateRangeOp({\n      op: annotateOp\n    })) {\n      return annotateOp;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Annotates the range with the provided properties\n   * @param start - The inclusive start position of the range to annotate\n   * @param end - The exclusive end position of the range to annotate\n   * @param props - The properties to annotate the range with\n   * @param combiningOp - Specifies how to combine values for the property, such as \"incr\" for increment.\n   * @returns The annotate op if valid, otherwise undefined\n   */\n\n\n  annotateRangeLocal(start, end, props, combiningOp) {\n    const annotateOp = createAnnotateRangeOp(start, end, props, combiningOp);\n\n    if (this.applyAnnotateRangeOp({\n      op: annotateOp\n    })) {\n      return annotateOp;\n    }\n\n    return undefined;\n  }\n  /**\n   * Removes the range\n   *\n   * @param start - The inclusive start of the range to remove\n   * @param end - The exclusive end of the range to remove\n   */\n\n\n  removeRangeLocal(start, end) {\n    const removeOp = createRemoveRangeOp(start, end);\n\n    if (this.applyRemoveRangeOp({\n      op: removeOp\n    })) {\n      return removeOp;\n    }\n\n    return undefined;\n  }\n  /**\n   * @param pos - The position to insert the segment at\n   * @param segment - The segment to insert\n   */\n\n\n  insertSegmentLocal(pos, segment) {\n    if (segment.cachedLength <= 0) {\n      return undefined;\n    }\n\n    const insertOp = createInsertSegmentOp(pos, segment);\n\n    if (this.applyInsertOp({\n      op: insertOp\n    })) {\n      return insertOp;\n    }\n\n    return undefined;\n  }\n  /**\n   * @param refPos - The reference position to insert the segment at\n   * @param segment - The segment to insert\n   */\n\n\n  insertAtReferencePositionLocal(refPos, segment) {\n    const pos = this.mergeTree.referencePositionToLocalPosition(refPos, this.getCurrentSeq(), this.getClientId());\n\n    if (pos === LocalReference.DetachedPosition) {\n      return undefined;\n    }\n\n    const op = createInsertSegmentOp(pos, segment);\n    const opArgs = {\n      op\n    };\n    let traceStart;\n\n    if (this.measureOps) {\n      traceStart = Trace.start();\n    }\n\n    this.mergeTree.insertAtReferencePosition(refPos, segment, opArgs);\n    this.completeAndLogOp(opArgs, this.getClientSequenceArgs(opArgs), {\n      start: op.pos1\n    }, traceStart);\n    return op;\n  }\n\n  walkSegments(handler, start, end, accum, splitRange = false) {\n    this.mergeTree.mapRange({\n      leaf: handler\n    }, this.getCurrentSeq(), this.getClientId(), accum, start, end, splitRange);\n  }\n  /**\n   * Serializes the data required for garbage collection. The IFluidHandles stored in all segments that haven't\n   * been removed represent routes to other objects. We serialize the data in these segments using the passed in\n   * serializer which keeps track of all serialized handles.\n   */\n\n\n  serializeGCData(handle, handleCollectingSerializer) {\n    this.mergeTree.walkAllSegments(this.mergeTree.root, seg => {\n      // Only serialize segments that have not been removed.\n      if (seg.removedSeq === undefined) {\n        handleCollectingSerializer.stringify(seg.clone().toJSONObject(), handle);\n      }\n\n      return true;\n    });\n  }\n\n  getCollabWindow() {\n    return this.mergeTree.getCollabWindow();\n  }\n  /**\n   * Returns the current position of a segment, and -1 if the segment\n   * does not exist in this merge tree\n   * @param segment - The segment to get the position of\n   */\n\n\n  getPosition(segment) {\n    if ((segment === null || segment === void 0 ? void 0 : segment.parent) === undefined) {\n      return -1;\n    }\n\n    return this.mergeTree.getPosition(segment, this.getCurrentSeq(), this.getClientId());\n  }\n  /**\n   * @deprecated - use createReferencePosition instead\n   */\n\n\n  addLocalReference(lref) {\n    return this.mergeTree.addLocalReference(lref);\n  }\n  /**\n   * @deprecated - use removeReferencePosition instead\n   */\n\n\n  removeLocalReference(lref) {\n    return this.removeLocalReferencePosition(lref);\n  }\n\n  createLocalReferencePosition(segment, offset, refType, properties) {\n    return this.mergeTree.createLocalReferencePosition(segment, offset, refType, properties, this);\n  }\n\n  removeLocalReferencePosition(lref) {\n    return this.mergeTree.removeLocalReferencePosition(lref);\n  }\n\n  localReferencePositionToPosition(lref) {\n    return this.mergeTree.referencePositionToLocalPosition(lref);\n  }\n  /**\n   * Given a position specified relative to a marker id, lookup the marker\n   * and convert the position to a character position.\n   * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.\n   */\n\n\n  posFromRelativePos(relativePos) {\n    return this.mergeTree.posFromRelativePos(relativePos);\n  }\n\n  getMarkerFromId(id) {\n    return this.mergeTree.getMarkerFromId(id);\n  }\n  /**\n   * Performs the remove based on the provided op\n   * @param opArgs - The ops args for the op\n   * @returns True if the remove was applied. False if it could not be.\n   */\n\n\n  applyRemoveRangeOp(opArgs) {\n    assert(opArgs.op.type === MergeTreeDeltaType.REMOVE, 0x02d\n    /* \"Unexpected op type on range remove!\" */\n    );\n    const op = opArgs.op;\n    const clientArgs = this.getClientSequenceArgs(opArgs);\n    const range = this.getValidOpRange(op, clientArgs);\n\n    if (!range) {\n      return false;\n    }\n\n    let traceStart;\n\n    if (this.measureOps) {\n      traceStart = Trace.start();\n    }\n\n    this.mergeTree.markRangeRemoved(range.start, range.end, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, false, opArgs);\n    this.completeAndLogOp(opArgs, clientArgs, range, traceStart);\n    return true;\n  }\n  /**\n   * Performs the annotate based on the provided op\n   * @param opArgs - The ops args for the op\n   * @returns True if the annotate was applied. False if it could not be.\n   */\n\n\n  applyAnnotateRangeOp(opArgs) {\n    assert(opArgs.op.type === MergeTreeDeltaType.ANNOTATE, 0x02e\n    /* \"Unexpected op type on range annotate!\" */\n    );\n    const op = opArgs.op;\n    const clientArgs = this.getClientSequenceArgs(opArgs);\n    const range = this.getValidOpRange(op, clientArgs);\n\n    if (!range) {\n      return false;\n    }\n\n    let traceStart;\n\n    if (this.measureOps) {\n      traceStart = Trace.start();\n    }\n\n    this.mergeTree.annotateRange(range.start, range.end, op.props, op.combiningOp, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, opArgs);\n    this.completeAndLogOp(opArgs, clientArgs, range, traceStart);\n    return true;\n  }\n  /**\n   * Performs the insert based on the provided op\n   * @param opArgs - The ops args for the op\n   * @returns True if the insert was applied. False if it could not be.\n   */\n\n\n  applyInsertOp(opArgs) {\n    assert(opArgs.op.type === MergeTreeDeltaType.INSERT, 0x02f\n    /* \"Unexpected op type on range insert!\" */\n    );\n    const op = opArgs.op;\n    const clientArgs = this.getClientSequenceArgs(opArgs);\n    const range = this.getValidOpRange(op, clientArgs);\n\n    if (!range) {\n      return false;\n    }\n\n    let segments;\n\n    if (op.seg) {\n      segments = [this.specToSegment(op.seg)];\n    }\n\n    if (!segments || segments.length === 0) {\n      return false;\n    }\n\n    let traceStart;\n\n    if (this.measureOps) {\n      traceStart = Trace.start();\n    }\n\n    this.mergeTree.insertSegments(range.start, segments, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, opArgs);\n    this.completeAndLogOp(opArgs, clientArgs, range, traceStart);\n    return true;\n  }\n  /**\n   *\n   * @param opArgs - The op args of the op to complete\n   * @param clientArgs - The client args for the op\n   * @param range - The range the op applied to\n   * @param clockStart - Optional. The clock start if timing data should be updated.\n   */\n\n\n  completeAndLogOp(opArgs, clientArgs, range, traceStart) {\n    if (!opArgs.sequencedMessage) {\n      if (traceStart) {\n        this.localTime += elapsedMicroseconds(traceStart);\n        this.localOps++;\n      }\n    } else {\n      assert(this.mergeTree.getCollabWindow().currentSeq < clientArgs.sequenceNumber, 0x030\n      /* \"Incoming remote op sequence# <= local collabWindow's currentSequence#\" */\n      );\n      assert(this.mergeTree.getCollabWindow().minSeq <= opArgs.sequencedMessage.minimumSequenceNumber, 0x031\n      /* \"Incoming remote op minSequence# < local collabWindow's minSequence#\" */\n      );\n\n      if (traceStart) {\n        this.accumTime += elapsedMicroseconds(traceStart);\n        this.accumOps++;\n        this.accumWindow += this.getCurrentSeq() - this.getCollabWindow().minSeq;\n      }\n    }\n  }\n  /**\n   * Returns a valid range for the op, or undefined\n   * @param op - The op to generate the range for\n   * @param clientArgs - The client args for the op\n   */\n\n\n  getValidOpRange(op, clientArgs) {\n    let start = op.pos1;\n\n    if (start === undefined && op.relativePos1) {\n      start = this.mergeTree.posFromRelativePos(op.relativePos1, clientArgs.referenceSequenceNumber, clientArgs.clientId);\n    }\n\n    let end = op.pos2;\n\n    if (end === undefined && op.relativePos2) {\n      end = this.mergeTree.posFromRelativePos(op.relativePos2, clientArgs.referenceSequenceNumber, clientArgs.clientId);\n    } // Validate if local op\n\n\n    if (clientArgs.clientId === this.getClientId()) {\n      const length = this.getLength();\n      const invalidPositions = []; // Validate start position\n      //\n\n      if (start === undefined || start < 0 || start > length || start === length && op.type !== MergeTreeDeltaType.INSERT) {\n        invalidPositions.push(\"start\");\n      } // Validate end if not insert, or insert has end\n      //\n\n\n      if (op.type !== MergeTreeDeltaType.INSERT || end !== undefined) {\n        if (end === undefined || end <= start) {\n          invalidPositions.push(\"end\");\n        }\n      }\n\n      if (invalidPositions.length > 0) {\n        throw new LoggingError(\"RangeOutOfBounds\", {\n          usageError: true,\n          end,\n          invalidPositions: invalidPositions.toString(),\n          length,\n          opPos1: op.pos1,\n          opPos1Relative: op.relativePos1 !== undefined,\n          opPos2: op.pos2,\n          opPos2Relative: op.relativePos2 !== undefined,\n          opType: op.type,\n          start\n        });\n      }\n    } // start and end are guaranteed to be non-null here, otherwise we throw above.\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\n\n    return {\n      start,\n      end\n    };\n  }\n  /**\n   * Gets the client args from the op if remote, otherwise uses the local clients info\n   * @param sequencedMessage - The sequencedMessage to get the client sequence args for\n   */\n\n\n  getClientSequenceArgsForMessage(sequencedMessage) {\n    // If there this no sequenced message, then the op is local\n    // and unacked, so use this clients sequenced args\n    //\n    if (!sequencedMessage) {\n      const segWindow = this.getCollabWindow();\n      return {\n        clientId: segWindow.clientId,\n        referenceSequenceNumber: segWindow.currentSeq,\n        sequenceNumber: this.getLocalSequenceNumber()\n      };\n    } else {\n      return {\n        clientId: this.getOrAddShortClientId(sequencedMessage.clientId),\n        referenceSequenceNumber: sequencedMessage.referenceSequenceNumber,\n        sequenceNumber: sequencedMessage.sequenceNumber\n      };\n    }\n  }\n  /**\n   * Gets the client args from the op if remote, otherwise uses the local clients info\n   * @param opArgs - The op arg to get the client sequence args for\n   */\n\n\n  getClientSequenceArgs(opArgs) {\n    return this.getClientSequenceArgsForMessage(opArgs.sequencedMessage);\n  }\n\n  ackPendingSegment(opArgs) {\n    const ackOp = deltaOpArgs => {\n      let trace;\n\n      if (this.measureOps) {\n        trace = Trace.start();\n      }\n\n      this.mergeTree.ackPendingSegment(deltaOpArgs);\n\n      if (deltaOpArgs.op.type === MergeTreeDeltaType.ANNOTATE) {\n        if (deltaOpArgs.op.combiningOp && deltaOpArgs.op.combiningOp.name === \"consensus\") {\n          this.updateConsensusProperty(deltaOpArgs.op, deltaOpArgs.sequencedMessage);\n        }\n      }\n\n      if (trace) {\n        this.accumTime += elapsedMicroseconds(trace);\n        this.accumOps++;\n        this.accumWindow += this.getCurrentSeq() - this.getCollabWindow().minSeq;\n      }\n    };\n\n    if (opArgs.op.type === MergeTreeDeltaType.GROUP) {\n      for (const memberOp of opArgs.op.ops) {\n        ackOp({\n          groupOp: opArgs.op,\n          op: memberOp,\n          sequencedMessage: opArgs.sequencedMessage\n        });\n      }\n    } else {\n      ackOp(opArgs);\n    }\n  } // as functions are modified move them above the eslint-disabled waterline and lint them\n\n\n  cloneFromSegments() {\n    const clone = new Client(this.specToSegment, this.logger, this.mergeTree.options);\n    const segments = [];\n    const newRoot = this.mergeTree.blockClone(this.mergeTree.root, segments);\n    clone.mergeTree.root = newRoot;\n    return clone;\n  }\n\n  getOrAddShortClientId(longClientId) {\n    if (!this.clientNameToIds.get(longClientId)) {\n      this.addLongClientId(longClientId);\n    }\n\n    return this.getShortClientId(longClientId);\n  }\n\n  getShortClientId(longClientId) {\n    return this.clientNameToIds.get(longClientId).data;\n  }\n\n  getLongClientId(shortClientId) {\n    if (shortClientId >= 0) {\n      return this.shortClientIdMap[shortClientId];\n    } else {\n      return \"original\";\n    }\n  }\n\n  addLongClientId(longClientId) {\n    this.clientNameToIds.put(longClientId, this.shortClientIdMap.length);\n    this.shortClientIdMap.push(longClientId);\n  }\n  /**\n   * During reconnect, we must find the positions to pending segments\n   * relative to other pending segments. This methods computes that\n   * position relative to a localSeq. Pending segments above the localSeq\n   * will be ignored.\n   *\n   * @param segment - The segment to find the position for\n   * @param localSeq - The localSeq to find the position of the segment at\n   */\n\n\n  findReconnectionPosition(segment, localSeq) {\n    assert(localSeq <= this.mergeTree.collabWindow.localSeq, 0x032\n    /* \"localSeq greater than collab window\" */\n    );\n    let segmentPosition = 0;\n    /*\n        Walk the segments up to the current segment, and calculate it's\n        position taking into account local segments that were modified,\n        after the current segment.\n         TODO: Consider embedding this information into the tree for\n        more efficient look up of pending segment positions.\n    */\n\n    this.mergeTree.walkAllSegments(this.mergeTree.root, seg => {\n      // If we've found the desired segment, terminate the walk and return 'segmentPosition'.\n      if (seg === segment) {\n        return false;\n      } // Otherwise, advance segmentPosition if the segment has been inserted and not removed\n      // with respect to the given 'localSeq'.\n      //\n      // Note that all ACKed / remote ops are applied and we only need concern ourself with\n      // determining if locally pending ops fall before/after the given 'localSeq'.\n\n\n      if ((seg.localSeq === undefined || seg.localSeq <= localSeq // Is inserted\n      ) && (seg.removedSeq === undefined || seg.localRemovedSeq > localSeq) // Not removed\n      ) {\n        segmentPosition += seg.cachedLength;\n      }\n\n      return true;\n    });\n    return segmentPosition;\n  }\n  /**\n   * Rebases a (local) position from the perspective `{ seq: seqNumberFrom, localSeq }` to the perspective\n   * of the current sequence number. This is desirable when rebasing operations for reconnection.\n   *\n   * If the position refers to a segment/offset that was removed by some operation between `seqNumberFrom` and\n   * the current sequence number, the returned position will align with the position of a reference given\n   * `SlideOnRemove` semantics.\n   */\n\n\n  rebasePosition(pos, seqNumberFrom, localSeq) {\n    assert(localSeq <= this.mergeTree.collabWindow.localSeq, 0x300\n    /* localSeq greater than collab window */\n    );\n    let segment;\n    let posAccumulated = 0;\n    let offset = pos;\n\n    const isInsertedInView = seg => seg.seq !== undefined && seg.seq !== UnassignedSequenceNumber && seg.seq <= seqNumberFrom || seg.localSeq !== undefined && seg.localSeq <= localSeq;\n\n    const isRemovedFromView = ({\n      removedSeq,\n      localRemovedSeq\n    }) => removedSeq !== undefined && removedSeq !== UnassignedSequenceNumber && removedSeq <= seqNumberFrom || localRemovedSeq !== undefined && localRemovedSeq <= localSeq;\n\n    this.mergeTree.walkAllSegments(this.mergeTree.root, seg => {\n      assert(seg.seq !== undefined || seg.localSeq !== undefined, 0x301\n      /* Either seq or localSeq should be defined */\n      );\n      segment = seg;\n\n      if (isInsertedInView(seg) && !isRemovedFromView(seg)) {\n        posAccumulated += seg.cachedLength;\n\n        if (offset >= seg.cachedLength) {\n          offset -= seg.cachedLength;\n        }\n      } // Keep going while we've yet to reach the segment at the desired position\n\n\n      return posAccumulated <= pos;\n    });\n    assert(segment !== undefined, 0x302\n    /* No segment found */\n    );\n    const seqNumberTo = this.getCollabWindow().currentSeq;\n\n    if (segment.removedSeq !== undefined && segment.removedSeq !== UnassignedSequenceNumber && segment.removedSeq <= seqNumberTo || segment.localRemovedSeq !== undefined && segment.localRemovedSeq <= localSeq) {\n      // Segment that the position was in has been removed: null out offset.\n      offset = 0;\n    }\n\n    assert(0 <= offset && offset < segment.cachedLength, 0x303\n    /* Invalid offset */\n    );\n    return this.findReconnectionPosition(segment, localSeq) + offset;\n  }\n\n  resetPendingDeltaToOps(resetOp, segmentGroup) {\n    var _a, _b;\n\n    assert(!!segmentGroup, 0x033\n    /* \"Segment group undefined\" */\n    );\n    const NACKedSegmentGroup = (_a = this.mergeTree.pendingSegments) === null || _a === void 0 ? void 0 : _a.dequeue();\n    assert(segmentGroup === NACKedSegmentGroup, 0x034\n    /* \"Segment group not at head of merge tree pending queue\" */\n    );\n    const opList = []; // We need to sort the segments by ordinal, as the segments are not sorted in the segment group.\n    // The reason they need them sorted, as they have the same local sequence number and which means\n    // farther segments will  take into account nearer segments when calculating their position.\n    // By sorting we ensure the nearer segment will be applied and sequenced before the father segments\n    // so their recalculated positions will be correct.\n\n    for (const segment of segmentGroup.segments.sort((a, b) => a.ordinal < b.ordinal ? -1 : 1)) {\n      const segmentSegGroup = segment.segmentGroups.dequeue();\n      assert(segmentGroup === segmentSegGroup, 0x035\n      /* \"Segment group not at head of segment pending queue\" */\n      );\n      const segmentPosition = this.findReconnectionPosition(segment, segmentGroup.localSeq);\n      let newOp;\n\n      switch (resetOp.type) {\n        case MergeTreeDeltaType.ANNOTATE:\n          assert(((_b = segment.propertyManager) === null || _b === void 0 ? void 0 : _b.hasPendingProperties()) === true, 0x036\n          /* \"Segment has no pending properties\" */\n          ); // if the segment has been removed, there's no need to send the annotate op\n          // unless the remove was local, in which case the annotate must have come\n          // before the remove\n\n          if (segment.removedSeq === undefined || segment.localRemovedSeq !== undefined) {\n            newOp = createAnnotateRangeOp(segmentPosition, segmentPosition + segment.cachedLength, resetOp.props, resetOp.combiningOp);\n          }\n\n          break;\n\n        case MergeTreeDeltaType.INSERT:\n          assert(segment.seq === UnassignedSequenceNumber, 0x037\n          /* \"Segment already has assigned sequence number\" */\n          );\n          let segInsertOp = segment;\n\n          if (typeof resetOp.seg === \"object\" && resetOp.seg.props !== undefined) {\n            segInsertOp = segment.clone();\n            segInsertOp.properties = resetOp.seg.props;\n          }\n\n          newOp = createInsertSegmentOp(segmentPosition, segInsertOp);\n          break;\n\n        case MergeTreeDeltaType.REMOVE:\n          if (segment.localRemovedSeq !== undefined) {\n            newOp = createRemoveRangeOp(segmentPosition, segmentPosition + segment.cachedLength);\n          }\n\n          break;\n\n        default:\n          throw new Error(`Invalid op type`);\n      }\n\n      if (newOp) {\n        const newSegmentGroup = {\n          segments: [],\n          localSeq: segmentGroup.localSeq\n        };\n        segment.segmentGroups.enqueue(newSegmentGroup);\n        this.mergeTree.pendingSegments.enqueue(newSegmentGroup);\n        opList.push(newOp);\n      }\n    }\n\n    return opList;\n  }\n\n  applyRemoteOp(opArgs) {\n    const op = opArgs.op;\n    const msg = opArgs.sequencedMessage;\n    this.getOrAddShortClientId(msg.clientId);\n\n    switch (op.type) {\n      case MergeTreeDeltaType.INSERT:\n        this.applyInsertOp(opArgs);\n        break;\n\n      case MergeTreeDeltaType.REMOVE:\n        this.applyRemoveRangeOp(opArgs);\n        break;\n\n      case MergeTreeDeltaType.ANNOTATE:\n        this.applyAnnotateRangeOp(opArgs);\n        break;\n\n      case MergeTreeDeltaType.GROUP:\n        {\n          for (const memberOp of op.ops) {\n            this.applyRemoteOp({\n              op: memberOp,\n              groupOp: op,\n              sequencedMessage: msg\n            });\n          }\n\n          break;\n        }\n\n      default:\n        break;\n    }\n  }\n\n  applyStashedOp(op) {\n    let metadata;\n\n    switch (op.type) {\n      case MergeTreeDeltaType.INSERT:\n        this.applyInsertOp({\n          op\n        });\n        metadata = this.peekPendingSegmentGroups();\n        break;\n\n      case MergeTreeDeltaType.REMOVE:\n        this.applyRemoveRangeOp({\n          op\n        });\n        metadata = this.peekPendingSegmentGroups();\n        break;\n\n      case MergeTreeDeltaType.ANNOTATE:\n        this.applyAnnotateRangeOp({\n          op\n        });\n        metadata = this.peekPendingSegmentGroups();\n        break;\n\n      case MergeTreeDeltaType.GROUP:\n        return op.ops.map(o => this.applyStashedOp(o));\n\n      default:\n        unreachableCase(op, \"unrecognized op type\");\n    }\n\n    assert(!!metadata, 0x2db\n    /* \"Applying op must generate a pending segment\" */\n    );\n    return metadata;\n  }\n\n  applyMsg(msg, local = false) {\n    var _a; // Ensure client ID is registered\n\n\n    this.getOrAddShortClientId(msg.clientId); // Apply if an operation message\n\n    if (msg.type === MessageType.Operation) {\n      const opArgs = {\n        op: msg.contents,\n        sequencedMessage: msg\n      };\n\n      if (((_a = opArgs.sequencedMessage) === null || _a === void 0 ? void 0 : _a.clientId) === this.longClientId || local) {\n        this.ackPendingSegment(opArgs);\n      } else {\n        this.applyRemoteOp(opArgs);\n      }\n    }\n\n    this.updateSeqNumbers(msg.minimumSequenceNumber, msg.sequenceNumber);\n  }\n\n  updateSeqNumbers(min, seq) {\n    const collabWindow = this.mergeTree.getCollabWindow(); // Equal is fine here due to SharedSegmentSequence<>.snapshotContent() potentially updating with same #\n\n    assert(collabWindow.currentSeq <= seq, 0x038\n    /* \"Incoming op sequence# < local collabWindow's currentSequence#\" */\n    );\n    collabWindow.currentSeq = seq;\n    assert(min <= seq, 0x039\n    /* \"Incoming op sequence# < minSequence#\" */\n    );\n    this.updateMinSeq(min);\n  }\n  /**\n   * Resolves a remote client's position against the local sequence\n   * and returns the remote client's position relative to the local\n   * sequence\n   * @param remoteClientPosition - The remote client's position to resolve\n   * @param remoteClientRefSeq - The reference sequence number of the remote client\n   * @param remoteClientId - The client id of the remote client\n   */\n\n\n  resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {\n    const shortRemoteClientId = this.getOrAddShortClientId(remoteClientId);\n    return this.mergeTree.resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, shortRemoteClientId);\n  }\n  /**\n   *  Given an pending operation and segment group, regenerate the op, so it\n   *  can be resubmitted\n   * @param resetOp - The op to reset\n   * @param segmentGroup - The segment group associated with the op\n   */\n\n\n  regeneratePendingOp(resetOp, segmentGroup) {\n    const opList = [];\n\n    if (resetOp.type === MergeTreeDeltaType.GROUP) {\n      if (Array.isArray(segmentGroup)) {\n        assert(resetOp.ops.length === segmentGroup.length, 0x03a\n        /* \"Number of ops in 'resetOp' must match the number of segment groups provided.\" */\n        );\n\n        for (let i = 0; i < resetOp.ops.length; i++) {\n          opList.push(...this.resetPendingDeltaToOps(resetOp.ops[i], segmentGroup[i]));\n        }\n      } else {\n        // A group op containing a single op will pass a direct reference to 'segmentGroup'\n        // rather than an array of segment groups.  (See 'peekPendingSegmentGroups()')\n        assert(resetOp.ops.length === 1, 0x03b\n        /* \"Number of ops in 'resetOp' must match the number of segment groups provided.\" */\n        );\n        opList.push(...this.resetPendingDeltaToOps(resetOp.ops[0], segmentGroup));\n      }\n    } else {\n      assert(resetOp.type !== MergeTreeDeltaType.GROUP, 0x03c\n      /* \"Reset op has 'group' delta type!\" */\n      );\n      assert(!Array.isArray(segmentGroup), 0x03d\n      /* \"segmentGroup is array rather than singleton!\" */\n      );\n      opList.push(...this.resetPendingDeltaToOps(resetOp, segmentGroup));\n    }\n\n    return opList.length === 1 ? opList[0] : createGroupOp(...opList);\n  }\n\n  createTextHelper() {\n    return new MergeTreeTextHelper(this.mergeTree);\n  }\n\n  summarize(runtime, handle, serializer, catchUpMsgs) {\n    var _a;\n\n    const deltaManager = runtime.deltaManager;\n    const minSeq = deltaManager.minimumSequenceNumber; // Catch up to latest MSN, if we have not had a chance to do it.\n    // Required for case where FluidDataStoreRuntime.attachChannel()\n    // generates summary right after loading data store.\n\n    this.updateSeqNumbers(minSeq, deltaManager.lastSequenceNumber); // One of the summaries (from SPO) I observed to have chunk.chunkSequenceNumber > minSeq!\n    // Not sure why - need to catch it sooner\n\n    assert(this.getCollabWindow().minSeq === minSeq, 0x03e\n    /* \"minSeq mismatch between collab window and delta manager!\" */\n    ); // Must continue to support legacy\n    //       (See https://github.com/microsoft/FluidFramework/issues/84)\n\n    if (((_a = this.mergeTree.options) === null || _a === void 0 ? void 0 : _a.newMergeTreeSnapshotFormat) === true) {\n      assert(catchUpMsgs === undefined || catchUpMsgs.length === 0, 0x03f\n      /* \"New format should not emit catchup ops\" */\n      );\n      const snap = new SnapshotV1(this.mergeTree, this.logger, id => this.getLongClientId(id));\n      snap.extractSync();\n      return snap.emit(serializer, handle);\n    } else {\n      const snap = new SnapshotLegacy(this.mergeTree, this.logger);\n      snap.extractSync();\n      return snap.emit(catchUpMsgs, serializer, handle);\n    }\n  }\n\n  load(runtime, storage, serializer) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const loader = new SnapshotLoader(runtime, _this, _this.mergeTree, _this.logger, serializer);\n      return loader.initialize(storage);\n    })();\n  }\n\n  getStackContext(startPos, rangeLabels) {\n    return this.mergeTree.getStackContext(startPos, this.getCollabWindow().clientId, rangeLabels);\n  }\n\n  getLocalSequenceNumber() {\n    const segWindow = this.getCollabWindow();\n\n    if (segWindow.collaborating) {\n      return UnassignedSequenceNumber;\n    } else {\n      return UniversalSequenceNumber;\n    }\n  }\n\n  localTransaction(groupOp) {\n    for (const op of groupOp.ops) {\n      const opArgs = {\n        op,\n        groupOp\n      };\n\n      switch (op.type) {\n        case MergeTreeDeltaType.INSERT:\n          this.applyInsertOp(opArgs);\n          break;\n\n        case MergeTreeDeltaType.ANNOTATE:\n          this.applyAnnotateRangeOp(opArgs);\n          break;\n\n        case MergeTreeDeltaType.REMOVE:\n          this.applyRemoveRangeOp(opArgs);\n          break;\n\n        default:\n          break;\n      }\n    }\n  }\n\n  updateConsensusProperty(op, msg) {\n    const markerId = op.relativePos1.id;\n    const consensusInfo = this.pendingConsensus.get(markerId);\n\n    if (consensusInfo) {\n      consensusInfo.marker.addProperties(op.props, op.combiningOp, msg.sequenceNumber);\n    }\n\n    this.mergeTree.addMinSeqListener(msg.sequenceNumber, () => consensusInfo.callback(consensusInfo.marker));\n  }\n\n  updateMinSeq(minSeq) {\n    let trace;\n\n    if (this.measureOps) {\n      trace = Trace.start();\n    }\n\n    this.mergeTree.setMinSeq(minSeq);\n\n    if (trace) {\n      const elapsed = elapsedMicroseconds(trace);\n      this.accumWindowTime += elapsed;\n\n      if (elapsed > this.maxWindowTime) {\n        this.maxWindowTime = elapsed;\n      }\n    }\n  }\n\n  getContainingSegment(pos, op) {\n    const args = this.getClientSequenceArgsForMessage(op);\n    return this.mergeTree.getContainingSegment(pos, args.referenceSequenceNumber, args.clientId);\n  }\n  /**\n   * Returns the position to slide a reference to if a slide is required.\n   * @param segoff - The segment and offset to slide from\n   * @returns - segment and offset to slide the reference to\n   */\n\n\n  getSlideToSegment(segoff) {\n    return this.mergeTree._getSlideToSegment(segoff);\n  }\n\n  getPropertiesAtPosition(pos) {\n    let propertiesAtPosition;\n    const segoff = this.getContainingSegment(pos);\n    const seg = segoff.segment;\n\n    if (seg) {\n      propertiesAtPosition = seg.properties;\n    }\n\n    return propertiesAtPosition;\n  }\n\n  getRangeExtentsOfPosition(pos) {\n    let posStart;\n    let posAfterEnd;\n    const segoff = this.getContainingSegment(pos);\n    const seg = segoff.segment;\n\n    if (seg) {\n      posStart = this.getPosition(seg);\n      posAfterEnd = posStart + seg.cachedLength;\n    }\n\n    return {\n      posStart,\n      posAfterEnd\n    };\n  }\n\n  getCurrentSeq() {\n    return this.getCollabWindow().currentSeq;\n  }\n\n  getClientId() {\n    return this.getCollabWindow().clientId;\n  }\n\n  getLength() {\n    return this.mergeTree.length;\n  }\n\n  startOrUpdateCollaboration(longClientId, minSeq = 0, currentSeq = 0) {\n    // we should always have a client id if we are collaborating\n    // if the client id is undefined we are likely bound to a detached\n    // container, so we should keep going in local mode. once\n    // the container attaches this will be called again on connect with the\n    // client id\n    if (longClientId !== undefined) {\n      if (this.longClientId === undefined) {\n        this.longClientId = longClientId;\n        this.addLongClientId(this.longClientId);\n        this.mergeTree.startCollaboration(this.getShortClientId(this.longClientId), minSeq, currentSeq);\n      } else {\n        const oldClientId = this.longClientId;\n        const oldData = this.clientNameToIds.get(oldClientId).data;\n        this.longClientId = longClientId;\n        this.clientNameToIds.put(longClientId, oldData);\n        this.shortClientIdMap[oldData] = longClientId;\n      }\n    }\n  }\n\n  findTile(startPos, tileLabel, preceding = true) {\n    const clientId = this.getClientId();\n    return this.mergeTree.findTile(startPos, clientId, tileLabel, preceding);\n  }\n\n} //# sourceMappingURL=client.js.map","map":null,"metadata":{},"sourceType":"module"}