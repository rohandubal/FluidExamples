{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, unreachableCase } from \"@fluidframework/common-utils\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { UsageError } from \"@fluidframework/container-utils\";\nimport { TelemetryDataTag } from \"@fluidframework/telemetry-utils\";\n/**\n * Type guard that returns true if the given alias message is actually an instance of\n * a class which implements {@link IDataStoreAliasMessage}\n * @param maybeDataStoreAliasMessage - message object to be validated\n * @returns True if the {@link IDataStoreAliasMessage} is fully implemented, false otherwise\n */\n\nexport const isDataStoreAliasMessage = maybeDataStoreAliasMessage => {\n  return typeof (maybeDataStoreAliasMessage === null || maybeDataStoreAliasMessage === void 0 ? void 0 : maybeDataStoreAliasMessage.internalId) === \"string\" && typeof (maybeDataStoreAliasMessage === null || maybeDataStoreAliasMessage === void 0 ? void 0 : maybeDataStoreAliasMessage.alias) === \"string\";\n};\nexport const channelToDataStore = (fluidDataStoreChannel, internalId, runtime, datastores, logger) => new DataStore(fluidDataStoreChannel, internalId, runtime, datastores, logger);\nvar AliasState = /*#__PURE__*/(() => {\n  (function (AliasState) {\n    AliasState[\"Aliased\"] = \"Aliased\";\n    AliasState[\"Aliasing\"] = \"Aliasing\";\n    AliasState[\"None\"] = \"None\";\n  })(AliasState || (AliasState = {}));\n\n  return AliasState;\n})();\n\nclass DataStore {\n  constructor(fluidDataStoreChannel, internalId, runtime, datastores, logger) {\n    this.fluidDataStoreChannel = fluidDataStoreChannel;\n    this.internalId = internalId;\n    this.runtime = runtime;\n    this.datastores = datastores;\n    this.logger = logger;\n    this.aliasState = AliasState.None;\n  }\n\n  trySetAlias(alias) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (alias.includes(\"/\")) {\n        throw new UsageError(`The alias cannot contain slashes: '${alias}'`);\n      }\n\n      switch (_this.aliasState) {\n        // If we're already aliasing, check if it's for the same value and return\n        // the stored promise, otherwise return 'AlreadyAliased'\n        case AliasState.Aliasing:\n          assert(_this.aliasResult !== undefined, 0x316\n          /* There should be a cached promise of in-progress aliasing */\n          );\n          yield _this.aliasResult;\n          return _this.alias === alias ? \"Success\" : \"AlreadyAliased\";\n        // If this datastore is already aliased, return true only if this\n        // is a repeated call for the same alias\n\n        case AliasState.Aliased:\n          return _this.alias === alias ? \"Success\" : \"AlreadyAliased\";\n        // There is no current or past alias operation for this datastore,\n        // it is safe to continue execution\n\n        case AliasState.None:\n          break;\n\n        default:\n          unreachableCase(_this.aliasState);\n      }\n\n      _this.aliasState = AliasState.Aliasing;\n      _this.aliasResult = _this.trySetAliasInternal(alias);\n      return _this.aliasResult;\n    })();\n  }\n\n  trySetAliasInternal(alias) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const message = {\n        internalId: _this2.internalId,\n        alias\n      }; // back-compat 0.58.2000 - makeVisibleAndAttachGraph was added in this version to IFluidDataStoreChannel. For\n      // older versions, we still have to call bindToContext.\n\n      if (_this2.fluidDataStoreChannel.makeVisibleAndAttachGraph !== undefined) {\n        _this2.fluidDataStoreChannel.makeVisibleAndAttachGraph();\n      } else {\n        _this2.fluidDataStoreChannel.bindToContext();\n      }\n\n      if (_this2.runtime.attachState === AttachState.Detached) {\n        const localResult = _this2.datastores.processAliasMessageCore(message); // Explicitly lock-out future attempts of aliasing,\n        // regardless of result\n\n\n        _this2.aliasState = AliasState.Aliased;\n        return localResult ? \"Success\" : \"Conflict\";\n      }\n\n      const aliased = yield _this2.ackBasedPromise(resolve => {\n        _this2.runtime.submitDataStoreAliasOp(message, resolve);\n      }).then(succeeded => {\n        // Explicitly Lock-out future attempts of aliasing,\n        // regardless of result\n        _this2.aliasState = AliasState.Aliased;\n\n        if (succeeded) {\n          _this2.alias = alias;\n        }\n\n        return succeeded;\n      }).catch(error => {\n        _this2.logger.sendErrorEvent({\n          eventName: \"AliasingException\",\n          alias: {\n            value: alias,\n            tag: TelemetryDataTag.UserData\n          },\n          internalId: {\n            value: _this2.internalId,\n            tag: TelemetryDataTag.PackageData\n          }\n        }, error);\n\n        _this2.aliasState = AliasState.None;\n        return false;\n      });\n      return aliased ? \"Success\" : \"Conflict\";\n    })();\n  }\n\n  request(request) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this3.fluidDataStoreChannel.request(request);\n    })();\n  }\n\n  get IFluidRouter() {\n    return this.fluidDataStoreChannel;\n  }\n\n  ackBasedPromise(executor) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      let rejectBecauseDispose;\n      return new Promise((resolve, reject) => {\n        rejectBecauseDispose = () => reject(new Error(\"ContainerRuntime disposed while this ack-based Promise was pending\"));\n\n        if (_this4.runtime.disposed) {\n          rejectBecauseDispose();\n          return;\n        }\n\n        _this4.runtime.on(\"dispose\", rejectBecauseDispose);\n\n        executor(resolve, reject);\n      }).finally(() => {\n        _this4.runtime.off(\"dispose\", rejectBecauseDispose);\n      });\n    })();\n  }\n\n} //# sourceMappingURL=dataStore.js.map","map":null,"metadata":{},"sourceType":"module"}