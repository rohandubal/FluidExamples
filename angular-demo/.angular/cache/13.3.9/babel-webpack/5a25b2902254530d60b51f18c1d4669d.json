{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { assert, bufferToString } from \"@fluidframework/common-utils\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { NonCollabClient, UniversalSequenceNumber } from \"./constants\";\nimport { hasMergeInfo } from \"./snapshotChunks\";\nimport { SnapshotV1 } from \"./snapshotV1\";\nimport { SnapshotLegacy } from \"./snapshotlegacy\";\nexport class SnapshotLoader {\n  constructor(runtime, client, mergeTree, logger, serializer) {\n    this.runtime = runtime;\n    this.client = client;\n    this.mergeTree = mergeTree;\n    this.serializer = serializer;\n\n    this.specToSegment = spec => {\n      var _a;\n\n      let seg;\n\n      if (hasMergeInfo(spec)) {\n        seg = this.client.specToSegment(spec.json); // `specToSegment()` initializes `seg` with the LocalClientId.  Overwrite this with\n        // the `spec` client (if specified).  Otherwise overwrite with `NonCollabClient`.\n\n        seg.clientId = spec.client !== undefined ? this.client.getOrAddShortClientId(spec.client) : NonCollabClient;\n        seg.seq = spec.seq !== undefined ? spec.seq : UniversalSequenceNumber;\n\n        if (spec.removedSeq !== undefined) {\n          seg.removedSeq = spec.removedSeq;\n        } // this format had a bug where it didn't store all the overlap clients\n        // this is for back compat, so we change the singular id to an array\n        // this will only cause problems if there is an overlapping delete\n        // spanning the snapshot, which should be rare\n\n\n        if (spec.removedClient !== undefined) {\n          seg.removedClientIds = [this.client.getOrAddShortClientId(spec.removedClient)];\n        }\n\n        if (spec.removedClientIds !== undefined) {\n          seg.removedClientIds = (_a = spec.removedClientIds) === null || _a === void 0 ? void 0 : _a.map(sid => this.client.getOrAddShortClientId(sid));\n        }\n      } else {\n        seg = this.client.specToSegment(spec);\n        seg.seq = UniversalSequenceNumber; // `specToSegment()` initializes `seg` with the LocalClientId.  We must overwrite this with\n        // `NonCollabClient`.\n\n        seg.clientId = NonCollabClient;\n      }\n\n      return seg;\n    };\n\n    this.logger = ChildLogger.create(logger, \"SnapshotLoader\");\n  }\n\n  initialize(services) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const headerLoadedP = services.readBlob(SnapshotLegacy.header).then(header => {\n        assert(!!header, 0x05f\n        /* \"Missing blob header on legacy snapshot!\" */\n        );\n        return _this.loadHeader(bufferToString(header, \"utf8\"));\n      });\n\n      const catchupOpsP = _this.loadBodyAndCatchupOps(headerLoadedP, services);\n\n      catchupOpsP.catch(err => _this.logger.sendErrorEvent({\n        eventName: \"CatchupOpsLoadFailure\"\n      }, err));\n      yield headerLoadedP;\n      return {\n        catchupOpsP\n      };\n    })();\n  }\n\n  loadBodyAndCatchupOps(headerChunkP, services) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const blobsP = services.list(\"\");\n      const headerChunk = yield headerChunkP; // TODO we shouldn't need to wait on the body being complete to finish initialization.\n      // To fully support this we need to be able to process inbound ops for pending segments.\n\n      yield _this2.loadBody(headerChunk, services);\n      const blobs = yield blobsP;\n\n      if (blobs.length === headerChunk.headerMetadata.orderedChunkMetadata.length + 1) {\n        headerChunk.headerMetadata.orderedChunkMetadata.forEach(md => blobs.splice(blobs.indexOf(md.id), 1));\n        assert(blobs.length === 1, 0x060\n        /* There should be only one blob with catch up ops */\n        ); // TODO: The 'Snapshot.catchupOps' tree entry is purely for backwards compatibility.\n        //       (See https://github.com/microsoft/FluidFramework/issues/84)\n\n        return _this2.loadCatchupOps(services.readBlob(blobs[0]));\n      } else if (blobs.length !== headerChunk.headerMetadata.orderedChunkMetadata.length) {\n        throw new Error(\"Unexpected blobs in snapshot\");\n      }\n\n      return [];\n    })();\n  }\n\n  loadHeader(header) {\n    var _a;\n\n    const chunk = SnapshotV1.processChunk(SnapshotLegacy.header, header, this.logger, this.mergeTree.options, this.serializer);\n    const segs = chunk.segments.map(this.specToSegment);\n    this.mergeTree.reloadFromSegments(segs);\n\n    if (chunk.headerMetadata === undefined) {\n      throw new Error(\"header metadata not available\");\n    } // If we load a detached container from snapshot, then we don't supply a default clientId\n    // because we don't want to start collaboration.\n\n\n    if (this.runtime.attachState !== AttachState.Detached) {\n      // specify a default client id, \"snapshot\" here as we\n      // should enter collaboration/op sending mode if we load\n      // a snapshot in any case (summary or attach message)\n      // once we get a client id this will be called with that\n      // clientId in the connected event\n      this.client.startOrUpdateCollaboration((_a = this.runtime.clientId) !== null && _a !== void 0 ? _a : \"snapshot\", // TODO: Make 'minSeq' non-optional once the new snapshot format becomes the default?\n      //       (See https://github.com/microsoft/FluidFramework/issues/84)\n\n      /* minSeq: */\n      chunk.headerMetadata.minSequenceNumber !== undefined ? chunk.headerMetadata.minSequenceNumber : chunk.headerMetadata.sequenceNumber,\n      /* currentSeq: */\n      chunk.headerMetadata.sequenceNumber);\n    }\n\n    return chunk;\n  }\n\n  loadBody(chunk1, services) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      assert(chunk1.length <= chunk1.headerMetadata.totalLength, 0x061\n      /* \"Mismatch in totalLength\" */\n      );\n      assert(chunk1.segmentCount <= chunk1.headerMetadata.totalSegmentCount, 0x062\n      /* \"Mismatch in totalSegmentCount\" */\n      );\n\n      if (chunk1.segmentCount === chunk1.headerMetadata.totalSegmentCount) {\n        return;\n      }\n\n      const segs = [];\n      let lengthSofar = chunk1.length;\n\n      for (let chunkIndex = 1; chunkIndex < chunk1.headerMetadata.orderedChunkMetadata.length; chunkIndex++) {\n        const chunk = yield SnapshotV1.loadChunk(services, chunk1.headerMetadata.orderedChunkMetadata[chunkIndex].id, _this3.logger, _this3.mergeTree.options, _this3.serializer);\n        lengthSofar += chunk.length; // Deserialize each chunk segment and append it to the end of the MergeTree.\n\n        segs.push(...chunk.segments.map(_this3.specToSegment));\n      }\n\n      assert(lengthSofar === chunk1.headerMetadata.totalLength, 0x063\n      /* \"Mismatch in totalLength\" */\n      );\n      assert(chunk1.segmentCount + segs.length === chunk1.headerMetadata.totalSegmentCount, 0x064\n      /* \"Mismatch in totalSegmentCount\" */\n      ); // Helper to insert segments at the end of the MergeTree.\n\n      const mergeTree = _this3.mergeTree;\n\n      const append = (segments, cli, seq) => {\n        mergeTree.insertSegments(mergeTree.root.cachedLength, segments,\n        /* refSeq: */\n        UniversalSequenceNumber, cli, seq, undefined);\n      }; // Helpers to batch-insert segments that are below the min seq\n\n\n      const batch = [];\n\n      const flushBatch = () => {\n        if (batch.length > 0) {\n          append(batch, NonCollabClient, UniversalSequenceNumber);\n        }\n      };\n\n      for (const seg of segs) {\n        const cli = seg.clientId;\n        const seq = seg.seq; // If the segment can be batch inserted, add it to the 'batch' array.  Otherwise, flush\n        // any batched segments and then insert the current segment individually.\n\n        if (cli === NonCollabClient && seq === UniversalSequenceNumber) {\n          batch.push(seg);\n        } else {\n          flushBatch();\n          append([seg], cli, seq);\n        }\n      }\n\n      flushBatch();\n    })();\n  }\n  /**\n   * If loading from a snapshot, get the catchup messages.\n   * @param rawMessages - The messages in original encoding\n   * @returns The decoded messages, but handles aren't parsed.  Matches the format that will be passed in\n   * SharedObject.processCore.\n   */\n\n\n  loadCatchupOps(rawMessages) {\n    return _asyncToGenerator(function* () {\n      return JSON.parse(bufferToString(yield rawMessages, \"utf8\"));\n    })();\n  }\n\n} //# sourceMappingURL=snapshotLoader.js.map","map":null,"metadata":{},"sourceType":"module"}