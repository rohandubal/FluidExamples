{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { FluidDataStoreRuntime, mixinRequestHandler } from \"@fluidframework/datastore\";\nimport { FluidDataStoreRegistry } from \"@fluidframework/container-runtime\";\nimport { DependencyContainer } from \"@fluidframework/synthesize\";\nimport { PureDataObject } from \"../data-objects\";\n/**\n * Proxy over PureDataObject\n * Does delayed creation & initialization of PureDataObject\n*/\n\nfunction createDataObject(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n  return _createDataObject.apply(this, arguments);\n}\n/**\n * PureDataObjectFactory is a barebones IFluidDataStoreFactory for use with PureDataObject.\n * Consumers should typically use DataObjectFactory instead unless creating\n * another base data store factory.\n *\n * @typeParam TObj - DataObject (concrete type)\n * @typeParam I - The input types for the DataObject\n */\n\n\nfunction _createDataObject() {\n  _createDataObject = _asyncToGenerator(function* (ctor, context, sharedObjectRegistry, optionalProviders, runtimeClassArg, existing, initProps) {\n    // base\n    let runtimeClass = runtimeClassArg; // request mixin in\n\n    runtimeClass = mixinRequestHandler( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (request, runtimeArg) {\n        return (yield PureDataObject.getDataObject(runtimeArg)).request(request);\n      });\n\n      return function (_x8, _x9) {\n        return _ref.apply(this, arguments);\n      };\n    }(), runtimeClass); // Create a new runtime for our data store\n    // The runtime is what Fluid uses to create DDS' and route to your data store\n\n    const runtime = new runtimeClass(context, sharedObjectRegistry, existing); // Create object right away.\n    // This allows object to register various callbacks with runtime before runtime\n    // becomes globally available. But it's not full initialization - constructor can't\n    // access DDSes or other services of runtime as objects are not fully initialized.\n    // In order to use object, we need to go through full initialization by calling finishInitialization().\n\n    const scope = context.scope;\n    const dependencyContainer = new DependencyContainer(scope.IFluidDependencySynthesizer);\n    const providers = dependencyContainer.synthesize(optionalProviders, {});\n    const instance = new ctor({\n      runtime,\n      context,\n      providers,\n      initProps\n    }); // if it's a newly created object, we need to wait for it to finish initialization\n    // as that results in creation of DDSes, before it gets attached, providing atomic\n    // guarantee of creation.\n    // WARNING: we can't do the same (yet) for already existing PureDataObject!\n    // This will result in deadlock, as it tries to resolve internal handles, but any\n    // handle resolution goes through root (container runtime), which can't route it back\n    // to this data store, as it's still not initialized and not known to container runtime yet.\n    // In the future, we should address it by using relative paths for handles and be able to resolve\n    // local DDSes while data store is not fully initialized.\n\n    if (!existing) {\n      yield instance.finishInitialization(existing);\n    }\n\n    return {\n      instance,\n      runtime\n    };\n  });\n  return _createDataObject.apply(this, arguments);\n}\n\nexport class PureDataObjectFactory {\n  constructor(type, ctor, sharedObjects, optionalProviders, registryEntries, runtimeClass = FluidDataStoreRuntime) {\n    this.type = type;\n    this.ctor = ctor;\n    this.optionalProviders = optionalProviders;\n    this.runtimeClass = runtimeClass;\n\n    if (this.type === \"\") {\n      throw new Error(\"undefined type member\");\n    }\n\n    if (registryEntries !== undefined) {\n      this.registry = new FluidDataStoreRegistry(registryEntries);\n    }\n\n    this.sharedObjectRegistry = new Map(sharedObjects.map(ext => [ext.type, ext]));\n  }\n\n  get IFluidDataStoreFactory() {\n    return this;\n  }\n\n  get IFluidDataStoreRegistry() {\n    return this.registry;\n  }\n  /**\n   * Convenience helper to get the data store's/factory's data store registry entry.\n   * The return type hides the factory's generics, easing grouping of registry\n   * entries that differ only in this way into the same array.\n   * @returns The NamedFluidDataStoreRegistryEntry\n   */\n\n\n  get registryEntry() {\n    return [this.type, Promise.resolve(this)];\n  }\n  /**\n   * This is where we do data store setup.\n   *\n   * @param context - data store context used to load a data store runtime\n   */\n\n\n  instantiateDataStore(context, existing) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        runtime\n      } = yield createDataObject(_this.ctor, context, _this.sharedObjectRegistry, _this.optionalProviders, _this.runtimeClass, existing);\n      return runtime;\n    })();\n  }\n  /**\n   * Creates a new instance of the object. Uses parent context's registry to build package path to this factory.\n   * In other words, registry of context passed in has to contain this factory, with the name that matches\n   * this factory's type.\n   * It is intended to be used by data store objects that create sub-objects.\n   * @param context - The context being used to create the runtime\n   * (the created object will have its own new context created as well)\n   * @param initialState - The initial state to provide to the created data store.\n   * @returns an object created by this factory. Data store and objects created are not attached to container.\n   * They get attached only when a handle to one of them is attached to already attached objects.\n   */\n\n\n  createChildInstance(parentContext, initialState) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2.createNonRootInstanceCore(parentContext.containerRuntime, [...parentContext.packagePath, _this2.type], initialState);\n    })();\n  }\n  /**\n   * Creates a new instance of the object. Uses peer context's registry and its package path to identify this factory.\n   * In other words, registry of context passed in has to have this factory.\n   * Intended to be used by data store objects that need to create peers (similar) instances of existing objects.\n   * @param context - The component context being used to create the object\n   * (the created object will have its own new context created as well)\n   * @param initialState - The initial state to provide to the created component.\n   * @returns an object created by this factory. Data store and objects created are not attached to container.\n   * They get attached only when a handle to one of them is attached to already attached objects.\n   */\n\n\n  createPeerInstance(peerContext, initialState) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this3.createNonRootInstanceCore(peerContext.containerRuntime, peerContext.packagePath, initialState);\n    })();\n  }\n  /**\n   * Creates a new instance of the object. Uses container's registry to find this factory.\n   * It's expected that only container owners would use this functionality, as only such developers\n   * have knowledge of entries in container registry.\n   * The name in this registry for such record should match type of this factory.\n   * @param runtime - container runtime. It's registry is used to create an object.\n   * @param initialState - The initial state to provide to the created component.\n   * @returns an object created by this factory. Data store and objects created are not attached to container.\n   * They get attached only when a handle to one of them is attached to already attached objects.\n   */\n\n\n  createInstance(runtime, initialState) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this4.createNonRootInstanceCore(runtime, [_this4.type], initialState);\n    })();\n  }\n  /**\n   * Creates a new root instance of the object. Uses container's registry to find this factory.\n   * It's expected that only container owners would use this functionality, as only such developers\n   * have knowledge of entries in container registry.\n   * The name in this registry for such record should match type of this factory.\n   * @param runtime - container runtime. It's registry is used to create an object.\n   * @param initialState - The initial state to provide to the created component.\n   * @returns an object created by this factory. Data store and objects created are not attached to container.\n   * They get attached only when a handle to one of them is attached to already attached objects.\n   */\n\n\n  createRootInstance(rootDataStoreId, runtime, initialState) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const context = runtime.createDetachedRootDataStore([_this5.type], rootDataStoreId);\n      return _this5.createInstanceCore(context, initialState);\n    })();\n  }\n\n  createNonRootInstanceCore(containerRuntime, packagePath, initialState) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const context = containerRuntime.createDetachedDataStore(packagePath);\n      return _this6.createInstanceCore(context, initialState);\n    })();\n  }\n\n  createInstanceCore(context, initialState) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        instance,\n        runtime\n      } = yield createDataObject(_this7.ctor, context, _this7.sharedObjectRegistry, _this7.optionalProviders, _this7.runtimeClass, false, // existing\n      initialState);\n      yield context.attachRuntime(_this7, runtime);\n      return instance;\n    })();\n  }\n\n} //# sourceMappingURL=pureDataObjectFactory.js.map","map":null,"metadata":{},"sourceType":"module"}