{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { default as AbortController } from \"abort-controller\";\nimport { v4 as uuid } from \"uuid\";\nimport { assert, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { normalizeError, logIfFalse, safeRaiseEvent } from \"@fluidframework/telemetry-utils\";\nimport { DriverErrorType } from \"@fluidframework/driver-definitions\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { NonRetryableError, isClientMessage } from \"@fluidframework/driver-utils\";\nimport { ThrottlingWarning, DataCorruptionError, extractSafePropertiesFromMessage, DataProcessingError } from \"@fluidframework/container-utils\";\nimport { DeltaQueue } from \"./deltaQueue\";\n/**\n * Manages the flow of both inbound and outbound messages. This class ensures that shared objects receive delta\n * messages in order regardless of possible network conditions or timings causing out of order delivery.\n */\n\nexport class DeltaManager extends TypedEventEmitter {\n  constructor(serviceProvider, logger, _active, createConnectionManager) {\n    super();\n    this.serviceProvider = serviceProvider;\n    this.logger = logger;\n    this._active = _active;\n    this.pending = []; // The minimum sequence number and last sequence number received from the server\n\n    this.minSequenceNumber = 0; // There are three numbers we track\n    // * lastQueuedSequenceNumber is the last queued sequence number. If there are gaps in seq numbers, then this number\n    //   is not updated until we cover that gap, so it increases each time by 1.\n    // * lastObservedSeqNumber is  an estimation of last known sequence number for container in storage. It's initially\n    //   populated at web socket connection time (if storage provides that info) and is  updated once ops shows up.\n    //   It's never less than lastQueuedSequenceNumber\n    // * lastProcessedSequenceNumber - last processed sequence number\n\n    this.lastQueuedSequenceNumber = 0;\n    this.lastObservedSeqNumber = 0;\n    this.lastProcessedSequenceNumber = 0;\n    this.baseTerm = 0;\n    /**\n     * Track down the ops size.\n    */\n\n    this.opsSize = 0; // The sequence number we initially loaded from\n\n    this.initSequenceNumber = 0;\n    this.closed = false;\n    this.throttlingIdSet = new Set();\n    this.timeTillThrottling = 0;\n    this.closeAbortController = new AbortController();\n    this.deltaStorageDelayId = uuid();\n    this.deltaStreamDelayId = uuid();\n    this.messageBuffer = [];\n    const props = {\n      incomingOpHandler: (messages, reason) => {\n        try {\n          this.enqueueMessages(messages, reason);\n        } catch (error) {\n          this.logger.sendErrorEvent({\n            eventName: \"EnqueueMessages_Exception\"\n          }, error);\n          this.close(normalizeError(error));\n        }\n      },\n      signalHandler: message => this._inboundSignal.push(message),\n      reconnectionDelayHandler: (delayMs, error) => this.emitDelayInfo(this.deltaStreamDelayId, delayMs, error),\n      closeHandler: error => this.close(error),\n      disconnectHandler: reason => this.disconnectHandler(reason),\n      connectHandler: connection => this.connectHandler(connection),\n      pongHandler: latency => this.emit(\"pong\", latency),\n      readonlyChangeHandler: readonly => safeRaiseEvent(this, this.logger, \"readonly\", readonly)\n    };\n    this.connectionManager = createConnectionManager(props);\n    this._inbound = new DeltaQueue(op => {\n      this.processInboundMessage(op);\n    });\n\n    this._inbound.on(\"error\", error => {\n      this.close(DataProcessingError.wrapIfUnrecognized(error, \"deltaManagerInboundErrorHandler\", this.lastMessage));\n    }); // Inbound signal queue\n\n\n    this._inboundSignal = new DeltaQueue(message => {\n      if (this.handler === undefined) {\n        throw new Error(\"Attempted to process an inbound signal without a handler attached\");\n      }\n\n      this.handler.processSignal({\n        clientId: message.clientId,\n        content: JSON.parse(message.content)\n      });\n    });\n\n    this._inboundSignal.on(\"error\", error => {\n      this.close(normalizeError(error));\n    }); // Initially, all queues are created paused.\n    // - outbound is flipped back and forth in setupNewSuccessfulConnection / disconnectFromDeltaStream\n    // - inbound & inboundSignal are resumed in attachOpHandler() when we have handler setup\n\n  }\n\n  get active() {\n    return this._active();\n  }\n\n  get disposed() {\n    return this.closed;\n  }\n\n  get IDeltaSender() {\n    return this;\n  }\n\n  get inbound() {\n    return this._inbound;\n  }\n\n  get inboundSignal() {\n    return this._inboundSignal;\n  }\n\n  get initialSequenceNumber() {\n    return this.initSequenceNumber;\n  }\n\n  get lastSequenceNumber() {\n    return this.lastProcessedSequenceNumber;\n  }\n\n  get lastMessage() {\n    return this.lastProcessedMessage;\n  }\n\n  get lastKnownSeqNumber() {\n    return this.lastObservedSeqNumber;\n  }\n\n  get referenceTerm() {\n    return this.baseTerm;\n  }\n\n  get minimumSequenceNumber() {\n    return this.minSequenceNumber;\n  }\n  /**\n   * Tells if  current connection has checkpoint information.\n   * I.e. we know how far behind the client was at the time of establishing connection\n   */\n\n\n  get hasCheckpointSequenceNumber() {\n    // Valid to be called only if we have active connection.\n    assert(this.connectionManager.connected, 0x0df\n    /* \"Missing active connection\" */\n    );\n    return this._checkpointSequenceNumber !== undefined;\n  } // Forwarding connection manager properties / IDeltaManager implementation\n\n\n  get maxMessageSize() {\n    return this.connectionManager.maxMessageSize;\n  }\n\n  get version() {\n    return this.connectionManager.version;\n  }\n\n  get serviceConfiguration() {\n    return this.connectionManager.serviceConfiguration;\n  }\n\n  get outbound() {\n    return this.connectionManager.outbound;\n  }\n\n  get readOnlyInfo() {\n    return this.connectionManager.readOnlyInfo;\n  }\n\n  get clientDetails() {\n    return this.connectionManager.clientDetails;\n  }\n\n  submit(type, contents, batch = false, metadata) {\n    const messagePartial = {\n      contents: JSON.stringify(contents),\n      metadata,\n      referenceSequenceNumber: this.lastProcessedSequenceNumber,\n      type\n    };\n\n    if (!batch) {\n      this.flush();\n    }\n\n    const message = this.connectionManager.prepareMessageToSend(messagePartial);\n\n    if (message === undefined) {\n      return -1;\n    }\n\n    this.opsSize += message.contents.length;\n    this.messageBuffer.push(message);\n    this.emit(\"submitOp\", message);\n\n    if (!batch) {\n      this.flush();\n    }\n\n    return message.clientSequenceNumber;\n  }\n\n  submitSignal(content) {\n    return this.connectionManager.submitSignal(content);\n  }\n\n  flush() {\n    if (this.messageBuffer.length === 0) {\n      return;\n    } // The prepareFlush event allows listeners to append metadata to the batch prior to submission.\n\n\n    this.emit(\"prepareSend\", this.messageBuffer);\n    this.connectionManager.sendMessages(this.messageBuffer);\n    this.messageBuffer = [];\n  }\n\n  get connectionProps() {\n    return Object.assign({\n      sequenceNumber: this.lastSequenceNumber,\n      opsSize: this.opsSize > 0 ? this.opsSize : undefined\n    }, this.connectionManager.connectionProps);\n  }\n  /**\n   * Log error event with a bunch of internal to DeltaManager information about state of op processing\n   * Used to diagnose connectivity issues related to op processing (i.e. cases where for some reason\n   * we stop processing ops that results in no processing join op and thus moving to connected state)\n   * @param event - Event to log.\n   */\n\n\n  logConnectionIssue(event) {\n    var _a;\n\n    assert(this.connectionManager.connected, 0x238\n    /* \"called only in connected state\" */\n    );\n    const pendingSorted = this.pending.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n    this.logger.sendErrorEvent(Object.assign(Object.assign(Object.assign(Object.assign({}, event), {\n      // This directly tells us if fetching ops is in flight, and thus likely the reason of\n      // stalled op processing\n      fetchReason: this.fetchReason,\n      // A bunch of useful sequence numbers to understand if we are holding some ops from processing\n      lastQueuedSequenceNumber: this.lastQueuedSequenceNumber,\n      lastProcessedSequenceNumber: this.lastProcessedSequenceNumber,\n      lastObserved: this.lastObservedSeqNumber\n    }), this.connectionManager.connectionVerboseProps), {\n      pendingOps: this.pending.length,\n      pendingFirst: (_a = pendingSorted[0]) === null || _a === void 0 ? void 0 : _a.sequenceNumber,\n      haveHandler: this.handler !== undefined,\n      inboundLength: this.inbound.length,\n      inboundPaused: this.inbound.paused\n    }));\n  }\n\n  connectHandler(connection) {\n    this.refreshDelayInfo(this.deltaStreamDelayId);\n    const props = this.connectionManager.connectionVerboseProps;\n    props.connectionLastQueuedSequenceNumber = this.lastQueuedSequenceNumber;\n    props.connectionLastObservedSeqNumber = this.lastObservedSeqNumber;\n    const checkpointSequenceNumber = connection.checkpointSequenceNumber;\n    this._checkpointSequenceNumber = checkpointSequenceNumber;\n\n    if (checkpointSequenceNumber !== undefined) {\n      this.updateLatestKnownOpSeqNumber(checkpointSequenceNumber);\n    } // We cancel all ops on lost of connectivity, and rely on DDSes to resubmit them.\n    // Semantics are not well defined for batches (and they are broken right now on disconnects anyway),\n    // but it's safe to assume (until better design is put into place) that batches should not exist\n    // across multiple connections. Right now we assume runtime will not submit any ops in disconnected\n    // state. As requirements change, so should these checks.\n\n\n    assert(this.messageBuffer.length === 0, 0x0e9\n    /* \"messageBuffer is not empty on new connection\" */\n    );\n    this.opsSize = 0;\n    this.emit(\"connect\", connection, checkpointSequenceNumber !== undefined ? this.lastObservedSeqNumber - this.lastSequenceNumber : undefined); // If we got some initial ops, then we know the gap and call above fetched ops to fill it.\n    // Same is true for \"write\" mode even if we have no ops - we will get \"join\" own op very very soon.\n    // However if we are connecting as view-only, then there is no good signal to realize if client is behind.\n    // Thus we have to hit storage to see if any ops are there.\n\n    if (checkpointSequenceNumber !== undefined) {\n      // We know how far we are behind (roughly). If it's non-zero gap, fetch ops right away.\n      if (checkpointSequenceNumber > this.lastQueuedSequenceNumber) {\n        this.fetchMissingDeltas(\"AfterConnection\");\n      } // we do not know the gap, and we will not learn about it if socket is quite - have to ask.\n\n    } else if (connection.mode === \"read\") {\n      this.fetchMissingDeltas(\"AfterReadConnection\");\n    }\n  }\n\n  dispose() {\n    throw new Error(\"Not implemented.\");\n  }\n  /**\n   * Sets the sequence number from which inbound messages should be returned\n   */\n\n\n  attachOpHandler(minSequenceNumber, sequenceNumber, term, handler, prefetchType = \"none\") {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this.initSequenceNumber = sequenceNumber;\n      _this.lastProcessedSequenceNumber = sequenceNumber;\n      _this.baseTerm = term;\n      _this.minSequenceNumber = minSequenceNumber;\n      _this.lastQueuedSequenceNumber = sequenceNumber;\n      _this.lastObservedSeqNumber = sequenceNumber; // We will use same check in other places to make sure all the seq number above are set properly.\n\n      assert(_this.handler === undefined, 0x0e2\n      /* \"DeltaManager already has attached op handler!\" */\n      );\n      _this.handler = handler; // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\n      assert(!!_this.handler, 0x0e3\n      /* \"Newly set op handler is null/undefined!\" */\n      ); // There should be no pending fetch!\n      // This API is called right after attachOpHandler by Container.load().\n      // We might have connection already and it might have called fetchMissingDeltas() from\n      // setupNewSuccessfulConnection. But it should do nothing, because there is no way to fetch ops before\n      // we know snapshot sequence number that is set in attachOpHandler. So all such calls should be noop.\n\n      assert(_this.fetchReason === undefined, 0x268\n      /* \"There can't be pending fetch that early in boot sequence!\" */\n      );\n\n      if (_this.closed) {\n        return;\n      }\n\n      _this._inbound.resume();\n\n      _this._inboundSignal.resume();\n\n      if (prefetchType !== \"none\") {\n        const cacheOnly = prefetchType === \"cached\";\n        yield _this.fetchMissingDeltasCore(`DocumentOpen_${prefetchType}`, cacheOnly); // Keep going with fetching ops from storage once we have all cached ops in.\n        // But do not block load and make this request async / not blocking this api.\n        // Ops processing will start once cached ops are in and and will stop when queue is empty\n        // (which in most cases will happen when we are done processing cached ops)\n\n        if (cacheOnly) {\n          // fire and forget\n          _this.fetchMissingDeltas(\"PostDocumentOpen\");\n        }\n      } // Ensure there is no need to call this.processPendingOps() at the end of boot sequence\n\n\n      assert(_this.fetchReason !== undefined || _this.pending.length === 0, 0x269\n      /* \"pending ops are not dropped\" */\n      );\n    })();\n  }\n\n  connect(args) {\n    var _a;\n\n    const fetchOpsFromStorage = (_a = args.fetchOpsFromStorage) !== null && _a !== void 0 ? _a : true;\n    logIfFalse(this.handler !== undefined || !fetchOpsFromStorage, this.logger, \"CantFetchWithoutBaseline\"); // can't fetch if no baseline\n    // Note: There is race condition here.\n    // We want to issue request to storage as soon as possible, to\n    // reduce latency of becoming current, thus this code here.\n    // But there is no ordering between fetching OPs and connection to delta stream\n    // As result, we might be behind by the time we connect to delta stream\n    // In case of r/w connection, that's not an issue, because we will hear our\n    // own \"join\" message and realize any gap client has in ops.\n    // But for view-only connection, we have no such signal, and with no traffic\n    // on the wire, we might be always behind.\n    // See comment at the end of \"connect\" handler\n\n    if (fetchOpsFromStorage) {\n      this.fetchMissingDeltas(args.reason);\n    }\n\n    this.connectionManager.connect(args.mode);\n  }\n\n  getDeltas(from, // inclusive\n  to, // exclusive\n  fetchReason, callback, cacheOnly) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const docService = _this2.serviceProvider();\n\n      if (docService === undefined) {\n        throw new Error(\"Delta manager is not attached\");\n      }\n\n      if (_this2.deltaStorage === undefined) {\n        _this2.deltaStorage = yield docService.connectToDeltaStorage();\n      }\n\n      let cancelFetch;\n\n      if (to !== undefined) {\n        const lastExpectedOp = to - 1; // make it inclusive!\n        // It is possible that due to asynchrony (including await above), required ops were already\n        // received through delta stream. Validate that before moving forward.\n\n        if (_this2.lastQueuedSequenceNumber >= lastExpectedOp) {\n          _this2.logger.sendPerformanceEvent(Object.assign({\n            reason: fetchReason,\n            eventName: \"ExtraStorageCall\",\n            early: true,\n            from,\n            to\n          }, _this2.connectionManager.connectionVerboseProps));\n\n          return;\n        } // Be prepared for the case where webSocket would receive the ops that we are trying to fill through\n        // storage. Ideally it should never happen (i.e. ops on socket are always ordered, and thus once we\n        // detected gap, this gap can't be filled in later on through websocket).\n        // And in practice that does look like the case. The place where this code gets hit is if we lost\n        // connection and reconnected (likely to another box), and new socket's initial ops contains these ops.\n\n\n        cancelFetch = op => op.sequenceNumber >= lastExpectedOp;\n      } else {\n        // Unbound requests are made to proactively fetch ops, but also get up to date in cases where socket\n        // is silent (and connection is \"read\", thus we might not have any data on how far client is behind).\n        // Once we have any op coming in from socket, we can cancel it as it's not needed any more.\n        // That said, if we have socket connection, make sure we got ops up to checkpointSequenceNumber!\n        cancelFetch = op => op.sequenceNumber >= _this2.lastObservedSeqNumber;\n      }\n\n      const controller = new AbortController();\n      let opsFromFetch = false;\n\n      const opListener = op => {\n        assert(op.sequenceNumber === _this2.lastQueuedSequenceNumber, 0x23a\n        /* \"seq#'s\" */\n        ); // Ops that are coming from this request should not cancel itself.\n        // This is useless for known ranges (to is defined) as it means request is over either way.\n        // And it will cancel unbound request too early, not allowing us to learn where the end of the file is.\n\n        if (!opsFromFetch && cancelFetch(op)) {\n          controller.abort();\n\n          _this2._inbound.off(\"push\", opListener);\n        }\n      };\n\n      try {\n        _this2._inbound.on(\"push\", opListener);\n\n        assert(_this2.closeAbortController.signal.onabort === null, 0x1e8\n        /* \"reentrancy\" */\n        );\n\n        _this2.closeAbortController.signal.onabort = () => controller.abort();\n\n        const stream = _this2.deltaStorage.fetchMessages(from, // inclusive\n        to, // exclusive\n        controller.signal, cacheOnly, fetchReason); // eslint-disable-next-line no-constant-condition\n\n\n        while (true) {\n          const result = yield stream.read();\n\n          if (result.done) {\n            break;\n          }\n\n          try {\n            opsFromFetch = true;\n            callback(result.value);\n          } finally {\n            opsFromFetch = false;\n          }\n        }\n      } finally {\n        _this2.closeAbortController.signal.onabort = null;\n\n        _this2._inbound.off(\"push\", opListener);\n\n        assert(!opsFromFetch, 0x289\n        /* \"logic error\" */\n        );\n      }\n    })();\n  }\n  /**\n   * Closes the connection and clears inbound & outbound queues.\n   */\n\n\n  close(error) {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n    this.connectionManager.dispose(error);\n    this.closeAbortController.abort();\n\n    this._inbound.clear();\n\n    this._inboundSignal.clear(); // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n\n    this._inbound.pause(); // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n\n    this._inboundSignal.pause(); // Drop pending messages - this will ensure catchUp() does not go into infinite loop\n\n\n    this.pending = []; // This needs to be the last thing we do (before removing listeners), as it causes\n    // Container to dispose context and break ability of data stores / runtime to \"hear\"\n    // from delta manager, including notification (above) about readonly state.\n\n    this.emit(\"closed\", error);\n    this.removeAllListeners();\n  }\n\n  refreshDelayInfo(id) {\n    this.throttlingIdSet.delete(id);\n\n    if (this.throttlingIdSet.size === 0) {\n      this.timeTillThrottling = 0;\n    }\n  }\n\n  disconnectHandler(reason) {\n    this.messageBuffer.length = 0;\n    this.emit(\"disconnect\", reason);\n  }\n  /**\n   * Emit info about a delay in service communication on account of throttling.\n   * @param id - Id of the connection that is delayed\n   * @param delayMs - Duration of the delay\n   * @param error - error object indicating the throttling\n   */\n\n\n  emitDelayInfo(id, delayMs, error) {\n    const timeNow = Date.now();\n    this.throttlingIdSet.add(id);\n\n    if (delayMs > 0 && timeNow + delayMs > this.timeTillThrottling) {\n      this.timeTillThrottling = timeNow + delayMs;\n      const throttlingWarning = ThrottlingWarning.wrap(error, delayMs / 1000\n      /* retryAfterSeconds */\n      , this.logger);\n      this.emit(\"throttled\", throttlingWarning);\n    }\n  } // returns parts of message (in string format) that should never change for a given message.\n  // Used for message comparison. It attempts to avoid comparing fields that potentially may differ.\n  // for example, it's not clear if serverMetadata or timestamp property is a property of message or server state.\n  // We only extract the most obvious fields that are sufficient (with high probability) to detect sequence number\n  // reuse.\n  // Also payload goes to telemetry, so no PII, including content!!\n  // Note: It's possible for a duplicate op to be broadcasted and have everything the same except the timestamp.\n\n\n  comparableMessagePayload(m) {\n    return `${m.clientId}-${m.type}-${m.minimumSequenceNumber}-${m.referenceSequenceNumber}-${m.timestamp}`;\n  }\n\n  enqueueMessages(messages, reason, allowGaps = false) {\n    var _a, _b;\n\n    if (this.handler === undefined) {\n      // We did not setup handler yet.\n      // This happens when we connect to web socket faster than we get attributes for container\n      // and thus faster than attachOpHandler() is called\n      // this.lastProcessedSequenceNumber is still zero, so we can't rely on this.fetchMissingDeltas()\n      // to do the right thing.\n      this.pending = this.pending.concat(messages);\n      return;\n    } // Pending ops should never just hang around for nothing.\n    // This invariant will stay true through this function execution,\n    // so there is no need to process pending ops here.\n    // It's responsibility of\n    // - attachOpHandler()\n    // - fetchMissingDeltas() after it's done with querying storage\n\n\n    assert(this.pending.length === 0 || this.fetchReason !== undefined, 0x1e9\n    /* \"Pending ops\" */\n    );\n\n    if (messages.length === 0) {\n      return;\n    }\n\n    const from = messages[0].sequenceNumber;\n    const last = messages[messages.length - 1].sequenceNumber; // Report stats about missing and duplicate ops\n    // This helps better understand why we fetch ops from storage, and thus may delay\n    // getting current / sending ops\n    // It's possible that this batch is already too late - do not bother\n\n    if (last > this.lastQueuedSequenceNumber) {\n      let prev = from - 1;\n      const initialGap = prev - this.lastQueuedSequenceNumber;\n      let firstMissing;\n      let duplicate = 0;\n      let gap = 0; // Count all gaps and duplicates\n\n      for (const message of messages) {\n        if (message.sequenceNumber === prev) {\n          duplicate++;\n        } else if (message.sequenceNumber !== prev + 1) {\n          gap++;\n\n          if (firstMissing === undefined) {\n            firstMissing = prev + 1;\n          }\n        }\n\n        prev = message.sequenceNumber;\n      }\n\n      let eventName; // Report if we found some issues\n\n      if (duplicate !== 0 || gap !== 0 && !allowGaps || initialGap > 0 && this.fetchReason === undefined) {\n        eventName = \"enqueueMessages\"; // Also report if we are fetching ops, and same range comes in, thus making this fetch obsolete.\n      } else if (this.fetchReason !== undefined && this.fetchReason !== reason && from <= this.lastQueuedSequenceNumber + 1 && last > this.lastQueuedSequenceNumber) {\n        eventName = \"enqueueMessagesExtraFetch\";\n      } // Report if there is something to report\n      // Do not report when pending fetch is in progress, as such reporting will not\n      // correctly take into account pending ops.\n\n\n      if (eventName !== undefined) {\n        this.logger.sendPerformanceEvent(Object.assign({\n          eventName,\n          reason,\n          previousReason: this.prevEnqueueMessagesReason,\n          from,\n          to: last + 1,\n          length: messages.length,\n          fetchReason: this.fetchReason,\n          duplicate: duplicate > 0 ? duplicate : undefined,\n          initialGap: initialGap !== 0 ? initialGap : undefined,\n          gap: gap > 0 ? gap : undefined,\n          firstMissing,\n          dmInitialSeqNumber: this.initialSequenceNumber\n        }, this.connectionManager.connectionVerboseProps));\n      }\n    }\n\n    this.updateLatestKnownOpSeqNumber(messages[messages.length - 1].sequenceNumber);\n    const n = (_a = this.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber;\n    assert(n === undefined || n === this.lastQueuedSequenceNumber, 0x0ec\n    /* \"Unexpected value for previously processed message's sequence number\" */\n    );\n\n    for (const message of messages) {\n      // Check that the messages are arriving in the expected order\n      if (message.sequenceNumber <= this.lastQueuedSequenceNumber) {\n        // Validate that we do not have data loss, i.e. sequencing is reset and started again\n        // with numbers that this client already observed before.\n        if (((_b = this.previouslyProcessedMessage) === null || _b === void 0 ? void 0 : _b.sequenceNumber) === message.sequenceNumber) {\n          const message1 = this.comparableMessagePayload(this.previouslyProcessedMessage);\n          const message2 = this.comparableMessagePayload(message);\n\n          if (message1 !== message2) {\n            const error = new NonRetryableError( // This looks like a data corruption but the culprit was that the file was overwritten\n            // in storage.  See PR #5882.\n            // Likely to be an issue with Fluid Services. Content does not match previous client\n            // knowledge about this file. If the file is overwritten for any reason, this error can be\n            // hit. One example is that some clients could be submitting ops to two different service\n            // instances such that the same sequence number is reused for two different ops.\n            // pre-0.58 error message: twoMessagesWithSameSeqNumAndDifferentPayload\n            \"Found two messages with the same sequenceNumber but different payloads. Likely to be a \" + \"service issue\", DriverErrorType.fileOverwrittenInStorage, {\n              clientId: this.connectionManager.clientId,\n              sequenceNumber: message.sequenceNumber,\n              message1,\n              message2,\n              driverVersion: undefined\n            });\n            this.close(error);\n          }\n        }\n      } else if (message.sequenceNumber !== this.lastQueuedSequenceNumber + 1) {\n        this.pending.push(message);\n        this.fetchMissingDeltas(reason, message.sequenceNumber);\n      } else {\n        this.lastQueuedSequenceNumber = message.sequenceNumber;\n        this.previouslyProcessedMessage = message;\n\n        this._inbound.push(message);\n      }\n    } // When / if we report a gap in ops in the future, we want telemetry to correctly reflect source\n    // of prior ops. But if we have some out of order ops (this.pending), then reporting current reason\n    // becomes not accurate, as the gap existed before current batch, so we should just report \"unknown\".\n\n\n    this.prevEnqueueMessagesReason = this.pending.length > 0 ? \"unknown\" : reason;\n  }\n\n  processInboundMessage(message) {\n    const startTime = Date.now();\n    this.lastProcessedMessage = message; // All non-system messages are coming from some client, and should have clientId\n    // System messages may have no clientId (but some do, like propose, noop, summarize)\n\n    assert(message.clientId !== undefined || !isClientMessage(message), 0x0ed\n    /* \"non-system message have to have clientId\" */\n    ); // TODO Remove after SPO picks up the latest build.\n\n    if (typeof message.contents === \"string\" && message.contents !== \"\" && message.type !== MessageType.ClientLeave) {\n      message.contents = JSON.parse(message.contents);\n    }\n\n    this.connectionManager.beforeProcessingIncomingOp(message); // Watch the minimum sequence number and be ready to update as needed\n\n    if (this.minSequenceNumber > message.minimumSequenceNumber) {\n      // pre-0.58 error message: msnMovesBackwards\n      throw new DataCorruptionError(\"Found a lower minimumSequenceNumber (msn) than previously recorded\", Object.assign(Object.assign({}, extractSafePropertiesFromMessage(message)), {\n        clientId: this.connectionManager.clientId\n      }));\n    }\n\n    this.minSequenceNumber = message.minimumSequenceNumber;\n\n    if (message.sequenceNumber !== this.lastProcessedSequenceNumber + 1) {\n      // pre-0.58 error message: nonSequentialSequenceNumber\n      throw new DataCorruptionError(\"Found a non-Sequential sequenceNumber\", Object.assign(Object.assign({}, extractSafePropertiesFromMessage(message)), {\n        clientId: this.connectionManager.clientId\n      }));\n    }\n\n    this.lastProcessedSequenceNumber = message.sequenceNumber; // a bunch of code assumes that this is true\n\n    assert(this.lastProcessedSequenceNumber <= this.lastObservedSeqNumber, 0x267\n    /* \"lastObservedSeqNumber should be updated first\" */\n    ); // Back-compat for older server with no term\n\n    if (message.term === undefined) {\n      message.term = 1;\n    }\n\n    this.baseTerm = message.term;\n\n    if (this.handler === undefined) {\n      throw new Error(\"Attempted to process an inbound message without a handler attached\");\n    }\n\n    this.handler.process(message);\n    const endTime = Date.now(); // Should be last, after changing this.lastProcessedSequenceNumber above, as many callers\n    // test this.lastProcessedSequenceNumber instead of using op.sequenceNumber itself.\n\n    this.emit(\"op\", message, endTime - startTime);\n  }\n  /**\n   * Retrieves the missing deltas between the given sequence numbers\n   */\n\n\n  fetchMissingDeltas(reasonArg, to) {\n    this.fetchMissingDeltasCore(reasonArg, false\n    /* cacheOnly */\n    , to).catch(error => {\n      this.logger.sendErrorEvent({\n        eventName: \"fetchMissingDeltasException\"\n      }, error);\n    });\n  }\n  /**\n  * Retrieves the missing deltas between the given sequence numbers\n  */\n\n\n  fetchMissingDeltasCore(reason, cacheOnly, to) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a; // Exit out early if we're already fetching deltas\n\n\n      if (_this3.fetchReason !== undefined) {\n        return;\n      }\n\n      if (_this3.closed) {\n        _this3.logger.sendTelemetryEvent({\n          eventName: \"fetchMissingDeltasClosedConnection\",\n          reason\n        });\n\n        return;\n      }\n\n      if (_this3.handler === undefined) {\n        // We do not poses yet any information\n        assert(_this3.lastQueuedSequenceNumber === 0, 0x26b\n        /* \"initial state\" */\n        );\n        return;\n      }\n\n      try {\n        let from = _this3.lastQueuedSequenceNumber + 1;\n        const n = (_a = _this3.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber;\n\n        if (n !== undefined) {\n          // If we already processed at least one op, then we have this.previouslyProcessedMessage populated\n          // and can use it to validate that we are operating on same file, i.e. it was not overwritten.\n          // Knowing about this mechanism, we could ask for op we already observed to increase validation.\n          // This is especially useful when coming out of offline mode or loading from\n          // very old cached (by client / driver) snapshot.\n          assert(n === _this3.lastQueuedSequenceNumber, 0x0f2\n          /* \"previouslyProcessedMessage\" */\n          );\n          assert(from > 1, 0x0f3\n          /* \"not positive\" */\n          );\n          from--;\n        }\n\n        const fetchReason = `${reason}_fetch`;\n        _this3.fetchReason = fetchReason;\n        yield _this3.getDeltas(from, to, fetchReason, messages => {\n          _this3.refreshDelayInfo(_this3.deltaStorageDelayId);\n\n          _this3.enqueueMessages(messages, fetchReason);\n        }, cacheOnly);\n      } catch (error) {\n        _this3.logger.sendErrorEvent({\n          eventName: \"GetDeltas_Exception\"\n        }, error);\n\n        _this3.close(normalizeError(error));\n      } finally {\n        _this3.refreshDelayInfo(_this3.deltaStorageDelayId);\n\n        _this3.fetchReason = undefined;\n\n        _this3.processPendingOps(reason);\n      }\n    })();\n  }\n  /**\n   * Sorts pending ops and attempts to apply them\n   */\n\n\n  processPendingOps(reason) {\n    if (this.closed) {\n      return;\n    }\n\n    assert(this.handler !== undefined, 0x26c\n    /* \"handler should be installed\" */\n    );\n    const pendingSorted = this.pending.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n    this.pending = []; // Given that we do not track where these ops came from any more, it's not very\n    // actionably to report gaps in this range.\n\n    this.enqueueMessages(pendingSorted, `${reason}_pending`, true\n    /* allowGaps */\n    ); // Re-entrancy is ignored by fetchMissingDeltas, execution will come here when it's over\n\n    if (this.fetchReason === undefined) {\n      // See issue #7312 for more details\n      // We observe cases where client gets into situation where it is not aware of missing ops\n      // (i.e. client being behind), and as such, does not attempt to fetch them.\n      // In some cases client may not have enough signal (example - \"read\" connection that is silent -\n      // there is no easy way for client to realize it's behind, see a bit of commentary / logic at the\n      // end of setupNewSuccessfulConnection). In other cases it should be able to learn that info (\"write\"\n      // connection, learn by receiving its own join op), but data suggest it does not happen.\n      // In 50% of these cases we do know we are behind through checkpointSequenceNumber on connection object\n      // and thus can leverage that to trigger recovery. But this is not going to solve all the problems\n      // (the other 50%), and thus these errors below should be looked at even if code below results in\n      // recovery.\n      if (this.lastQueuedSequenceNumber < this.lastObservedSeqNumber) {\n        this.fetchMissingDeltas(\"OpsBehind\");\n      }\n    }\n  }\n\n  updateLatestKnownOpSeqNumber(seq) {\n    if (this.lastObservedSeqNumber < seq) {\n      this.lastObservedSeqNumber = seq;\n    }\n  }\n\n} //# sourceMappingURL=deltaManager.js.map","map":null,"metadata":{},"sourceType":"module"}