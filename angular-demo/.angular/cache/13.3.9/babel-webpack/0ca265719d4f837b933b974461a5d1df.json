{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as base64js from \"base64-js\";\nimport { IsoBuffer } from \"./bufferBrowser\";\n\nfunction digestBuffer(_x, _x2) {\n  return _digestBuffer.apply(this, arguments);\n}\n\nfunction _digestBuffer() {\n  _digestBuffer = _asyncToGenerator(function* (file, algorithm) {\n    const hash = yield crypto.subtle.digest(algorithm, file);\n    return new Uint8Array(hash);\n  });\n  return _digestBuffer.apply(this, arguments);\n}\n\nfunction encodeDigest(hashArray, encoding) {\n  // eslint-disable-next-line default-case\n  switch (encoding) {\n    case \"hex\":\n      {\n        const hashHex = Array.prototype.map.call(hashArray, byte => {\n          return byte.toString(16).padStart(2, \"0\");\n        }).join(\"\");\n        return hashHex;\n      }\n\n    case \"base64\":\n      {\n        return base64js.fromByteArray(hashArray);\n      }\n  }\n}\n/**\n * Hash a file. Consistent within a session, but should not be persisted and\n * is not consistent with git.\n * If called under an insecure context for a browser, this will fallback to\n * using the node implementation.\n *\n * @param file - The contents of the file in a buffer\n * @param algorithm - The hash algorithm to use, artificially constrained by what is used internally\n * @param hashEncoding - The encoding of the returned hash, also artificially constrained\n * @returns The hash of the content of the buffer\n */\n\n\nexport function hashFile(_x3) {\n  return _hashFile.apply(this, arguments);\n}\n/**\n * Create a github hash (Github hashes the string with blob and size)\n * Must be called under secure context for browsers\n *\n * @param file - The contents of the file in a buffer\n * @returns The sha1 hash of the content of the buffer with the `blob` prefix and size\n */\n\nfunction _hashFile() {\n  _hashFile = _asyncToGenerator(function* (file, algorithm = \"SHA-1\", hashEncoding = \"hex\") {\n    // Handle insecure contexts (e.g. running with local services)\n    // by deferring to Node version, which uses a hash polyfill\n    // When packed, this chunk will show as \"FluidFramework-HashFallback\" separately\n    // from the main chunk and will be of non-trivial size.  It will not be served\n    // under normal circumstances.\n    if (crypto.subtle === undefined) {\n      return import(\n      /* webpackChunkName: \"FluidFramework-HashFallback\" */\n      \"./hashFileNode\").then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (m) {\n          return m.hashFile(file, algorithm, hashEncoding);\n        });\n\n        return function (_x5) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    } // This is split up this way to facilitate testing (see the test for more info)\n\n\n    const hashArray = yield digestBuffer(file, algorithm);\n    return encodeDigest(hashArray, hashEncoding);\n  });\n  return _hashFile.apply(this, arguments);\n}\n\nexport function gitHashFile(_x4) {\n  return _gitHashFile.apply(this, arguments);\n} //# sourceMappingURL=hashFileBrowser.js.map\n\nfunction _gitHashFile() {\n  _gitHashFile = _asyncToGenerator(function* (file) {\n    const size = file.byteLength;\n    const filePrefix = `blob ${size.toString()}${String.fromCharCode(0)}`;\n    const hashBuffer = IsoBuffer.from(filePrefix + file.toString()); // hashFile uses sha1; if that changes this will need to change too\n\n    return hashFile(hashBuffer);\n  });\n  return _gitHashFile.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}