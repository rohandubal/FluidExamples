{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { bufferToString, fromBase64ToUtf8, IsoBuffer, Uint8ArrayToString, unreachableCase } from \"@fluidframework/common-utils\";\nimport { AttachmentTreeEntry, BlobTreeEntry, TreeTreeEntry } from \"@fluidframework/protocol-base\";\nimport { SummaryType, TreeEntry } from \"@fluidframework/protocol-definitions\";\n/**\n * Combines summary stats by adding their totals together.\n * Returns empty stats if called without args.\n * @param stats - stats to merge\n */\n\nexport function mergeStats(...stats) {\n  const results = {\n    treeNodeCount: 0,\n    blobNodeCount: 0,\n    handleNodeCount: 0,\n    totalBlobSize: 0,\n    unreferencedBlobSize: 0\n  };\n\n  for (const stat of stats) {\n    results.treeNodeCount += stat.treeNodeCount;\n    results.blobNodeCount += stat.blobNodeCount;\n    results.handleNodeCount += stat.handleNodeCount;\n    results.totalBlobSize += stat.totalBlobSize;\n    results.unreferencedBlobSize += stat.unreferencedBlobSize;\n  }\n\n  return results;\n}\nexport function utf8ByteLength(str) {\n  // returns the byte length of an utf8 string\n  let s = str.length;\n\n  for (let i = str.length - 1; i >= 0; i--) {\n    const code = str.charCodeAt(i);\n\n    if (code > 0x7f && code <= 0x7ff) {\n      s++;\n    } else if (code > 0x7ff && code <= 0xffff) {\n      s += 2;\n    }\n\n    if (code >= 0xDC00 && code <= 0xDFFF) {\n      i--; // trail surrogate\n    }\n  }\n\n  return s;\n}\nexport function getBlobSize(content) {\n  if (typeof content === \"string\") {\n    return utf8ByteLength(content);\n  } else {\n    return content.byteLength;\n  }\n}\n\nfunction calculateStatsCore(summaryObject, stats) {\n  switch (summaryObject.type) {\n    case SummaryType.Tree:\n      {\n        stats.treeNodeCount++;\n\n        for (const value of Object.values(summaryObject.tree)) {\n          calculateStatsCore(value, stats);\n        }\n\n        return;\n      }\n\n    case SummaryType.Handle:\n      {\n        stats.handleNodeCount++;\n        return;\n      }\n\n    case SummaryType.Blob:\n      {\n        stats.blobNodeCount++;\n        stats.totalBlobSize += getBlobSize(summaryObject.content);\n        return;\n      }\n\n    default:\n      return;\n  }\n}\n\nexport function calculateStats(summary) {\n  const stats = mergeStats();\n  calculateStatsCore(summary, stats);\n  return stats;\n}\nexport function addBlobToSummary(summary, key, content) {\n  const blob = {\n    type: SummaryType.Blob,\n    content\n  };\n  summary.summary.tree[key] = blob;\n  summary.stats.blobNodeCount++;\n  summary.stats.totalBlobSize += getBlobSize(content);\n}\nexport function addTreeToSummary(summary, key, summarizeResult) {\n  summary.summary.tree[key] = summarizeResult.summary;\n  summary.stats = mergeStats(summary.stats, summarizeResult.stats);\n}\nexport function addSummarizeResultToSummary(summary, key, summarizeResult) {\n  summary.summary.tree[key] = summarizeResult.summary;\n  summary.stats = mergeStats(summary.stats, summarizeResult.stats);\n}\nexport class SummaryTreeBuilder {\n  constructor() {\n    this.attachmentCounter = 0;\n    this.summaryTree = {};\n    this.summaryStats = mergeStats();\n    this.summaryStats.treeNodeCount++;\n  }\n\n  get summary() {\n    return {\n      type: SummaryType.Tree,\n      tree: Object.assign({}, this.summaryTree)\n    };\n  }\n\n  get stats() {\n    return Object.assign({}, this.summaryStats);\n  }\n\n  addBlob(key, content) {\n    // Prevent cloning by directly referencing underlying private properties\n    addBlobToSummary({\n      summary: {\n        type: SummaryType.Tree,\n        tree: this.summaryTree\n      },\n      stats: this.summaryStats\n    }, key, content);\n  }\n\n  addHandle(key, handleType, handle) {\n    this.summaryTree[key] = {\n      type: SummaryType.Handle,\n      handleType,\n      handle\n    };\n    this.summaryStats.handleNodeCount++;\n  }\n\n  addWithStats(key, summarizeResult) {\n    this.summaryTree[key] = summarizeResult.summary;\n    this.summaryStats = mergeStats(this.summaryStats, summarizeResult.stats);\n  }\n\n  addAttachment(id) {\n    this.summaryTree[this.attachmentCounter++] = {\n      id,\n      type: SummaryType.Attachment\n    };\n  }\n\n  getSummaryTree() {\n    return {\n      summary: this.summary,\n      stats: this.stats\n    };\n  }\n\n}\n/**\n * Converts snapshot ITree to ISummaryTree format and tracks stats.\n * @param snapshot - snapshot in ITree format\n * @param fullTree - true to never use handles, even if id is specified\n */\n\nexport function convertToSummaryTreeWithStats(snapshot, fullTree = false) {\n  const builder = new SummaryTreeBuilder();\n\n  for (const entry of snapshot.entries) {\n    switch (entry.type) {\n      case TreeEntry.Blob:\n        {\n          const blob = entry.value;\n          let content;\n\n          if (blob.encoding === \"base64\") {\n            content = IsoBuffer.from(blob.contents, \"base64\");\n          } else {\n            content = blob.contents;\n          }\n\n          builder.addBlob(entry.path, content);\n          break;\n        }\n\n      case TreeEntry.Tree:\n        {\n          const subtree = convertToSummaryTree(entry.value, fullTree);\n          builder.addWithStats(entry.path, subtree);\n          break;\n        }\n\n      case TreeEntry.Attachment:\n        {\n          const id = entry.value.id;\n          builder.addAttachment(id);\n          break;\n        }\n\n      default:\n        throw new Error(\"Unexpected TreeEntry type\");\n    }\n  }\n\n  const summaryTree = builder.getSummaryTree();\n  summaryTree.summary.unreferenced = snapshot.unreferenced;\n  return summaryTree;\n}\n/**\n * Converts snapshot ITree to ISummaryTree format and tracks stats.\n * @param snapshot - snapshot in ITree format\n * @param fullTree - true to never use handles, even if id is specified\n */\n\nexport function convertToSummaryTree(snapshot, fullTree = false) {\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n  if (snapshot.id && !fullTree) {\n    const stats = mergeStats();\n    stats.handleNodeCount++;\n    return {\n      summary: {\n        handle: snapshot.id,\n        handleType: SummaryType.Tree,\n        type: SummaryType.Handle\n      },\n      stats\n    };\n  } else {\n    return convertToSummaryTreeWithStats(snapshot, fullTree);\n  }\n}\n/**\n * Converts ISnapshotTree to ISummaryTree format and tracks stats. This snapshot tree was\n * was taken by serialize api in detached container.\n * @param snapshot - snapshot in ISnapshotTree format\n */\n\nexport function convertSnapshotTreeToSummaryTree(snapshot) {\n  const builder = new SummaryTreeBuilder();\n\n  for (const [path, id] of Object.entries(snapshot.blobs)) {\n    let decoded;\n\n    if (snapshot.blobsContents !== undefined) {\n      const content = snapshot.blobsContents[id];\n\n      if (content !== undefined) {\n        decoded = bufferToString(content, \"utf-8\");\n      } // 0.44 back-compat We still put contents in same blob for back-compat so need to add blob\n      // only for blobPath -> blobId mapping and not for blobId -> blob value contents.\n\n    } else if (snapshot.blobs[id] !== undefined) {\n      decoded = fromBase64ToUtf8(snapshot.blobs[id]);\n    }\n\n    if (decoded !== undefined) {\n      builder.addBlob(path, decoded);\n    }\n  }\n\n  for (const [key, tree] of Object.entries(snapshot.trees)) {\n    const subtree = convertSnapshotTreeToSummaryTree(tree);\n    builder.addWithStats(key, subtree);\n  }\n\n  const summaryTree = builder.getSummaryTree();\n  summaryTree.summary.unreferenced = snapshot.unreferenced;\n  return summaryTree;\n}\n/**\n * Converts ISummaryTree to ITree format. This is needed for back-compat while we get rid of snapshot.\n * @param summaryTree - summary tree in ISummaryTree format\n */\n\nexport function convertSummaryTreeToITree(summaryTree) {\n  const entries = [];\n\n  for (const [key, value] of Object.entries(summaryTree.tree)) {\n    switch (value.type) {\n      case SummaryType.Blob:\n        {\n          let parsedContent;\n          let encoding = \"utf-8\";\n\n          if (typeof value.content === \"string\") {\n            parsedContent = value.content;\n          } else {\n            parsedContent = Uint8ArrayToString(value.content, \"base64\");\n            encoding = \"base64\";\n          }\n\n          entries.push(new BlobTreeEntry(key, parsedContent, encoding));\n          break;\n        }\n\n      case SummaryType.Tree:\n        {\n          entries.push(new TreeTreeEntry(key, convertSummaryTreeToITree(value)));\n          break;\n        }\n\n      case SummaryType.Attachment:\n        {\n          entries.push(new AttachmentTreeEntry(key, value.id));\n          break;\n        }\n\n      case SummaryType.Handle:\n        {\n          throw new Error(\"Should not have Handle type in summary tree\");\n        }\n\n      default:\n        unreachableCase(value, \"Unexpected summary tree type\");\n    }\n  }\n\n  return {\n    entries,\n    unreferenced: summaryTree.unreferenced\n  };\n}\nexport class TelemetryContext {\n  constructor() {\n    this.telemetry = new Map();\n  }\n  /**\n   * {@inheritDoc @fluidframework/runtime-definitions#ITelemetryContext.set}\n   */\n\n\n  set(prefix, property, value) {\n    this.telemetry.set(`${prefix}${property}`, value);\n  }\n  /**\n   * {@inheritDoc @fluidframework/runtime-definitions#ITelemetryContext.get}\n   */\n\n\n  get(prefix, property) {\n    return this.telemetry.get(`${prefix}${property}`);\n  }\n  /**\n   * {@inheritDoc @fluidframework/runtime-definitions#ITelemetryContext.serialize}\n   */\n\n\n  serialize() {\n    const jsonObject = {};\n    this.telemetry.forEach((value, key) => {\n      jsonObject[key] = value;\n    });\n    return JSON.stringify(jsonObject);\n  }\n\n} //# sourceMappingURL=summaryUtils.js.map","map":null,"metadata":{},"sourceType":"module"}