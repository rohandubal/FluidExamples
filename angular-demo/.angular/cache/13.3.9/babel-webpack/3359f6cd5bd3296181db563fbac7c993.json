{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, performance, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport Deque from \"double-ended-queue\";\nexport class DeltaQueue extends TypedEventEmitter {\n  /**\n   * @param worker - A callback to process a delta.\n   * @param logger - For logging telemetry.\n   */\n  constructor(worker) {\n    super();\n    this.worker = worker;\n    this.isDisposed = false;\n    this.q = new Deque();\n    /**\n     * Tracks the number of pause requests for the queue\n     * The DeltaQueue is create initially paused.\n     */\n\n    this.pauseCount = 1;\n  }\n\n  get disposed() {\n    return this.isDisposed;\n  }\n  /**\n   * @returns True if the queue is paused, false if not.\n   */\n\n\n  get paused() {\n    return this.pauseCount !== 0;\n  }\n\n  get length() {\n    return this.q.length;\n  }\n\n  get idle() {\n    return this.processingPromise === undefined && this.q.length === 0;\n  }\n\n  waitTillProcessingDone() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      return (_a = _this.processingPromise) !== null && _a !== void 0 ? _a : {\n        count: 0,\n        duration: 0\n      };\n    })();\n  }\n\n  dispose() {\n    throw new Error(\"Not implemented.\");\n    this.isDisposed = true;\n  }\n\n  clear() {\n    this.q.clear();\n  }\n\n  peek() {\n    return this.q.peekFront();\n  }\n\n  toArray() {\n    return this.q.toArray();\n  }\n\n  push(task) {\n    try {\n      this.q.push(task);\n      this.emit(\"push\", task);\n      this.ensureProcessing();\n    } catch (error) {\n      this.emit(\"error\", error);\n    }\n  }\n\n  pause() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2.pauseCount++; // If called from within the processing loop, we are in the middle of processing an op. Return a promise\n      // that will resolve when processing has actually stopped.\n\n      yield _this2.waitTillProcessingDone();\n    })();\n  }\n\n  resume() {\n    assert(this.pauseCount > 0, 0x0f4\n    /* \"Nonzero pause-count on resume()\" */\n    );\n    this.pauseCount--;\n    this.ensureProcessing();\n  }\n  /**\n   * There are several actions that may need to kick off delta processing, so we want to guard against\n   * accidental reentrancy. ensureProcessing can be called safely to start the processing loop if it is\n   * not already started.\n   */\n\n\n  ensureProcessing() {\n    if (this.anythingToProcess() && this.processingPromise === undefined) {\n      // Use a resolved promise to start the processing on a separate stack.\n      this.processingPromise = Promise.resolve().then(() => {\n        assert(this.processingPromise !== undefined, \"reentrancy?\");\n        const result = this.processDeltas();\n        assert(this.processingPromise !== undefined, \"reentrancy?\"); // WARNING: Do not move next line to .finally() clause!\n        // It runs async and creates a race condition where incoming ensureProcessing() call observes\n        // from previous run while previous run is over (but finally clause was not scheduled yet)\n\n        this.processingPromise = undefined;\n        return result;\n      }).catch(error => {\n        this.error = error;\n        this.processingPromise = undefined;\n        this.emit(\"error\", error);\n        return {\n          count: 0,\n          duration: 0\n        };\n      });\n      assert(this.processingPromise !== undefined, \"processDeltas() should run async\");\n    }\n  }\n\n  anythingToProcess() {\n    return this.q.length !== 0 && !this.paused && this.error === undefined;\n  }\n  /**\n   * Executes the delta processing loop until a stop condition is reached.\n   */\n\n\n  processDeltas() {\n    const start = performance.now();\n    let count = 0; // For grouping to work we must process all local messages immediately and in the single turn.\n    // So loop over them until no messages to process, we have become paused, or hit an error.\n\n    while (this.anythingToProcess()) {\n      // Get the next message in the queue\n      const next = this.q.shift();\n      count++; // Process the message.\n      // We know next is defined since we did a length check just prior to shifting.\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      this.worker(next);\n      this.emit(\"op\", next);\n    }\n\n    const duration = performance.now() - start;\n\n    if (this.q.length === 0) {\n      this.emit(\"idle\", count, duration);\n    }\n\n    return {\n      count,\n      duration\n    };\n  }\n\n} //# sourceMappingURL=deltaQueue.js.map","map":null,"metadata":{},"sourceType":"module"}