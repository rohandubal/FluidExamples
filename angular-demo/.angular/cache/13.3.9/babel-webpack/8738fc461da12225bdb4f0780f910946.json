{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, Deferred, Timer } from \"@fluidframework/common-utils\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { PerformanceEvent, LoggingError, ChildLogger } from \"@fluidframework/telemetry-utils\";\nimport { getRetryDelaySecondsFromError } from \"@fluidframework/driver-utils\";\nimport { DriverErrorType } from \"@fluidframework/driver-definitions\";\n/** Helper function to wait for a promise or PromiseTimer to elapse. */\n\nexport function raceTimer(_x, _x2, _x3) {\n  return _raceTimer.apply(this, arguments);\n} // Send some telemetry if generate summary takes too long\n\nfunction _raceTimer() {\n  _raceTimer = _asyncToGenerator(function* (promise, timer, cancellationToken) {\n    const promises = [promise.then(value => ({\n      result: \"done\",\n      value\n    })), timer.then(({\n      timerResult: result\n    }) => ({\n      result\n    }))];\n\n    if (cancellationToken !== undefined) {\n      promises.push(cancellationToken.waitCancelled.then(() => ({\n        result: \"cancelled\"\n      })));\n    }\n\n    return Promise.race(promises);\n  });\n  return _raceTimer.apply(this, arguments);\n}\n\nconst maxSummarizeTimeoutTime = 20000; // 20 sec\n\nconst maxSummarizeTimeoutCount = 5; // Double and resend 5 times\n\nconst summarizeErrors = {\n  /**\n   * Error encountered while generating the summary tree, uploading\n   * it to storage, or submitting the op. It could be a result of\n   * the client becoming disconnected while generating or an actual error.\n   */\n  submitSummaryFailure: \"Error while generating, uploading, or submitting summary\",\n\n  /**\n   * The summaryAckWaitTimeout time has elapsed before receiving the summarize op\n   * sent by this summarize attempt. It is expected to be broadcast quickly.\n   */\n  summaryOpWaitTimeout: \"Timeout while waiting for summarize op broadcast\",\n\n  /**\n   * The summaryAckWaitTimeout time has elapsed before receiving either a\n   * summaryAck or summaryNack op from the server in response to this\n   * summarize attempt. It is expected that the server should respond.\n   */\n  summaryAckWaitTimeout: \"Timeout while waiting for summaryAck/summaryNack op\",\n\n  /**\n   * The server responded with a summaryNack op, thus rejecting this\n   * summarize attempt.\n   */\n  summaryNack: \"Server rejected summary via summaryNack op\",\n  disconnect: \"Summary cancelled due to summarizer or main client disconnect\"\n};\nexport class SummarizeResultBuilder {\n  constructor() {\n    this.summarySubmitted = new Deferred();\n    this.summaryOpBroadcasted = new Deferred();\n    this.receivedSummaryAckOrNack = new Deferred();\n  }\n\n  fail(message, error, nackSummaryResult, retryAfterSeconds) {\n    assert(!this.receivedSummaryAckOrNack.isCompleted, 0x25e\n    /* \"no reason to call fail if all promises have been completed\" */\n    );\n    const result = {\n      success: false,\n      message,\n      data: undefined,\n      error,\n      retryAfterSeconds\n    };\n    this.summarySubmitted.resolve(result);\n    this.summaryOpBroadcasted.resolve(result);\n    this.receivedSummaryAckOrNack.resolve(Object.assign(Object.assign({}, result), {\n      data: nackSummaryResult\n    }));\n  }\n\n  build() {\n    return {\n      summarySubmitted: this.summarySubmitted.promise,\n      summaryOpBroadcasted: this.summaryOpBroadcasted.promise,\n      receivedSummaryAckOrNack: this.receivedSummaryAckOrNack.promise\n    };\n  }\n\n}\n/**\n * This class generates and tracks a summary attempt.\n */\n\nexport class SummaryGenerator {\n  constructor(pendingAckTimer, heuristicData, submitSummaryCallback, raiseSummarizingError, successfulSummaryCallback, summaryWatcher, logger) {\n    this.pendingAckTimer = pendingAckTimer;\n    this.heuristicData = heuristicData;\n    this.submitSummaryCallback = submitSummaryCallback;\n    this.raiseSummarizingError = raiseSummarizingError;\n    this.successfulSummaryCallback = successfulSummaryCallback;\n    this.summaryWatcher = summaryWatcher;\n    this.logger = logger;\n    this.summarizeTimer = new Timer(maxSummarizeTimeoutTime, () => this.summarizeTimerHandler(maxSummarizeTimeoutTime, 1));\n  }\n  /**\n   * Generates summary and listens for broadcast and ack/nack.\n   * Returns true for ack, false for nack, and undefined for failure or timeout.\n   * @param reason - reason for summarizing\n   * @param options - refreshLatestAck to fetch summary ack info from server,\n   * fullTree to generate tree without any summary handles even if unchanged\n   */\n\n\n  summarize(summarizeProps, options, cancellationToken, resultsBuilder = new SummarizeResultBuilder()) {\n    this.summarizeCore(summarizeProps, options, resultsBuilder, cancellationToken).catch(error => {\n      const message = \"UnexpectedSummarizeError\";\n      this.logger.sendErrorEvent(Object.assign({\n        eventName: message\n      }, summarizeProps), error);\n      resultsBuilder.fail(message, error);\n    });\n    return resultsBuilder.build();\n  }\n\n  summarizeCore(summarizeProps, options, resultsBuilder, cancellationToken) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        refreshLatestAck,\n        fullTree\n      } = options;\n      const logger = ChildLogger.create(_this.logger, undefined, {\n        all: summarizeProps\n      }); // Note: timeSinceLastAttempt and timeSinceLastSummary for the\n      // first summary are basically the time since the summarizer was loaded.\n\n      const timeSinceLastAttempt = Date.now() - _this.heuristicData.lastAttempt.summaryTime;\n\n      const timeSinceLastSummary = Date.now() - _this.heuristicData.lastSuccessfulSummary.summaryTime;\n\n      let summarizeTelemetryProps = {\n        fullTree,\n        timeSinceLastAttempt,\n        timeSinceLastSummary\n      };\n      const summarizeEvent = PerformanceEvent.start(logger, Object.assign({\n        eventName: \"Summarize\",\n        refreshLatestAck\n      }, summarizeTelemetryProps)); // Helper functions to report failures and return.\n\n      const getFailMessage = errorCode => `${errorCode}: ${summarizeErrors[errorCode]}`;\n\n      const fail = (errorCode, error, properties, nackSummaryResult) => {\n        _this.raiseSummarizingError(summarizeErrors[errorCode]); // UploadSummary may fail with 429 and retryAfter - respect that\n        // Summary Nack also can have retryAfter, it's parsed below and comes as a property.\n\n\n        const retryAfterSeconds = getRetryDelaySecondsFromError(error); // Report any failure as an error unless it was due to cancellation (like \"disconnected\" error)\n        // If failure happened on upload, we may not yet realized that socket disconnected, so check\n        // offlineError too.\n\n        const category = cancellationToken.cancelled || (error === null || error === void 0 ? void 0 : error.errorType) === DriverErrorType.offlineError ? \"generic\" : \"error\";\n        summarizeEvent.cancel(Object.assign(Object.assign({}, properties), {\n          reason: errorCode,\n          category,\n          retryAfterSeconds\n        }), error);\n        resultsBuilder.fail(getFailMessage(errorCode), error, nackSummaryResult, retryAfterSeconds);\n      }; // Wait to generate and send summary\n\n\n      _this.summarizeTimer.start(); // Use record type to prevent unexpected value types\n\n\n      let summaryData;\n\n      try {\n        summaryData = yield _this.submitSummaryCallback({\n          fullTree,\n          refreshLatestAck,\n          summaryLogger: logger,\n          cancellationToken\n        }); // Cumulatively add telemetry properties based on how far generateSummary went.\n\n        const referenceSequenceNumber = summaryData.referenceSequenceNumber;\n        const opsSinceLastSummary = referenceSequenceNumber - _this.heuristicData.lastSuccessfulSummary.refSequenceNumber;\n        summarizeTelemetryProps = Object.assign(Object.assign({}, summarizeTelemetryProps), {\n          referenceSequenceNumber,\n          minimumSequenceNumber: summaryData.minimumSequenceNumber,\n          opsSinceLastAttempt: referenceSequenceNumber - _this.heuristicData.lastAttempt.refSequenceNumber,\n          opsSinceLastSummary\n        });\n\n        if (summaryData.stage !== \"base\") {\n          summarizeTelemetryProps = Object.assign(Object.assign(Object.assign({}, summarizeTelemetryProps), summaryData.summaryStats), {\n            generateDuration: summaryData.generateDuration\n          });\n\n          if (summaryData.stage !== \"generate\") {\n            summarizeTelemetryProps = Object.assign(Object.assign({}, summarizeTelemetryProps), {\n              handle: summaryData.handle,\n              uploadDuration: summaryData.uploadDuration\n            });\n\n            if (summaryData.stage !== \"upload\") {\n              summarizeTelemetryProps = Object.assign(Object.assign({}, summarizeTelemetryProps), {\n                clientSequenceNumber: summaryData.clientSequenceNumber\n              });\n            }\n          }\n        }\n\n        if (summaryData.stage !== \"submit\") {\n          return fail(\"submitSummaryFailure\", summaryData.error, summarizeTelemetryProps);\n        }\n        /**\n         * With incremental summaries, if the full tree was not summarized, only data stores that changed should\n         * be summarized. A data store is considered changed if either or both of the following is true:\n         * - It has received an op.\n         * - Its reference state changed, i.e., it went from referenced to unreferenced or vice-versa.\n         *\n         * In the extreme case, every op can be for a different data store and each op can result in the reference\n         * state change of multiple data stores. So, the total number of data stores that are summarized should not\n         * exceed the number of ops since last summary + number of data store whose reference state changed.\n         */\n\n\n        if (!fullTree && !summaryData.forcedFullTree) {\n          const {\n            summarizedDataStoreCount,\n            gcStateUpdatedDataStoreCount = 0\n          } = summaryData.summaryStats;\n\n          if (summarizedDataStoreCount > gcStateUpdatedDataStoreCount + opsSinceLastSummary) {\n            logger.sendErrorEvent({\n              eventName: \"IncrementalSummaryViolation\",\n              summarizedDataStoreCount,\n              gcStateUpdatedDataStoreCount,\n              opsSinceLastSummary\n            });\n          }\n        } // Log event here on summary success only, as Summarize_cancel duplicates failure logging.\n\n\n        summarizeEvent.reportEvent(\"generate\", Object.assign({}, summarizeTelemetryProps));\n        resultsBuilder.summarySubmitted.resolve({\n          success: true,\n          data: summaryData\n        });\n      } catch (error) {\n        return fail(\"submitSummaryFailure\", error);\n      } finally {\n        _this.heuristicData.recordAttempt(summaryData === null || summaryData === void 0 ? void 0 : summaryData.referenceSequenceNumber);\n\n        _this.summarizeTimer.clear();\n      }\n\n      try {\n        const pendingTimeoutP = _this.pendingAckTimer.start();\n\n        const summary = _this.summaryWatcher.watchSummary(summaryData.clientSequenceNumber); // Wait for broadcast\n\n\n        const waitBroadcastResult = yield raceTimer(summary.waitBroadcast(), pendingTimeoutP, cancellationToken);\n\n        if (waitBroadcastResult.result === \"cancelled\") {\n          return fail(\"disconnect\");\n        }\n\n        if (waitBroadcastResult.result !== \"done\") {\n          return fail(\"summaryOpWaitTimeout\");\n        }\n\n        const summarizeOp = waitBroadcastResult.value;\n\n        const broadcastDuration = Date.now() - _this.heuristicData.lastAttempt.summaryTime;\n\n        resultsBuilder.summaryOpBroadcasted.resolve({\n          success: true,\n          data: {\n            summarizeOp,\n            broadcastDuration\n          }\n        });\n        _this.heuristicData.lastAttempt.summarySequenceNumber = summarizeOp.sequenceNumber;\n        logger.sendTelemetryEvent({\n          eventName: \"Summarize_Op\",\n          duration: broadcastDuration,\n          referenceSequenceNumber: summarizeOp.referenceSequenceNumber,\n          summarySequenceNumber: summarizeOp.sequenceNumber,\n          handle: summarizeOp.contents.handle\n        }); // Wait for ack/nack\n\n        const waitAckNackResult = yield raceTimer(summary.waitAckNack(), pendingTimeoutP, cancellationToken);\n\n        if (waitAckNackResult.result === \"cancelled\") {\n          return fail(\"disconnect\");\n        }\n\n        if (waitAckNackResult.result !== \"done\") {\n          return fail(\"summaryAckWaitTimeout\");\n        }\n\n        const ackNackOp = waitAckNackResult.value;\n\n        _this.pendingAckTimer.clear(); // Update for success/failure\n\n\n        const ackNackDuration = Date.now() - _this.heuristicData.lastAttempt.summaryTime; // adding new properties\n\n\n        summarizeTelemetryProps = Object.assign({\n          ackWaitDuration: ackNackDuration,\n          ackNackSequenceNumber: ackNackOp.sequenceNumber,\n          summarySequenceNumber: ackNackOp.contents.summaryProposal.summarySequenceNumber\n        }, summarizeTelemetryProps);\n\n        if (ackNackOp.type === MessageType.SummaryAck) {\n          _this.heuristicData.markLastAttemptAsSuccessful();\n\n          _this.successfulSummaryCallback();\n\n          summarizeEvent.end(Object.assign(Object.assign({}, summarizeTelemetryProps), {\n            handle: ackNackOp.contents.handle\n          }));\n          resultsBuilder.receivedSummaryAckOrNack.resolve({\n            success: true,\n            data: {\n              summaryAckOp: ackNackOp,\n              ackNackDuration\n            }\n          });\n        } else {\n          // Check for retryDelay in summaryNack response.\n          assert(ackNackOp.type === MessageType.SummaryNack, 0x274\n          /* \"type check\" */\n          );\n          const summaryNack = ackNackOp.contents;\n          const message = summaryNack === null || summaryNack === void 0 ? void 0 : summaryNack.message;\n          const retryAfterSeconds = summaryNack === null || summaryNack === void 0 ? void 0 : summaryNack.retryAfter; // pre-0.58 error message prefix: summaryNack\n\n          const error = new LoggingError(`Received summaryNack: ${message}`, {\n            retryAfterSeconds\n          });\n          assert(getRetryDelaySecondsFromError(error) === retryAfterSeconds, 0x25f\n          /* \"retryAfterSeconds\" */\n          ); // This will only set resultsBuilder.receivedSummaryAckOrNack, as other promises are already set.\n\n          return fail(\"summaryNack\", error, Object.assign(Object.assign({}, summarizeTelemetryProps), {\n            nackRetryAfter: retryAfterSeconds\n          }), {\n            summaryNackOp: ackNackOp,\n            ackNackDuration\n          });\n        }\n      } finally {\n        _this.pendingAckTimer.clear();\n      }\n    })();\n  }\n\n  summarizeTimerHandler(time, count) {\n    this.logger.sendPerformanceEvent({\n      eventName: \"SummarizeTimeout\",\n      timeoutTime: time,\n      timeoutCount: count\n    });\n\n    if (count < maxSummarizeTimeoutCount) {\n      // Double and start a new timer\n      const nextTime = time * 2;\n      this.summarizeTimer.start(nextTime, () => this.summarizeTimerHandler(nextTime, count + 1));\n    }\n  }\n\n  dispose() {\n    this.summarizeTimer.clear();\n  }\n\n} //# sourceMappingURL=summaryGenerator.js.map","map":null,"metadata":{},"sourceType":"module"}