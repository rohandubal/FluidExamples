{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { EventEmitter } from \"events\";\nimport { Deferred } from \"@fluidframework/common-utils\";\nimport { LoaderHeader } from \"@fluidframework/container-definitions\";\nimport { UsageError } from \"@fluidframework/container-utils\";\nimport { DriverErrorType, DriverHeader } from \"@fluidframework/driver-definitions\";\nimport { requestFluidObject } from \"@fluidframework/runtime-utils\";\nimport { ChildLogger, isFluidError, LoggingError, wrapErrorAndLog } from \"@fluidframework/telemetry-utils\";\nimport { summarizerClientType } from \"./summarizerClientElection\";\nimport { SummarizerHandle } from \"./summarizerHandle\";\nimport { RunningSummarizer } from \"./runningSummarizer\";\nimport { SummarizeHeuristicData } from \"./summarizerHeuristics\";\nimport { SummarizeResultBuilder } from \"./summaryGenerator\";\nconst summarizingError = \"summarizingError\";\nexport class SummarizingWarning extends LoggingError {\n  constructor(errorMessage, logged = false) {\n    super(errorMessage);\n    this.logged = logged;\n    this.errorType = summarizingError;\n    this.canRetry = true;\n  }\n\n  static wrap(error, logged = false, logger) {\n    const newErrorFn = errMsg => new SummarizingWarning(errMsg, logged);\n\n    return wrapErrorAndLog(error, newErrorFn, logger);\n  }\n\n}\nexport const createSummarizingWarning = (errorMessage, logged) => new SummarizingWarning(errorMessage, logged);\n/**\n * Summarizer is responsible for coordinating when to generate and send summaries.\n * It is the main entry point for summary work.\n * It is created only by summarizing container (i.e. one with clientType === \"summarizer\")\n */\n\nexport class Summarizer extends EventEmitter {\n  constructor(url,\n  /** Reference to runtime that created this object.\n   * i.e. runtime with clientType === \"summarizer\"\n   */\n  runtime, configurationGetter,\n  /** Represents an object that can generate summary.\n   * In practical terms, it's same runtime (this.runtime) with clientType === \"summarizer\".\n  */\n  internalsProvider, handleContext, summaryCollection, runCoordinatorCreateFn) {\n    var _this;\n\n    super();\n    _this = this;\n    this.runtime = runtime;\n    this.configurationGetter = configurationGetter;\n    this.internalsProvider = internalsProvider;\n    this.summaryCollection = summaryCollection;\n    this.runCoordinatorCreateFn = runCoordinatorCreateFn;\n    this._disposed = false;\n    this.starting = false;\n    this.stopDeferred = new Deferred();\n\n    this.summarizeOnDemand = (...args) => {\n      var _a;\n\n      try {\n        if (this._disposed || ((_a = this.runningSummarizer) === null || _a === void 0 ? void 0 : _a.disposed)) {\n          throw new UsageError(\"Summarizer is already disposed.\");\n        }\n\n        if (this.runtime.summarizerClientId !== undefined && this.runtime.summarizerClientId !== this.runtime.clientId) {\n          // If there is an elected summarizer, and it's not this one, don't allow on-demand summary.\n          // This is to prevent the on-demand summary and heuristic-based summary from stepping on\n          // each other.\n          throw new UsageError(\"On-demand summary attempted while an elected summarizer is present\");\n        }\n\n        const builder = new SummarizeResultBuilder();\n\n        if (this.runningSummarizer) {\n          // Summarizer is already running. Go ahead and start.\n          return this.runningSummarizer.summarizeOnDemand(builder, ...args);\n        } // Summarizer isn't running, so we need to start it, which is an async operation.\n        // Manage the promise related to creating the cancellation token here.\n        // The promises related to starting, summarizing,\n        // and submitting are communicated to the caller through the results builder.\n\n\n        const coordinatorCreateP = this.runCoordinatorCreateFn(this.runtime);\n        coordinatorCreateP.then(runCoordinator => {\n          // Successully created the cancellation token. Start the summarizer.\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const startP = this.start(this.runtime.clientId, runCoordinator);\n          startP.then( /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (runningSummarizer) {\n              // Successfully started the summarizer. Run it.\n              runningSummarizer.summarizeOnDemand(builder, ...args); // Wait for a command to stop or loss of connectivity before tearing down the summarizer and client.\n\n              const stopReason = yield Promise.race([_this.stopDeferred.promise, runCoordinator.waitCancelled]);\n              yield runningSummarizer.waitStop(false);\n              runCoordinator.stop(stopReason);\n\n              _this.close();\n            });\n\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }()).catch(reason => {\n            builder.fail(\"Failed to start summarizer\", reason);\n          });\n        }).catch(reason => {\n          builder.fail(\"Failed to create cancellation token\", reason);\n        });\n        return builder.build();\n      } catch (error) {\n        throw SummarizingWarning.wrap(error, false\n        /* logged */\n        , this.logger);\n      }\n    };\n\n    this.enqueueSummarize = (...args) => {\n      if (this._disposed || this.runningSummarizer === undefined || this.runningSummarizer.disposed) {\n        throw new UsageError(\"Summarizer is not running or already disposed.\");\n      }\n\n      return this.runningSummarizer.enqueueSummarize(...args);\n    };\n\n    this.logger = ChildLogger.create(this.runtime.logger, \"Summarizer\");\n    this.innerHandle = new SummarizerHandle(this, url, handleContext);\n  }\n\n  get IFluidLoadable() {\n    return this;\n  }\n\n  get ISummarizer() {\n    return this;\n  }\n\n  get handle() {\n    return this.innerHandle;\n  }\n  /**\n   * Creates a Summarizer and its underlying client.\n   * Note that different implementations of ILoader will handle the URL differently.\n   * ILoader provided by a ContainerRuntime is a RelativeLoader, which will treat URL's\n   * starting with \"/\" as relative to the Container. The general ILoader\n   * interface will expect an absolute URL and will not handle \"/\".\n   * @param loader - the loader that resolves the request\n   * @param url - the URL used to resolve the container\n   */\n\n\n  static create(loader, url) {\n    return _asyncToGenerator(function* () {\n      const request = {\n        headers: {\n          [LoaderHeader.cache]: false,\n          [LoaderHeader.clientDetails]: {\n            capabilities: {\n              interactive: false\n            },\n            type: summarizerClientType\n          },\n          [DriverHeader.summarizingClient]: true,\n          [LoaderHeader.reconnect]: false\n        },\n        url\n      };\n      const resolvedContainer = yield loader.resolve(request);\n      const fluidObject = yield requestFluidObject(resolvedContainer, {\n        url: \"_summarizer\"\n      });\n\n      if (fluidObject.ISummarizer === undefined) {\n        throw new UsageError(\"Fluid object does not implement ISummarizer\");\n      }\n\n      return fluidObject.ISummarizer;\n    })();\n  }\n\n  run(onBehalfOf) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        return yield _this2.runCore(onBehalfOf);\n      } catch (error) {\n        _this2.stop(\"summarizerException\");\n\n        throw SummarizingWarning.wrap(error, false\n        /* logged */\n        , _this2.logger);\n      } finally {\n        _this2.close();\n      }\n    })();\n  }\n  /**\n   * Stops the summarizer from running.  This will complete\n   * the run promise, and also close the container.\n   * @param reason - reason code for stopping\n   */\n\n\n  stop(reason) {\n    this.stopDeferred.resolve(reason);\n  }\n\n  close() {\n    // This will result in \"summarizerClientDisconnected\" stop reason recorded in telemetry,\n    // unless stop() was called earlier\n    this.dispose();\n    this.runtime.closeFn();\n  }\n\n  runCore(onBehalfOf) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const runCoordinator = yield _this3.runCoordinatorCreateFn(_this3.runtime); // Wait for either external signal to cancel, or loss of connectivity.\n\n      const stopP = Promise.race([runCoordinator.waitCancelled, _this3.stopDeferred.promise]);\n      void stopP.then(reason => {\n        _this3.logger.sendTelemetryEvent({\n          eventName: \"StoppingSummarizer\",\n          onBehalfOf,\n          reason\n        });\n      });\n\n      if (runCoordinator.cancelled) {\n        return runCoordinator.waitCancelled;\n      }\n\n      const runningSummarizer = yield _this3.start(onBehalfOf, runCoordinator); // Wait for either external signal to cancel, or loss of connectivity.\n\n      const stopReason = yield stopP; // There are two possible approaches here:\n      // 1. Propagate cancellation from this.stopDeferred to runCoordinator. This will ensure that we move to the exit\n      //    faster, including breaking out of the RunningSummarizer.trySummarize() faster.\n      //    We could create new coordinator and pass it to waitStop() -> trySummarizeOnce(\"lastSummary\") flow.\n      //    The con of this approach is that we might cancel active summary, and lastSummary will fail because it\n      //    did not wait for ack/nack from previous summary. Plus we disregard any 429 kind of info from service\n      //    that way (i.e. trySummarize() loop might have been waiting for 5 min because storage told us so).\n      //    In general, it's more wasted resources.\n      // 2. We can not do it and make waitStop() do last summary only if there was no active summary. This ensures\n      //    that client behaves properly (from server POV) and we do not waste resources. But, it may mean we wait\n      //    substantially longer for trySummarize() retries to play out and thus this summary loop may run into\n      //    conflict with new summarizer client starting on different client.\n      // As of now, #2 is implemented. It's more forward looking, as issue #7279 suggests changing design for new\n      // summarizer client to not be created until current summarizer fully moves to exit, and that would reduce\n      // cons of #2 substantially.\n      // Cleanup after running\n\n      yield runningSummarizer.waitStop(!runCoordinator.cancelled && Summarizer.stopReasonCanRunLastSummary(stopReason)); // Propagate reason and ensure that if someone is waiting for cancellation token, they are moving to exit\n\n      runCoordinator.stop(stopReason);\n      return stopReason;\n    })();\n  }\n  /**\n   * Should we try to run a last summary for the given stop reason?\n   * Currently only allows \"parentNotConnected\"\n   * @param stopReason - SummarizerStopReason\n   * @returns - true if the stop reason can run a last summary\n   */\n\n\n  static stopReasonCanRunLastSummary(stopReason) {\n    return stopReason === \"parentNotConnected\";\n  }\n  /**\n   * Put the summarizer in a started state, including creating and initializing the RunningSummarizer.\n   * The start request can come either from the SummaryManager (in the auto-summarize case) or from the user\n   * (in the on-demand case).\n   * @param onBehalfOf - ID of the client that requested that the summarizer start\n   * @param runCoordinator - cancellation token\n   * @param newConfig - Summary configuration to override the existing config when invoking the RunningSummarizer.\n   * @returns - Promise that is fulfilled when the RunningSummarizer is ready\n   */\n\n\n  start(onBehalfOf, runCoordinator) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this4.runningSummarizer) {\n        if (_this4.runningSummarizer.disposed) {\n          throw new UsageError(\"Starting a disposed summarizer\");\n        }\n\n        return _this4.runningSummarizer;\n      }\n\n      if (_this4.starting) {\n        throw new UsageError(\"Attempting to start a summarizer that is already starting\");\n      }\n\n      _this4.starting = true; // Initialize values and first ack (time is not exact)\n\n      _this4.logger.sendTelemetryEvent({\n        eventName: \"RunningSummarizer\",\n        onBehalfOf,\n        initSummarySeqNumber: _this4.runtime.deltaManager.initialSequenceNumber,\n        config: JSON.stringify(_this4.configurationGetter())\n      }); // Summarizing container ID (with clientType === \"summarizer\")\n\n\n      const clientId = _this4.runtime.clientId;\n\n      if (clientId === undefined) {\n        throw new UsageError(\"clientId should be defined if connected.\");\n      }\n\n      const runningSummarizer = yield RunningSummarizer.start(_this4.logger, _this4.summaryCollection.createWatcher(clientId), _this4.configurationGetter(), /*#__PURE__*/_asyncToGenerator(function* (...args) {\n        return _this4.internalsProvider.submitSummary(...args);\n      }), // submitSummaryCallback\n      new SummarizeHeuristicData(_this4.runtime.deltaManager.lastSequenceNumber, {\n        refSequenceNumber: _this4.runtime.deltaManager.initialSequenceNumber,\n        summaryTime: Date.now()\n      }), errorMessage => {\n        if (!_this4._disposed) {\n          _this4.logger.sendErrorEvent({\n            eventName: \"summarizingError\"\n          }, createSummarizingWarning(errorMessage, true));\n        }\n      }, _this4.summaryCollection, runCoordinator\n      /* cancellationToken */\n      , reason => runCoordinator.stop(reason));\n      _this4.runningSummarizer = runningSummarizer;\n      _this4.starting = false; // Handle summary acks\n      // Note: no exceptions are thrown from handleSummaryAcks handler as it handles all exceptions\n\n      _this4.handleSummaryAcks().catch(error => {\n        _this4.logger.sendErrorEvent({\n          eventName: \"HandleSummaryAckFatalError\"\n        }, error);\n      }); // Listen for ops\n\n\n      _this4.systemOpListener = op => runningSummarizer.handleSystemOp(op);\n\n      _this4.runtime.deltaManager.inbound.on(\"op\", _this4.systemOpListener);\n\n      _this4.opListener = (error, op) => runningSummarizer.handleOp(error, op);\n\n      _this4.runtime.on(\"batchEnd\", _this4.opListener);\n\n      return runningSummarizer;\n    })();\n  }\n  /**\n   * Disposes of resources after running.  This cleanup will\n   * clear any outstanding timers and reset some of the state\n   * properties.\n   * Called by ContainerRuntime when it is disposed, as well as at the end the run().\n   */\n\n\n  dispose() {\n    // Given that the call can come from own ContainerRuntime, ensure that we stop all the processes.\n    this.stop(\"summarizerClientDisconnected\");\n    this._disposed = true;\n\n    if (this.runningSummarizer) {\n      this.runningSummarizer.dispose();\n      this.runningSummarizer = undefined;\n    }\n\n    if (this.systemOpListener) {\n      this.runtime.deltaManager.inbound.off(\"op\", this.systemOpListener);\n    }\n\n    if (this.opListener) {\n      this.runtime.removeListener(\"batchEnd\", this.opListener);\n    }\n  }\n\n  handleSummaryAcks() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c, _d, _e;\n\n      let refSequenceNumber = _this5.runtime.deltaManager.initialSequenceNumber;\n      let ack;\n\n      while (_this5.runningSummarizer) {\n        const summaryLogger = (_a = _this5.runningSummarizer.tryGetCorrelatedLogger(refSequenceNumber)) !== null && _a !== void 0 ? _a : _this5.logger;\n\n        try {\n          // Initialize ack with undefined if exception happens inside of waitSummaryAck on second iteration,\n          // we record undefined, not previous handles.\n          ack = undefined;\n          ack = yield _this5.summaryCollection.waitSummaryAck(refSequenceNumber);\n          refSequenceNumber = ack.summaryOp.referenceSequenceNumber;\n          const summaryOpHandle = ack.summaryOp.contents.handle;\n          const summaryAckHandle = ack.summaryAck.contents.handle; // Make sure we block any summarizer from being executed/enqueued while\n          // executing the refreshLatestSummaryAck.\n          // https://dev.azure.com/fluidframework/internal/_workitems/edit/779\n\n          yield _this5.runningSummarizer.lockedRefreshSummaryAckAction( /*#__PURE__*/_asyncToGenerator(function* () {\n            return _this5.internalsProvider.refreshLatestSummaryAck(summaryOpHandle, summaryAckHandle, refSequenceNumber, summaryLogger).catch( /*#__PURE__*/function () {\n              var _ref4 = _asyncToGenerator(function* (error) {\n                // If the error is 404, so maybe the fetched version no longer exists on server. We just\n                // ignore this error in that case, as that means we will have another summaryAck for the\n                // latest version with which we will refresh the state. However in case of single commit\n                // summary, we might me missing a summary ack, so in that case we are still fine as the\n                // code in `submitSummary` function in container runtime, will refresh the latest state\n                // by calling `refreshLatestSummaryAckFromServer` and we will be fine.\n                if (isFluidError(error) && error.errorType === DriverErrorType.fileNotFoundOrAccessDeniedError) {\n                  summaryLogger.sendTelemetryEvent({\n                    eventName: \"HandleSummaryAckErrorIgnored\",\n                    referenceSequenceNumber: refSequenceNumber,\n                    proposalHandle: summaryOpHandle,\n                    ackHandle: summaryAckHandle\n                  }, error);\n                } else {\n                  throw error;\n                }\n              });\n\n              return function (_x2) {\n                return _ref4.apply(this, arguments);\n              };\n            }());\n          }));\n        } catch (error) {\n          summaryLogger.sendErrorEvent({\n            eventName: \"HandleSummaryAckError\",\n            referenceSequenceNumber: refSequenceNumber,\n            handle: (_c = (_b = ack === null || ack === void 0 ? void 0 : ack.summaryOp) === null || _b === void 0 ? void 0 : _b.contents) === null || _c === void 0 ? void 0 : _c.handle,\n            ackHandle: (_e = (_d = ack === null || ack === void 0 ? void 0 : ack.summaryAck) === null || _d === void 0 ? void 0 : _d.contents) === null || _e === void 0 ? void 0 : _e.handle\n          }, error);\n        }\n\n        refSequenceNumber++;\n      }\n    })();\n  }\n\n} //# sourceMappingURL=summarizer.js.map","map":null,"metadata":{},"sourceType":"module"}