{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { performance } from \"@fluidframework/common-utils\";\nimport { debug as registerDebug } from \"debug\";\nimport { TelemetryLogger, MultiSinkLogger, ChildLogger } from \"./logger\";\n/**\n * Implementation of debug logger\n */\n\nexport class DebugLogger extends TelemetryLogger {\n  constructor(debug, debugErr, properties) {\n    super(undefined, properties);\n    this.debug = debug;\n    this.debugErr = debugErr;\n  }\n  /**\n   * Create debug logger - all events are output to debug npm library\n   * @param namespace - Telemetry event name prefix to add to all events\n   * @param properties - Base properties to add to all events\n   * @param propertyGetters - Getters to add additional properties to all events\n   */\n\n\n  static create(namespace, properties) {\n    // Setup base logger upfront, such that host can disable it (if needed)\n    const debug = registerDebug(namespace);\n    const debugErr = registerDebug(namespace);\n    debugErr.log = console.error.bind(console);\n    debugErr.enabled = true;\n    return new DebugLogger(debug, debugErr, properties);\n  }\n  /**\n   * Mix in debug logger with another logger.\n   * Returned logger will output events to both newly created debug logger, as well as base logger\n   * @param namespace - Telemetry event name prefix to add to all events\n   * @param properties - Base properties to add to all events\n   * @param propertyGetters - Getters to add additional properties to all events\n   * @param baseLogger - Base logger to output events (in addition to debug logger being created). Can be undefined.\n   */\n\n\n  static mixinDebugLogger(namespace, baseLogger, properties) {\n    if (!baseLogger) {\n      return DebugLogger.create(namespace, properties);\n    }\n\n    const multiSinkLogger = new MultiSinkLogger(undefined, properties);\n    multiSinkLogger.addLogger(DebugLogger.create(namespace, this.tryGetBaseLoggerProps(baseLogger)));\n    multiSinkLogger.addLogger(ChildLogger.create(baseLogger, namespace));\n    return multiSinkLogger;\n  }\n\n  static tryGetBaseLoggerProps(baseLogger) {\n    if (baseLogger instanceof TelemetryLogger) {\n      return baseLogger.properties;\n    }\n\n    return undefined;\n  }\n  /**\n   * Send an event to debug loggers\n   *\n   * @param event - the event to send\n   */\n\n\n  send(event) {\n    const newEvent = this.prepareEvent(event);\n    const isError = newEvent.category === \"error\";\n    let logger = isError ? this.debugErr : this.debug; // Use debug's coloring schema for base of the event\n\n    const index = event.eventName.lastIndexOf(TelemetryLogger.eventNamespaceSeparator);\n    const name = event.eventName.substring(index + 1);\n\n    if (index > 0) {\n      logger = logger.extend(event.eventName.substring(0, index));\n    }\n\n    newEvent.eventName = undefined;\n    let tick = \"\";\n    tick = `tick=${TelemetryLogger.formatTick(performance.now())}`; // Extract stack to put it last, but also to avoid escaping '\\n' in it by JSON.stringify below\n\n    const stack = newEvent.stack ? newEvent.stack : \"\";\n    newEvent.stack = undefined; // Watch out for circular references - they can come from two sources\n    // 1) error object - we do not control it and should remove it and retry\n    // 2) properties supplied by telemetry caller - that's a bug that should be addressed!\n\n    let payload;\n\n    try {\n      payload = JSON.stringify(newEvent);\n    } catch (error) {\n      newEvent.error = undefined;\n      payload = JSON.stringify(newEvent);\n    }\n\n    if (payload === \"{}\") {\n      payload = \"\";\n    } // Force errors out, to help with diagnostics\n\n\n    if (isError) {\n      logger.enabled = true;\n    } // Print multi-line.\n\n\n    logger(`${name} ${payload} ${tick} ${stack}`);\n  }\n\n} //# sourceMappingURL=debugLogger.js.map","map":null,"metadata":{},"sourceType":"module"}