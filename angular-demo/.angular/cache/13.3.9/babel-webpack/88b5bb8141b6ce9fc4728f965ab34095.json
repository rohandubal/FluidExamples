{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { generateErrorWithStack } from \"@fluidframework/telemetry-utils\";\nexport function exceptionToResponse(err) {\n  const status = 500;\n\n  if (err !== null && typeof err === \"object\" && err.errorFromRequestFluidObject === true) {\n    const responseErr = err;\n    return {\n      mimeType: \"text/plain\",\n      status: responseErr.code,\n      value: responseErr.message,\n\n      get stack() {\n        return responseErr.stack;\n      }\n\n    };\n  } // Capture error objects, not stack itself, as stack retrieval is very expensive operation, so we delay it\n\n\n  const errWithStack = generateErrorWithStack();\n  return {\n    mimeType: \"text/plain\",\n    status,\n    value: `${err}`,\n\n    get stack() {\n      var _a;\n\n      return (_a = err === null || err === void 0 ? void 0 : err.stack) !== null && _a !== void 0 ? _a : errWithStack.stack;\n    }\n\n  };\n}\nexport function responseToException(response, request) {\n  const message = response.value;\n  const errWithStack = generateErrorWithStack();\n  const responseErr = {\n    errorFromRequestFluidObject: true,\n    message,\n    name: \"Error\",\n    code: response.status,\n\n    get stack() {\n      var _a;\n\n      return (_a = response.stack) !== null && _a !== void 0 ? _a : errWithStack.stack;\n    }\n\n  };\n  return responseErr;\n}\nexport function requestFluidObject(_x, _x2) {\n  return _requestFluidObject.apply(this, arguments);\n}\n\nfunction _requestFluidObject() {\n  _requestFluidObject = _asyncToGenerator(function* (router, url) {\n    const request = typeof url === \"string\" ? {\n      url\n    } : url;\n    const response = yield router.request(request);\n\n    if (response.status !== 200 || response.mimeType !== \"fluid/object\") {\n      throw responseToException(response, request);\n    }\n\n    assert(response.value, 0x19a\n    /* \"Invalid response value for Fluid object request\" */\n    );\n    return response.value;\n  });\n  return _requestFluidObject.apply(this, arguments);\n}\n\nexport const create404Response = request => createResponseError(404, \"not found\", request);\nexport function createResponseError(status, value, request) {\n  var _a;\n\n  assert(status !== 200, 0x19b\n  /* \"Cannot not create response error on 200 status\" */\n  ); // Omit query string which could contain personal data (aka \"PII\")\n\n  const urlNoQuery = (_a = request.url) === null || _a === void 0 ? void 0 : _a.split(\"?\")[0]; // Capture error objects, not stack itself, as stack retrieval is very expensive operation, so we delay it\n\n  const errWithStack = generateErrorWithStack();\n  return {\n    mimeType: \"text/plain\",\n    status,\n    value: urlNoQuery === undefined ? value : `${value}: ${urlNoQuery}`,\n\n    get stack() {\n      return errWithStack.stack;\n    }\n\n  };\n}\nexport function createDataStoreFactory(type, factory) {\n  return {\n    type,\n\n    get IFluidDataStoreFactory() {\n      return this;\n    },\n\n    get IFluidDataStoreRegistry() {\n      return this;\n    },\n\n    instantiateDataStore: function () {\n      var _ref = _asyncToGenerator(function* (context, existing) {\n        return (yield factory).instantiateDataStore(context, existing);\n      });\n\n      return function instantiateDataStore(_x3, _x4) {\n        return _ref.apply(this, arguments);\n      };\n    }(),\n    get: function () {\n      var _ref2 = _asyncToGenerator(function* (name) {\n        var _a;\n\n        return (_a = (yield factory).IFluidDataStoreRegistry) === null || _a === void 0 ? void 0 : _a.get(name);\n      });\n\n      return function get(_x5) {\n        return _ref2.apply(this, arguments);\n      };\n    }()\n  };\n} //# sourceMappingURL=dataStoreHelpers.js.map","map":null,"metadata":{},"sourceType":"module"}