{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { parse } from \"url\";\nimport { v4 as uuid } from \"uuid\";\nimport { assert, stringToBuffer, Uint8ArrayToArrayBuffer, unreachableCase } from \"@fluidframework/common-utils\";\nimport { SummaryType } from \"@fluidframework/protocol-definitions\";\nimport { LoggingError } from \"@fluidframework/telemetry-utils\";\nexport function parseUrl(url) {\n  var _a;\n\n  const parsed = parse(url, true);\n\n  if (typeof parsed.pathname !== \"string\") {\n    throw new LoggingError(\"Failed to parse pathname\");\n  }\n\n  const query = (_a = parsed.search) !== null && _a !== void 0 ? _a : \"\";\n  const regex = /^\\/([^/]*\\/[^/]*)(\\/?.*)$/;\n  const match = regex.exec(parsed.pathname);\n  return (match === null || match === void 0 ? void 0 : match.length) === 3 ? {\n    id: match[1],\n    path: match[2],\n    query,\n    version: parsed.query.version\n  } : undefined;\n}\n/**\n * Converts summary tree (for upload) to snapshot tree (for download).\n * Summary tree blobs contain contents, but snapshot tree blobs normally\n * contain IDs pointing to storage. This will create 2 blob entries in the\n * snapshot tree for each blob in the summary tree. One will be the regular\n * path pointing to a uniquely generated ID. Then there will be another\n * entry with the path as that uniquely generated ID, and value as the\n * blob contents as a base-64 string.\n * @param summary - summary to convert\n */\n\nfunction convertSummaryToSnapshotWithEmbeddedBlobContents(summary) {\n  const treeNode = {\n    blobs: {},\n    blobsContents: {},\n    trees: {},\n    id: uuid(),\n    unreferenced: summary.unreferenced\n  };\n  const keys = Object.keys(summary.tree);\n\n  for (const key of keys) {\n    const summaryObject = summary.tree[key];\n\n    switch (summaryObject.type) {\n      case SummaryType.Tree:\n        {\n          treeNode.trees[key] = convertSummaryToSnapshotWithEmbeddedBlobContents(summaryObject);\n          break;\n        }\n\n      case SummaryType.Attachment:\n        treeNode.blobs[key] = summaryObject.id;\n        break;\n\n      case SummaryType.Blob:\n        {\n          const blobId = uuid();\n          treeNode.blobs[key] = blobId;\n          const contentBuffer = typeof summaryObject.content === \"string\" ? stringToBuffer(summaryObject.content, \"utf8\") : Uint8ArrayToArrayBuffer(summaryObject.content);\n          treeNode.blobsContents[blobId] = contentBuffer;\n          break;\n        }\n\n      case SummaryType.Handle:\n        throw new LoggingError(\"No handles should be there in summary in detached container!!\");\n        break;\n\n      default:\n        {\n          unreachableCase(summaryObject, `Unknown tree type ${summaryObject.type}`);\n        }\n    }\n  }\n\n  return treeNode;\n}\n/**\n * Combine and convert protocol and app summary tree to format which is readable by container while rehydrating.\n * @param protocolSummaryTree - Protocol Summary Tree\n * @param appSummaryTree - App Summary Tree\n */\n\n\nexport function convertProtocolAndAppSummaryToSnapshotTree(protocolSummaryTree, appSummaryTree) {\n  // Shallow copy is fine, since we are doing a deep clone below.\n  const combinedSummary = {\n    type: SummaryType.Tree,\n    tree: Object.assign({}, appSummaryTree.tree)\n  };\n  combinedSummary.tree[\".protocol\"] = protocolSummaryTree;\n  const snapshotTreeWithBlobContents = convertSummaryToSnapshotWithEmbeddedBlobContents(combinedSummary);\n  return snapshotTreeWithBlobContents;\n} // This function converts the snapshot taken in detached container(by serialize api) to snapshotTree with which\n// a detached container can be rehydrated.\n\nexport const getSnapshotTreeFromSerializedContainer = detachedContainerSnapshot => {\n  const protocolSummaryTree = detachedContainerSnapshot.tree[\".protocol\"];\n  const appSummaryTree = detachedContainerSnapshot.tree[\".app\"];\n  assert(protocolSummaryTree !== undefined && appSummaryTree !== undefined, 0x1e0\n  /* \"Protocol and App summary trees should be present\" */\n  );\n  const snapshotTreeWithBlobContents = convertProtocolAndAppSummaryToSnapshotTree(protocolSummaryTree, appSummaryTree);\n  return snapshotTreeWithBlobContents;\n};\nexport function getProtocolSnapshotTree(snapshot) {\n  return \".protocol\" in snapshot.trees ? snapshot.trees[\".protocol\"] : snapshot;\n} //# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module"}