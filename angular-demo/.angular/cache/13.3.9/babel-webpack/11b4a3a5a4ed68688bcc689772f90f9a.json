{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { CreateSummarizerNodeSource } from \"@fluidframework/runtime-definitions\";\nimport { SummaryType } from \"@fluidframework/protocol-definitions\";\nimport { assert, unreachableCase } from \"@fluidframework/common-utils\";\nimport { mergeStats, convertToSummaryTree, calculateStats } from \"../summaryUtils\";\nimport { decodeSummary, encodeSummary, EscapedPath, parseSummaryForSubtrees, parseSummaryTreeForSubtrees, SummaryNode } from \"./summarizerNodeUtils\";\n/**\n * Encapsulates the summarizing work and state of an individual tree node in the\n * summary tree. It tracks changes and allows for optimizations when unchanged, or\n * can allow for fallback summaries to be generated when an error is encountered.\n * Usage is for the root node to call startSummary first to begin tracking a WIP\n * (work in progress) summary. Then all nodes will call summarize to summaries their\n * individual parts. Once completed and uploaded to storage, the root node will call\n * completeSummary or clearSummary to clear the WIP summary tracking state if something\n * went wrong. The SummarizerNodes will track all pending summaries that have been\n * recorded by the completeSummary call. When one of them is acked, the root node should\n * call refreshLatestSummary to inform the tree of SummarizerNodes of the new baseline\n * latest successful summary.\n */\n\nexport class SummarizerNode {\n  /**\n   * Do not call constructor directly.\n   * Use createRootSummarizerNode to create root node, or createChild to create child nodes.\n   */\n  constructor(defaultLogger, summarizeInternalFn, config, _changeSequenceNumber,\n  /** Undefined means created without summary */\n  _latestSummary, initialSummary, wipSummaryLogger) {\n    var _a;\n\n    this.defaultLogger = defaultLogger;\n    this.summarizeInternalFn = summarizeInternalFn;\n    this._changeSequenceNumber = _changeSequenceNumber;\n    this._latestSummary = _latestSummary;\n    this.initialSummary = initialSummary;\n    this.wipSummaryLogger = wipSummaryLogger;\n    this.children = new Map();\n    this.pendingSummaries = new Map();\n    this.outstandingOps = [];\n    this.wipSkipRecursion = false;\n    this.canReuseHandle = (_a = config.canReuseHandle) !== null && _a !== void 0 ? _a : true; // BUGBUG: Seeing issues with differential summaries.\n    // this will disable them, and throw instead\n    // while we continue to investigate\n\n    this.throwOnError = true; // config.throwOnFailure ?? false;\n\n    this.trackingSequenceNumber = this._changeSequenceNumber;\n  }\n  /**\n   * The reference sequence number of the most recent acked summary.\n   * Returns 0 if there is not yet an acked summary.\n   */\n\n\n  get referenceSequenceNumber() {\n    var _a, _b;\n\n    return (_b = (_a = this._latestSummary) === null || _a === void 0 ? void 0 : _a.referenceSequenceNumber) !== null && _b !== void 0 ? _b : 0;\n  }\n\n  startSummary(referenceSequenceNumber, summaryLogger) {\n    assert(this.wipSummaryLogger === undefined, 0x19f\n    /* \"wipSummaryLogger should not be set yet in startSummary\" */\n    );\n    assert(this.wipReferenceSequenceNumber === undefined, 0x1a0\n    /* \"Already tracking a summary\" */\n    );\n    this.wipSummaryLogger = summaryLogger;\n\n    for (const child of this.children.values()) {\n      child.startSummary(referenceSequenceNumber, this.wipSummaryLogger);\n    }\n\n    this.wipReferenceSequenceNumber = referenceSequenceNumber;\n  }\n\n  summarize(fullTree, trackState = true, telemetryContext) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      assert(_this.isTrackingInProgress(), 0x1a1\n      /* \"summarize should not be called when not tracking the summary\" */\n      );\n      assert(_this.wipSummaryLogger !== undefined, 0x1a2\n      /* \"wipSummaryLogger should have been set in startSummary or ctor\" */\n      ); // Try to reuse the tree if unchanged\n\n      if (_this.canReuseHandle && !fullTree && !_this.hasChanged()) {\n        const latestSummary = _this._latestSummary;\n\n        if (latestSummary !== undefined) {\n          _this.wipLocalPaths = {\n            localPath: latestSummary.localPath,\n            additionalPath: latestSummary.additionalPath\n          };\n          _this.wipSkipRecursion = true;\n          const stats = mergeStats();\n          stats.handleNodeCount++;\n          return {\n            summary: {\n              type: SummaryType.Handle,\n              handle: latestSummary.fullPath.path,\n              handleType: SummaryType.Tree\n            },\n            stats\n          };\n        }\n      }\n\n      try {\n        const result = yield _this.summarizeInternalFn(fullTree, true, telemetryContext);\n        _this.wipLocalPaths = {\n          localPath: EscapedPath.create(result.id)\n        };\n\n        if (result.pathPartsForChildren !== undefined) {\n          _this.wipLocalPaths.additionalPath = EscapedPath.createAndConcat(result.pathPartsForChildren);\n        }\n\n        return {\n          summary: result.summary,\n          stats: result.stats\n        };\n      } catch (error) {\n        if (_this.throwOnError || _this.trackingSequenceNumber < _this._changeSequenceNumber) {\n          throw error;\n        }\n\n        const latestSummary = _this._latestSummary;\n        const initialSummary = _this.initialSummary;\n        let encodeParam;\n        let localPath;\n\n        if (latestSummary !== undefined) {\n          // Create using handle of latest acked summary\n          encodeParam = {\n            fromSummary: true,\n            summaryNode: latestSummary\n          };\n          localPath = latestSummary.localPath;\n        } else if ((initialSummary === null || initialSummary === void 0 ? void 0 : initialSummary.summary) !== undefined) {\n          // Create using initial summary from attach op\n          encodeParam = {\n            fromSummary: false,\n            initialSummary: initialSummary.summary\n          };\n          localPath = EscapedPath.create(initialSummary.id);\n        } else {\n          // No base summary to reference\n          throw error;\n        }\n\n        _this.wipSummaryLogger.sendErrorEvent({\n          eventName: \"SummarizingWithBasePlusOps\"\n        }, error);\n\n        const summary = encodeSummary(encodeParam, _this.outstandingOps);\n        _this.wipLocalPaths = {\n          localPath,\n          additionalPath: summary.additionalPath\n        };\n        _this.wipSkipRecursion = true;\n        return {\n          summary: summary.summary,\n          stats: summary.stats\n        };\n      }\n    })();\n  }\n  /**\n   * Complete the WIP summary for the given proposalHandle\n   */\n\n\n  completeSummary(proposalHandle) {\n    this.completeSummaryCore(proposalHandle, undefined, false);\n  }\n  /**\n   * Recursive implementation for completeSummary, with additional internal-only parameters\n   */\n\n\n  completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion) {\n    assert(this.wipSummaryLogger !== undefined, 0x1a3\n    /* \"wipSummaryLogger should have been set in startSummary or ctor\" */\n    );\n    assert(this.wipReferenceSequenceNumber !== undefined, 0x1a4\n    /* \"Not tracking a summary\" */\n    );\n    let localPathsToUse = this.wipLocalPaths;\n\n    if (parentSkipRecursion) {\n      const latestSummary = this._latestSummary;\n\n      if (latestSummary !== undefined) {\n        // This case the parent node created a failure summary or was reused.\n        // This node and all children should only try to reference their path\n        // by its last known good state in the actual summary tree.\n        // If parent fails or is reused, the child summarize is not called so\n        // it did not get a chance to change its paths.\n        // In this case, essentially only propagate the new summary ref seq num.\n        localPathsToUse = {\n          localPath: latestSummary.localPath,\n          additionalPath: latestSummary.additionalPath\n        };\n      } else {\n        // This case the child is added after the latest non-failure summary.\n        // This node and all children should consider themselves as still not\n        // having a successful summary yet.\n        // We cannot \"reuse\" this node if unchanged since that summary, because\n        // handles will be unable to point to that node. It never made it to the\n        // tree itself, and only exists as an attach op in the _outstandingOps.\n        this.clearSummary();\n        return;\n      }\n    } // This should come from wipLocalPaths in normal cases, or from the latestSummary\n    // if parentIsFailure or parentIsReused is true.\n    // If there is no latestSummary, clearSummary and return before reaching this code.\n\n\n    assert(!!localPathsToUse, 0x1a5\n    /* \"Tracked summary local paths not set\" */\n    );\n    const summary = new SummaryNode(Object.assign(Object.assign({}, localPathsToUse), {\n      referenceSequenceNumber: this.wipReferenceSequenceNumber,\n      basePath: parentPath\n    }));\n    const fullPathForChildren = summary.fullPathForChildren;\n\n    for (const child of this.children.values()) {\n      child.completeSummaryCore(proposalHandle, fullPathForChildren, this.wipSkipRecursion || parentSkipRecursion);\n    } // Note that this overwrites existing pending summary with\n    // the same proposalHandle. If proposalHandle is something like\n    // a hash or unique identifier, this should be fine. If storage\n    // can return the same proposalHandle for a different summary,\n    // this should still be okay, because we should be proposing the\n    // newer one later which would have to overwrite the previous one.\n\n\n    this.pendingSummaries.set(proposalHandle, summary);\n    this.clearSummary();\n  }\n\n  clearSummary() {\n    this.wipReferenceSequenceNumber = undefined;\n    this.wipLocalPaths = undefined;\n    this.wipSkipRecursion = false;\n    this.wipSummaryLogger = undefined;\n\n    for (const child of this.children.values()) {\n      child.clearSummary();\n    }\n  }\n  /**\n   * Refreshes the latest summary tracked by this node. If we have a pending summary for the given proposal handle,\n   * it becomes the latest summary. If the current summary is already ahead (e.g., loaded from a service summary),\n   * we skip the update. Otherwise, we get the snapshot by calling `getSnapshot` and update latest\n   * summary based off of that.\n   * @returns A RefreshSummaryResult type which returns information based on the following three scenarios:\n   *          1. The latest summary was not udpated.\n   *          2. The latest summary was updated and the summary corresponding to the params was being tracked.\n   *          3. The latest summary was updated but the summary corresponding to the params was not tracked. In this\n   *             case, the latest summary is updated based on the downloaded snapshot which is also returned.\n   */\n\n\n  refreshLatestSummary(proposalHandle, summaryRefSeq, getSnapshot, readAndParseBlob, correlatedSummaryLogger) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (proposalHandle !== undefined) {\n        const maybeSummaryNode = _this2.pendingSummaries.get(proposalHandle);\n\n        if (maybeSummaryNode !== undefined) {\n          _this2.refreshLatestSummaryFromPending(proposalHandle, maybeSummaryNode.referenceSequenceNumber);\n\n          return {\n            latestSummaryUpdated: true,\n            wasSummaryTracked: true\n          };\n        }\n      } // If we have seen a summary same or later as the current one, ignore it.\n\n\n      if (_this2.referenceSequenceNumber >= summaryRefSeq) {\n        return {\n          latestSummaryUpdated: false\n        };\n      }\n\n      const snapshotTree = yield getSnapshot();\n      yield _this2.refreshLatestSummaryFromSnapshot(summaryRefSeq, snapshotTree, undefined, EscapedPath.create(\"\"), correlatedSummaryLogger, readAndParseBlob);\n      return {\n        latestSummaryUpdated: true,\n        wasSummaryTracked: false,\n        snapshot: snapshotTree\n      };\n    })();\n  }\n\n  refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber) {\n    const summaryNode = this.pendingSummaries.get(proposalHandle);\n\n    if (summaryNode === undefined) {\n      // This should only happen if parent skipped recursion AND no prior summary existed.\n      assert(this._latestSummary === undefined, 0x1a6\n      /* \"Not found pending summary, but this node has previously completed a summary\" */\n      );\n      return;\n    } else {\n      assert(referenceSequenceNumber === summaryNode.referenceSequenceNumber, 0x1a7\n      /* Pending summary reference sequence number should be consistent */\n      ); // Clear earlier pending summaries\n\n      this.pendingSummaries.delete(proposalHandle);\n    }\n\n    this.refreshLatestSummaryCore(referenceSequenceNumber);\n    this._latestSummary = summaryNode; // Propagate update to all child nodes\n\n    for (const child of this.children.values()) {\n      child.refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber);\n    }\n  }\n\n  refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // Possible re-entrancy. If we have already seen a summary later than this one, ignore it.\n      if (_this3.referenceSequenceNumber >= referenceSequenceNumber) {\n        return;\n      }\n\n      _this3.refreshLatestSummaryCore(referenceSequenceNumber);\n\n      const {\n        baseSummary,\n        pathParts\n      } = decodeSummary(snapshotTree, correlatedSummaryLogger);\n      _this3._latestSummary = new SummaryNode({\n        referenceSequenceNumber,\n        basePath,\n        localPath\n      });\n      const {\n        childrenTree,\n        childrenPathPart\n      } = parseSummaryForSubtrees(baseSummary);\n\n      if (childrenPathPart !== undefined) {\n        pathParts.push(childrenPathPart);\n      }\n\n      if (pathParts.length > 0) {\n        _this3._latestSummary.additionalPath = EscapedPath.createAndConcat(pathParts);\n      } // Propagate update to all child nodes\n\n\n      const pathForChildren = _this3._latestSummary.fullPathForChildren;\n      yield Promise.all(Array.from(_this3.children).filter(([id]) => {\n        // Assuming subtrees missing from snapshot are newer than the snapshot,\n        // but might be nice to assert this using earliest seq for node.\n        return childrenTree.trees[id] !== undefined;\n      }).map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* ([id, child]) {\n          return child.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, childrenTree.trees[id], pathForChildren, EscapedPath.create(id), correlatedSummaryLogger, readAndParseBlob);\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n\n  refreshLatestSummaryCore(referenceSequenceNumber) {\n    for (const [key, value] of this.pendingSummaries) {\n      if (value.referenceSequenceNumber < referenceSequenceNumber) {\n        this.pendingSummaries.delete(key);\n      }\n    } // Clear earlier outstanding ops\n\n\n    while (this.outstandingOps.length > 0 && this.outstandingOps[0].sequenceNumber <= referenceSequenceNumber) {\n      this.outstandingOps.shift();\n    }\n  }\n\n  loadBaseSummaryWithoutDifferential(snapshot) {\n    // Check base summary to see if it has any additional path parts\n    // separating child SummarizerNodes. Checks for .channels subtrees.\n    const {\n      childrenPathPart\n    } = parseSummaryForSubtrees(snapshot);\n\n    if (childrenPathPart !== undefined && this._latestSummary !== undefined) {\n      this._latestSummary.additionalPath = EscapedPath.create(childrenPathPart);\n    }\n  }\n\n  loadBaseSummary(snapshot, readAndParseBlob) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const decodedSummary = decodeSummary(snapshot, _this4.defaultLogger);\n      const outstandingOps = yield decodedSummary.getOutstandingOps(readAndParseBlob);\n      const {\n        childrenPathPart\n      } = parseSummaryForSubtrees(decodedSummary.baseSummary);\n\n      if (childrenPathPart !== undefined) {\n        decodedSummary.pathParts.push(childrenPathPart);\n      }\n\n      if (decodedSummary.pathParts.length > 0 && _this4._latestSummary !== undefined) {\n        _this4._latestSummary.additionalPath = EscapedPath.createAndConcat(decodedSummary.pathParts);\n      } // Defensive assertion: tracking number should already exceed this number.\n      // This is probably a little excessive; can remove when stable.\n\n\n      if (outstandingOps.length > 0) {\n        const newOpsLatestSeq = outstandingOps[outstandingOps.length - 1].sequenceNumber;\n        assert(newOpsLatestSeq <= _this4.trackingSequenceNumber, 0x1a9\n        /* \"When loading base summary, expected outstanding ops <= tracking sequence number\" */\n        );\n      }\n\n      return {\n        baseSummary: decodedSummary.baseSummary,\n        outstandingOps\n      };\n    })();\n  }\n\n  recordChange(op) {\n    const lastOp = this.outstandingOps[this.outstandingOps.length - 1];\n\n    if (lastOp !== undefined) {\n      assert(lastOp.sequenceNumber < op.sequenceNumber, 0x1aa\n      /* Out of order change recorded */\n      );\n    }\n\n    this.invalidate(op.sequenceNumber);\n    this.trackingSequenceNumber = op.sequenceNumber;\n    this.outstandingOps.push(op);\n  }\n\n  invalidate(sequenceNumber) {\n    if (sequenceNumber > this._changeSequenceNumber) {\n      this._changeSequenceNumber = sequenceNumber;\n    }\n  }\n  /**\n   * True if a change has been recorded with sequence number exceeding\n   * the latest successfully acked summary reference sequence number.\n   * False implies that the previous summary can be reused.\n   */\n\n\n  hasChanged() {\n    return this._changeSequenceNumber > this.referenceSequenceNumber;\n  }\n\n  get latestSummary() {\n    return this._latestSummary;\n  }\n\n  createChild(\n  /** Summarize function */\n  summarizeInternalFn,\n  /** Initial id or path part of this node */\n  id,\n  /**\n   * Information needed to create the node.\n   * If it is from a base summary, it will assert that a summary has been seen.\n   * Attach information if it is created from an attach op.\n   */\n  createParam, config = {}) {\n    assert(!this.children.has(id), 0x1ab\n    /* \"Create SummarizerNode child already exists\" */\n    );\n    const createDetails = this.getCreateDetailsForChild(id, createParam);\n    const child = new SummarizerNode(this.defaultLogger, summarizeInternalFn, config, createDetails.changeSequenceNumber, createDetails.latestSummary, createDetails.initialSummary, this.wipSummaryLogger); // There may be additional state that has to be updated in this child. For example, if a summary is being\n    // tracked, the child's summary tracking state needs to be updated too.\n\n    this.maybeUpdateChildState(child);\n    this.children.set(id, child);\n    return child;\n  }\n\n  getChild(id) {\n    return this.children.get(id);\n  }\n  /**\n   * Returns the details needed to create a child node.\n   * @param id - Initial id or path part of the child node.\n   * @param createParam - Information needed to create the node.\n   * @returns the details needed to create the child node.\n   */\n\n\n  getCreateDetailsForChild(id, createParam) {\n    var _a;\n\n    let initialSummary;\n    let latestSummary;\n    let changeSequenceNumber;\n    const parentLatestSummary = this._latestSummary;\n\n    switch (createParam.type) {\n      case CreateSummarizerNodeSource.FromAttach:\n        {\n          if (parentLatestSummary !== undefined && createParam.sequenceNumber <= parentLatestSummary.referenceSequenceNumber) {\n            // Prioritize latest summary if it was after this node was attached.\n            latestSummary = parentLatestSummary.createForChild(id);\n          } else {\n            const summary = convertToSummaryTree(createParam.snapshot);\n            initialSummary = {\n              sequenceNumber: createParam.sequenceNumber,\n              id,\n              summary\n            };\n          }\n\n          changeSequenceNumber = createParam.sequenceNumber;\n          break;\n        }\n\n      case CreateSummarizerNodeSource.FromSummary:\n        {\n          if (this.initialSummary === undefined) {\n            assert(!!parentLatestSummary, 0x1ac\n            /* \"Cannot create child from summary if parent does not have latest summary\" */\n            );\n          } // fallthrough to local\n\n        }\n\n      case CreateSummarizerNodeSource.Local:\n        {\n          const parentInitialSummary = this.initialSummary;\n\n          if (parentInitialSummary !== undefined) {\n            let childSummary;\n\n            if (parentInitialSummary.summary !== undefined) {\n              const {\n                childrenTree\n              } = parseSummaryTreeForSubtrees(parentInitialSummary.summary.summary);\n              assert(childrenTree.type === SummaryType.Tree, 0x1d6\n              /* \"Parent summary object is not a tree\" */\n              );\n              childSummary = childrenTree.tree[id];\n            }\n\n            if (createParam.type === CreateSummarizerNodeSource.FromSummary) {\n              // Locally created would not have differential subtree.\n              assert(!!childSummary, 0x1ad\n              /* \"Missing child summary tree\" */\n              );\n            }\n\n            let childSummaryWithStats;\n\n            if (childSummary !== undefined) {\n              assert(childSummary.type === SummaryType.Tree, 0x1ae\n              /* \"Child summary object is not a tree\" */\n              );\n              childSummaryWithStats = {\n                summary: childSummary,\n                stats: calculateStats(childSummary)\n              };\n            }\n\n            initialSummary = {\n              sequenceNumber: parentInitialSummary.sequenceNumber,\n              id,\n              summary: childSummaryWithStats\n            };\n          }\n\n          latestSummary = parentLatestSummary === null || parentLatestSummary === void 0 ? void 0 : parentLatestSummary.createForChild(id);\n          changeSequenceNumber = (_a = parentLatestSummary === null || parentLatestSummary === void 0 ? void 0 : parentLatestSummary.referenceSequenceNumber) !== null && _a !== void 0 ? _a : -1;\n          break;\n        }\n\n      default:\n        {\n          const type = createParam.type;\n          unreachableCase(createParam, `Unexpected CreateSummarizerNodeSource: ${type}`);\n        }\n    }\n\n    return {\n      initialSummary,\n      latestSummary,\n      changeSequenceNumber\n    };\n  }\n  /**\n   * Updates the state of the child if required. For example, if a summary is currently being  tracked, the child's\n   * summary tracking state needs to be updated too.\n   * @param child - The child node whose state is to be updated.\n   */\n\n\n  maybeUpdateChildState(child) {\n    // If we are tracking a summary, this child was created after the tracking started. So, we need to update the\n    // child's tracking state as well.\n    if (this.isTrackingInProgress()) {\n      child.wipReferenceSequenceNumber = this.wipReferenceSequenceNumber;\n    }\n  }\n  /**\n   * Tells whether summary tracking is in progress. True if \"startSummary\" API is called before summarize.\n   */\n\n\n  isTrackingInProgress() {\n    return this.wipReferenceSequenceNumber !== undefined;\n  }\n\n}\n/**\n * Creates a root summarizer node.\n * @param logger - Logger to use within SummarizerNode\n * @param summarizeInternalFn - Function to generate summary\n * @param changeSequenceNumber - Sequence number of latest change to new node/subtree\n * @param referenceSequenceNumber - Reference sequence number of last acked summary,\n * or undefined if not loaded from summary\n * @param config - Configure behavior of summarizer node\n */\n\nexport const createRootSummarizerNode = (logger, summarizeInternalFn, changeSequenceNumber, referenceSequenceNumber, config = {}) => new SummarizerNode(logger, summarizeInternalFn, config, changeSequenceNumber, referenceSequenceNumber === undefined ? undefined : SummaryNode.createForRoot(referenceSequenceNumber)); //# sourceMappingURL=summarizerNode.js.map","map":null,"metadata":{},"sourceType":"module"}