{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport URLParse from \"url-parse\";\nexport const parseFluidUrl = fluidUrl => {\n  return new URLParse(fluidUrl, true);\n};\n/**\n * Assume documentId is at end of url path.\n * This is true for Routerlicious' and Tinylicious' documentUrl and deltaStorageUrl.\n * Routerlicious and Tinylicious do not use documentId in storageUrl nor ordererUrl.\n * TODO: Ideally we would be able to regenerate the resolvedUrl, rather than patching the current one.\n */\n\nexport const replaceDocumentIdInPath = (urlPath, documentId) => urlPath.split(\"/\").slice(0, -1).concat([documentId]).join(\"/\");\nexport const getDiscoveredFluidResolvedUrl = (resolvedUrl, session) => {\n  if (session) {\n    const discoveredOrdererUrl = new URLParse(session.ordererUrl);\n    const deltaStorageUrl = new URLParse(resolvedUrl.endpoints.deltaStorageUrl);\n    deltaStorageUrl.set(\"host\", discoveredOrdererUrl.host);\n    const discoveredStorageUrl = new URLParse(session.historianUrl);\n    const storageUrl = new URLParse(resolvedUrl.endpoints.storageUrl);\n    storageUrl.set(\"host\", discoveredStorageUrl.host);\n    const parsedUrl = parseFluidUrl(resolvedUrl.url);\n    const discoveredResolvedUrl = {\n      endpoints: {\n        deltaStorageUrl: deltaStorageUrl.toString(),\n        ordererUrl: session.ordererUrl,\n        storageUrl: storageUrl.toString()\n      },\n      id: resolvedUrl.id,\n      tokens: resolvedUrl.tokens,\n      type: resolvedUrl.type,\n      url: new URLParse(`fluid://${discoveredOrdererUrl.host}${parsedUrl.pathname}`).toString()\n    };\n    return discoveredResolvedUrl;\n  } else {\n    return resolvedUrl;\n  }\n}; //# sourceMappingURL=urlUtils.js.map","map":null,"metadata":{},"sourceType":"module"}