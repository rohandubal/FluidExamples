{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, Timer } from \"@fluidframework/common-utils\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { isRuntimeMessage } from \"@fluidframework/driver-utils\";\nconst defaultNoopTimeFrequency = 2000;\nconst defaultNoopCountFrequency = 50; // Here are key considerations when deciding conditions for when to send non-immediate noops:\n// 1. Sending them too often results in increase in file size and bandwidth, as well as catch up performance\n// 2. Sending too infrequently ensures that collab window is large, and as result Sequence DDS would have\n//    large catchUp blobs - see Issue #6364\n// 3. Similarly, processes that rely on \"core\" snapshot (and can't parse trailing ops, including above), like search\n//    parser in SPO, will result in non-accurate results due to presence of catch up blobs.\n// 4. Ordering service used 250ms timeout to coalesce non-immediate noops. It was changed to 2000 ms to allow more\n//    aggressive noop sending from client side.\n// 5. Number of ops sent by all clients is proportional to number of \"write\" clients (every client sends noops),\n//    but number of sequenced noops is a function of time (one op per 2 seconds at most).\n//    We should consider impact to both outbound traffic (might be huge, depends on number of clients) and file size.\n// Please also see Issue #5629 for more discussions.\n//\n// With that, the current algorithm is as follows:\n// 1. Sent noop 2000 ms of receiving an op if no ops were sent by this client within this timeframe.\n//    This will ensure that MSN moves forward with reasonable speed. If that results in too many sequenced noops,\n//    server timeout of 2000ms should be reconsidered to be increased.\n// 2. If there are more than 50 ops received without sending any ops, send noop to keep collab window small.\n//    Note that system ops (including noops themselves) are excluded, so it's 1 noop per 50 real ops.\n\nexport class CollabWindowTracker {\n  constructor(submit, NoopTimeFrequency = defaultNoopTimeFrequency, NoopCountFrequency = defaultNoopCountFrequency) {\n    this.submit = submit;\n    this.NoopCountFrequency = NoopCountFrequency;\n    this.opsCountSinceNoop = 0;\n\n    if (NoopTimeFrequency !== Infinity) {\n      this.timer = new Timer(NoopTimeFrequency, () => {\n        // Can get here due to this.stopSequenceNumberUpdate() not resetting timer.\n        // Also timer callback can fire even after timer cancellation if it was queued before cancellation.\n        if (this.opsCountSinceNoop !== 0) {\n          this.submitNoop(false\n          /* immediate */\n          );\n        }\n      });\n    }\n  }\n  /**\n   * Schedules as ack to the server to update the reference sequence number\n   */\n\n\n  scheduleSequenceNumberUpdate(message, immediateNoOp) {\n    // While processing a message, an immediate no-op can be requested.\n    // i.e. to expedite approve or commit phase of quorum.\n    if (immediateNoOp) {\n      this.submitNoop(true\n      /* immediate */\n      );\n      return;\n    } // We don't acknowledge no-ops to avoid acknowledgement cycles (i.e. ack the MSN\n    // update, which updates the MSN, then ack the update, etc...).\n    // Intent here is for runtime (and DDSes) not to keep too much tracking state / memory\n    // due to runtime ops from other clients.\n\n\n    if (!isRuntimeMessage(message)) {\n      return;\n    }\n\n    this.opsCountSinceNoop++;\n\n    if (this.opsCountSinceNoop >= this.NoopCountFrequency) {\n      this.submitNoop(false\n      /* immediate */\n      );\n      return;\n    }\n\n    if (this.timer !== undefined) {\n      if (this.opsCountSinceNoop === 1) {\n        this.timer.restart();\n      }\n\n      assert(this.timer.hasTimer, 0x242\n      /* \"has timer\" */\n      );\n    }\n  }\n\n  submitNoop(immediate) {\n    // Anything other than null is immediate noop\n    this.submit(MessageType.NoOp, immediate ? \"\" : null);\n    assert(this.opsCountSinceNoop === 0, 0x243\n    /* \"stopSequenceNumberUpdate should be called as result of sending any op!\" */\n    );\n  }\n\n  stopSequenceNumberUpdate() {\n    this.opsCountSinceNoop = 0; // Ideally, we cancel timer here. But that will result in too often set/reset cycle if this client\n    // keeps sending ops. In most cases it's actually better to let it expire (at most - 4 times per second)\n    // for nothing, then have a ton of set/reset cycles.\n    // Note that Timer.restart() is smart and will not change timer expiration if we keep extending timer\n    // expiration - it will restart the timer instead when it fires with adjusted expiration.\n    // this.timer.clear();\n  }\n\n} //# sourceMappingURL=collabWindowTracker.js.map","map":null,"metadata":{},"sourceType":"module"}