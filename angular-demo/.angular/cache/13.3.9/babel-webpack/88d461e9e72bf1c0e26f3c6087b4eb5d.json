{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { Marker, TextSegment } from \"@fluidframework/merge-tree\";\nimport { SharedSegmentSequence } from \"./sequence\";\nimport { SharedStringFactory } from \"./sequenceFactory\";\n/**\n * The Shared String is a specialized data structure for handling collaborative\n * text. It is based on a more general Sequence data structure but has\n * additional features that make working with text easier.\n *\n * In addition to text, a Shared String can also contain markers. Markers can be\n * used to store metadata at positions within the text, like the details of an\n * image or Fluid object that should be rendered with the text.\n *\n */\n\nexport class SharedString extends SharedSegmentSequence {\n  constructor(document, id, attributes) {\n    super(document, id, attributes, SharedStringFactory.segmentFromSpec);\n    this.id = id;\n    this.mergeTreeTextHelper = this.client.createTextHelper();\n  }\n  /**\n   * Create a new shared string.\n   * @param runtime - data store runtime the new shared string belongs to\n   * @param id - optional name of the shared string\n   * @returns newly create shared string (but not attached yet)\n   */\n\n\n  static create(runtime, id) {\n    return runtime.createChannel(id, SharedStringFactory.Type);\n  }\n  /**\n   * Get a factory for SharedString to register with the data store.\n   * @returns a factory that creates and load SharedString\n   */\n\n\n  static getFactory() {\n    return new SharedStringFactory();\n  }\n\n  get ISharedString() {\n    return this;\n  }\n  /**\n   * Inserts a marker at a relative position.\n   * @param relativePos1 - The relative position to insert the marker at\n   * @param refType - The reference type of the marker\n   * @param props - The properties of the marker\n   */\n\n\n  insertMarkerRelative(relativePos1, refType, props) {\n    const segment = new Marker(refType);\n\n    if (props) {\n      segment.addProperties(props);\n    }\n\n    const pos = this.posFromRelativePos(relativePos1);\n    const insertOp = this.client.insertSegmentLocal(pos, segment);\n\n    if (insertOp) {\n      this.submitSequenceMessage(insertOp);\n    }\n  }\n  /**\n   * {@inheritDoc ISharedString.insertMarker}\n   */\n\n\n  insertMarker(pos, refType, props) {\n    const segment = new Marker(refType);\n\n    if (props) {\n      segment.addProperties(props);\n    }\n\n    const insertOp = this.client.insertSegmentLocal(pos, segment);\n\n    if (insertOp) {\n      this.submitSequenceMessage(insertOp);\n    }\n\n    return insertOp;\n  }\n  /**\n   * Inserts the text at the position.\n   * @param relativePos1 - The relative position to insert the text at\n   * @param text - The text to insert\n   * @param props - The properties of text\n   */\n\n\n  insertTextRelative(relativePos1, text, props) {\n    const segment = new TextSegment(text);\n\n    if (props) {\n      segment.addProperties(props);\n    }\n\n    const pos = this.posFromRelativePos(relativePos1);\n    const insertOp = this.client.insertSegmentLocal(pos, segment);\n\n    if (insertOp) {\n      this.submitSequenceMessage(insertOp);\n    }\n  }\n  /**\n   * {@inheritDoc ISharedString.insertText}\n   */\n\n\n  insertText(pos, text, props) {\n    const segment = new TextSegment(text);\n\n    if (props) {\n      segment.addProperties(props);\n    }\n\n    const insertOp = this.client.insertSegmentLocal(pos, segment);\n\n    if (insertOp) {\n      this.submitSequenceMessage(insertOp);\n    }\n  }\n  /**\n   * Replaces a range with the provided text.\n   * @param start - The inclusive start of the range to replace\n   * @param end - The exclusive end of the range to replace\n   * @param text - The text to replace the range with\n   * @param props - Optional. The properties of the replacement text\n   */\n\n\n  replaceText(start, end, text, props) {\n    this.replaceRange(start, end, TextSegment.make(text, props));\n  }\n  /**\n   * Removes the text in the given range.\n   * @param start - The inclusive start of the range to remove\n   * @param end - The exclusive end of the range to replace\n   * @returns the message sent.\n   */\n\n\n  removeText(start, end) {\n    return this.removeRange(start, end);\n  }\n  /**\n   * Annotates the marker with the provided properties and calls the callback on consensus.\n   * @param marker - The marker to annotate\n   * @param props - The properties to annotate the marker with\n   * @param consensusCallback - The callback called when consensus is reached\n   */\n\n\n  annotateMarkerNotifyConsensus(marker, props, callback) {\n    const annotateOp = this.client.annotateMarkerNotifyConsensus(marker, props, callback);\n\n    if (annotateOp) {\n      this.submitSequenceMessage(annotateOp);\n    }\n  }\n  /**\n   * Annotates the marker with the provided properties.\n   * @param marker - The marker to annotate\n   * @param props - The properties to annotate the marker with\n   * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n   */\n\n\n  annotateMarker(marker, props, combiningOp) {\n    const annotateOp = this.client.annotateMarker(marker, props, combiningOp);\n\n    if (annotateOp) {\n      this.submitSequenceMessage(annotateOp);\n    }\n  }\n\n  findTile(startPos, tileLabel, preceding = true) {\n    return this.client.findTile(startPos, tileLabel, preceding);\n  }\n\n  getTextAndMarkers(label) {\n    const segmentWindow = this.client.getCollabWindow();\n    return this.mergeTreeTextHelper.getTextAndMarkers(segmentWindow.currentSeq, segmentWindow.clientId, label);\n  }\n  /**\n   * Retrieve text from the SharedString in string format.\n   * @param start - The starting index of the text to retrieve, or 0 if omitted.\n   * @param end - The ending index of the text to retrieve, or the end of the string if omitted\n   * @returns The requested text content as a string.\n   */\n\n\n  getText(start, end) {\n    const segmentWindow = this.client.getCollabWindow();\n    return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \"\", start, end);\n  }\n  /**\n   * Adds spaces for markers and handles, so that position calculations account for them.\n   */\n\n\n  getTextWithPlaceholders() {\n    const segmentWindow = this.client.getCollabWindow();\n    return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \" \");\n  }\n\n  getTextRangeWithPlaceholders(start, end) {\n    const segmentWindow = this.client.getCollabWindow();\n    return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \" \", start, end);\n  }\n\n  getTextRangeWithMarkers(start, end) {\n    const segmentWindow = this.client.getCollabWindow();\n    return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, \"*\", start, end);\n  }\n\n  getMarkerFromId(id) {\n    return this.client.getMarkerFromId(id);\n  }\n\n} //# sourceMappingURL=sharedString.js.map","map":null,"metadata":{},"sourceType":"module"}