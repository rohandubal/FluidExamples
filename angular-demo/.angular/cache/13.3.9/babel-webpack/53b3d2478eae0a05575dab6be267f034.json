{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, LazyPromise } from \"@fluidframework/common-utils\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { isFluidResolvedUrl } from \"@fluidframework/driver-utils\";\nimport { PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nconst PackageNotFactoryError = \"Code package does not implement IRuntimeFactory\";\nexport class ContainerContext {\n  constructor(container, scope, codeLoader, _codeDetails, _baseSnapshot, deltaManager, quorum, loader, submitFn, submitSignalFn, closeFn, version, updateDirtyContainerState, existing, pendingLocalState) {\n    var _this = this;\n\n    this.container = container;\n    this.scope = scope;\n    this.codeLoader = codeLoader;\n    this._codeDetails = _codeDetails;\n    this._baseSnapshot = _baseSnapshot;\n    this.deltaManager = deltaManager;\n    this.loader = loader;\n    this.submitFn = submitFn;\n    this.submitSignalFn = submitSignalFn;\n    this.closeFn = closeFn;\n    this.version = version;\n    this.updateDirtyContainerState = updateDirtyContainerState;\n    this.existing = existing;\n    this.pendingLocalState = pendingLocalState;\n    this._disposed = false;\n    this._quorum = quorum;\n    this.taggedLogger = container.subLogger;\n    this._fluidModuleP = new LazyPromise( /*#__PURE__*/_asyncToGenerator(function* () {\n      return _this.loadCodeModule(_codeDetails);\n    }));\n    this.attachListener();\n  }\n\n  static createOrLoad(container, scope, codeLoader, codeDetails, baseSnapshot, deltaManager, quorum, loader, submitFn, submitSignalFn, closeFn, version, updateDirtyContainerState, existing, pendingLocalState) {\n    return _asyncToGenerator(function* () {\n      const context = new ContainerContext(container, scope, codeLoader, codeDetails, baseSnapshot, deltaManager, quorum, loader, submitFn, submitSignalFn, closeFn, version, updateDirtyContainerState, existing, pendingLocalState);\n      yield context.instantiateRuntime(existing);\n      return context;\n    })();\n  }\n\n  get clientId() {\n    return this.container.clientId;\n  }\n  /**\n   * DISCLAIMER: this id is only for telemetry purposes. Not suitable for any other usages.\n   */\n\n\n  get id() {\n    const resolvedUrl = this.container.resolvedUrl;\n\n    if (isFluidResolvedUrl(resolvedUrl)) {\n      return resolvedUrl.id;\n    }\n\n    return \"\";\n  }\n\n  get clientDetails() {\n    return this.container.clientDetails;\n  }\n\n  get connected() {\n    return this.container.connected;\n  }\n\n  get canSummarize() {\n    return \"summarize\" in this.runtime;\n  }\n\n  get serviceConfiguration() {\n    return this.container.serviceConfiguration;\n  }\n\n  get audience() {\n    return this.container.audience;\n  }\n\n  get options() {\n    return this.container.options;\n  }\n\n  get baseSnapshot() {\n    return this._baseSnapshot;\n  }\n\n  get storage() {\n    return this.container.storage;\n  }\n\n  get runtime() {\n    if (this._runtime === undefined) {\n      throw new Error(\"Attempted to access runtime before it was defined\");\n    }\n\n    return this._runtime;\n  }\n\n  get disposed() {\n    return this._disposed;\n  }\n\n  get codeDetails() {\n    return this._codeDetails;\n  }\n\n  get quorum() {\n    return this._quorum;\n  }\n  /**\n   * @deprecated - Temporary migratory API, to be removed when customers no longer need it.  When removed,\n   * ContainerContext should only take an IQuorumClients rather than an IQuorum.  See IContainerContext for more\n   * details.\n   */\n\n\n  getSpecifiedCodeDetails() {\n    var _a;\n\n    return (_a = this._quorum.get(\"code\")) !== null && _a !== void 0 ? _a : this._quorum.get(\"code2\");\n  }\n\n  dispose(error) {\n    if (this._disposed) {\n      return;\n    }\n\n    this._disposed = true;\n    this.runtime.dispose(error);\n\n    this._quorum.dispose();\n\n    this.deltaManager.dispose();\n  }\n\n  getLoadedFromVersion() {\n    return this.container.loadedFromVersion;\n  }\n\n  get attachState() {\n    return this.container.attachState;\n  }\n  /**\n   * Create a summary. Used when attaching or serializing a detached container.\n   *\n   * @param blobRedirectTable - A table passed during the attach process. While detached, blob upload is supported\n   * using IDs generated locally. After attach, these IDs cannot be used, so this table maps the old local IDs to the\n   * new storage IDs so requests can be redirected.\n   */\n\n\n  createSummary(blobRedirectTable) {\n    return this.runtime.createSummary(blobRedirectTable);\n  }\n\n  setConnectionState(connected, clientId) {\n    const runtime = this.runtime;\n    assert(connected === this.connected, 0x0de\n    /* \"Mismatch in connection state while setting\" */\n    );\n    runtime.setConnectionState(connected, clientId);\n  }\n\n  process(message, local, context) {\n    this.runtime.process(message, local, context);\n  }\n\n  processSignal(message, local) {\n    this.runtime.processSignal(message, local);\n  }\n\n  request(path) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2.runtime.request(path);\n    })();\n  }\n\n  getAbsoluteUrl(relativeUrl) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this3.container.getAbsoluteUrl(relativeUrl);\n    })();\n  }\n\n  getPendingLocalState() {\n    return this.runtime.getPendingLocalState();\n  }\n  /**\n   * Determines if the current code details of the context\n   * satisfy the incoming constraint code details\n   */\n\n\n  satisfies(constraintCodeDetails) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const comparers = [];\n      const maybeCompareCodeLoader = _this4.codeLoader;\n\n      if (maybeCompareCodeLoader.IFluidCodeDetailsComparer !== undefined) {\n        comparers.push(maybeCompareCodeLoader.IFluidCodeDetailsComparer);\n      }\n\n      const moduleWithDetails = yield _this4._fluidModuleP;\n      const maybeCompareExport = (_a = moduleWithDetails.module) === null || _a === void 0 ? void 0 : _a.fluidExport;\n\n      if ((maybeCompareExport === null || maybeCompareExport === void 0 ? void 0 : maybeCompareExport.IFluidCodeDetailsComparer) !== undefined) {\n        comparers.push(maybeCompareExport.IFluidCodeDetailsComparer);\n      } // if there are not comparers it is not possible to know\n      // if the current satisfy the incoming, so return false,\n      // as assuming they do not satisfy is safer .e.g we will\n      // reload, rather than potentially running with\n      // incompatible code\n\n\n      if (comparers.length === 0) {\n        return false;\n      }\n\n      for (const comparer of comparers) {\n        const satisfies = yield comparer.satisfies(moduleWithDetails.details, constraintCodeDetails);\n\n        if (satisfies === false) {\n          return false;\n        }\n      }\n\n      return true;\n    })();\n  }\n\n  notifyAttaching(snapshot) {\n    var _a, _b;\n\n    this._baseSnapshot = snapshot;\n    (_b = (_a = this.runtime).notifyAttaching) === null || _b === void 0 ? void 0 : _b.call(_a, snapshot);\n    this.runtime.setAttachState(AttachState.Attaching);\n  } // #region private\n\n\n  getRuntimeFactory() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const fluidExport = (_a = (yield _this5._fluidModuleP).module) === null || _a === void 0 ? void 0 : _a.fluidExport;\n      const runtimeFactory = fluidExport === null || fluidExport === void 0 ? void 0 : fluidExport.IRuntimeFactory;\n\n      if (runtimeFactory === undefined) {\n        throw new Error(PackageNotFactoryError);\n      }\n\n      return runtimeFactory;\n    })();\n  }\n\n  instantiateRuntime(existing) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const runtimeFactory = yield _this6.getRuntimeFactory();\n      _this6._runtime = yield runtimeFactory.instantiateRuntime(_this6, existing);\n    })();\n  }\n\n  attachListener() {\n    this.container.once(\"attached\", () => {\n      this.runtime.setAttachState(AttachState.Attached);\n    });\n  }\n\n  loadCodeModule(codeDetails) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const loadCodeResult = yield PerformanceEvent.timedExecAsync(_this7.taggedLogger, {\n        eventName: \"CodeLoad\"\n      }, /*#__PURE__*/_asyncToGenerator(function* () {\n        return _this7.codeLoader.load(codeDetails);\n      }));\n\n      if (\"module\" in loadCodeResult) {\n        const {\n          module,\n          details\n        } = loadCodeResult;\n        return {\n          module,\n          details: details !== null && details !== void 0 ? details : codeDetails\n        };\n      } else {\n        // If \"module\" is not in the result, we are using a legacy ICodeLoader.  Fix the result up with details.\n        // Once usage drops to 0 we can remove this compat path.\n        _this7.taggedLogger.sendTelemetryEvent({\n          eventName: \"LegacyCodeLoader\"\n        });\n\n        return loadCodeResult;\n      }\n    })();\n  }\n\n} //# sourceMappingURL=containerContext.js.map","map":null,"metadata":{},"sourceType":"module"}