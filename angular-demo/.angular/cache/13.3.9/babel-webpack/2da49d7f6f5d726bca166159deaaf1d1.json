{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { default as AbortController } from \"abort-controller\";\nimport { assert, performance, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { GenericError, UsageError } from \"@fluidframework/container-utils\";\nimport { canRetryOnError, createWriteError, createGenericNetworkError, getRetryDelayFromError, waitForConnectedState, DeltaStreamConnectionForbiddenError, logNetworkFailure // isRuntimeMessage,\n} from \"@fluidframework/driver-utils\";\nimport { MessageType, ScopeType } from \"@fluidframework/protocol-definitions\";\nimport { TelemetryLogger, normalizeError } from \"@fluidframework/telemetry-utils\";\nimport { ReconnectMode } from \"./contracts\";\nimport { DeltaQueue } from \"./deltaQueue\";\nconst MaxReconnectDelayInMs = 8000;\nconst InitialReconnectDelayInMs = 1000;\nconst DefaultChunkSize = 16 * 1024;\nconst fatalConnectErrorProp = {\n  fatalConnectError: true\n};\n\nfunction getNackReconnectInfo(nackContent) {\n  const message = `Nack (${nackContent.type}): ${nackContent.message}`;\n  const canRetry = nackContent.code !== 403;\n  const retryAfterMs = nackContent.retryAfter !== undefined ? nackContent.retryAfter * 1000 : undefined;\n  return createGenericNetworkError(message, {\n    canRetry,\n    retryAfterMs\n  }, {\n    statusCode: nackContent.code,\n    driverVersion: undefined\n  });\n}\n/**\n * Implementation of IDocumentDeltaConnection that does not support submitting\n * or receiving ops. Used in storage-only mode.\n */\n\n\nclass NoDeltaStream extends TypedEventEmitter {\n  constructor() {\n    super(...arguments);\n    this.clientId = \"storage-only client\";\n    this.claims = {\n      scopes: [ScopeType.DocRead]\n    };\n    this.mode = \"read\";\n    this.existing = true;\n    this.maxMessageSize = 0;\n    this.version = \"\";\n    this.initialMessages = [];\n    this.initialSignals = [];\n    this.initialClients = [];\n    this.serviceConfiguration = {\n      maxMessageSize: 0,\n      blockSize: 0,\n      summary: undefined\n    };\n    this.checkpointSequenceNumber = undefined;\n    this._disposed = false;\n  }\n\n  submit(messages) {\n    this.emit(\"nack\", this.clientId, messages.map(operation => {\n      return {\n        operation,\n        content: {\n          message: \"Cannot submit with storage-only connection\",\n          code: 403\n        }\n      };\n    }));\n  }\n\n  submitSignal(message) {\n    this.emit(\"nack\", this.clientId, {\n      operation: message,\n      content: {\n        message: \"Cannot submit signal with storage-only connection\",\n        code: 403\n      }\n    });\n  }\n\n  get disposed() {\n    return this._disposed;\n  }\n\n  dispose() {\n    this._disposed = true;\n  }\n\n}\n/**\n * Implementation of IConnectionManager, used by Container class\n * Implements constant connectivity to relay service, by reconnecting in case of loast connection or error.\n * Exposes various controls to influecen this process, including manual reconnects, forced read-only mode, etc.\n */\n\n\nexport class ConnectionManager {\n  constructor(serviceProvider, client, reconnectAllowed, logger, props) {\n    this.serviceProvider = serviceProvider;\n    this.client = client;\n    this.logger = logger;\n    this.props = props;\n    /** tracks host requiring read-only mode. */\n\n    this._forceReadonly = false;\n    /** True if there is pending (async) reconnection from \"read\" to \"write\" */\n\n    this.pendingReconnect = false;\n    this.clientSequenceNumber = 0;\n    this.clientSequenceNumberObserved = 0;\n    /** Counts the number of noops sent by the client which may not be acked. */\n\n    this.trailingNoopCount = 0;\n    this.connectFirstConnection = true;\n    this._connectionVerboseProps = {};\n    this._connectionProps = {};\n    this.closed = false;\n\n    this.opHandler = (documentId, messagesArg) => {\n      const messages = Array.isArray(messagesArg) ? messagesArg : [messagesArg];\n      this.props.incomingOpHandler(messages, \"opHandler\");\n    }; // Always connect in write mode after getting nacked.\n\n\n    this.nackHandler = (documentId, messages) => {\n      const message = messages[0];\n\n      if (this._readonlyPermissions === true) {\n        this.props.closeHandler(createWriteError(\"writeOnReadOnlyDocument\", {\n          driverVersion: undefined\n        }));\n        return;\n      }\n\n      const reconnectInfo = getNackReconnectInfo(message.content); // If the nack indicates we cannot retry, then close the container outright\n\n      if (!reconnectInfo.canRetry) {\n        this.props.closeHandler(reconnectInfo);\n        return;\n      }\n\n      this.reconnectOnError(\"write\", reconnectInfo);\n    }; // Connection mode is always read on disconnect/error unless the system mode was write.\n\n\n    this.disconnectHandlerInternal = disconnectReason => {\n      // Note: we might get multiple disconnect calls on same socket, as early disconnect notification\n      // (\"server_disconnect\", ODSP-specific) is mapped to \"disconnect\"\n      this.reconnectOnError(this.defaultReconnectionMode, disconnectReason);\n    };\n\n    this.errorHandler = error => {\n      this.reconnectOnError(this.defaultReconnectionMode, error);\n    };\n\n    this.clientDetails = this.client.details;\n    this.defaultReconnectionMode = this.client.mode;\n    this._reconnectMode = reconnectAllowed ? ReconnectMode.Enabled : ReconnectMode.Never; // Outbound message queue. The outbound queue is represented as a queue of an array of ops. Ops contained\n    // within an array *must* fit within the maxMessageSize and are guaranteed to be ordered sequentially.\n\n    this._outbound = new DeltaQueue(messages => {\n      if (this.connection === undefined) {\n        throw new Error(\"Attempted to submit an outbound message without connection\");\n      }\n\n      this.connection.submit(messages);\n    });\n\n    this._outbound.on(\"error\", error => {\n      this.props.closeHandler(normalizeError(error));\n    });\n  }\n\n  get connectionVerboseProps() {\n    return this._connectionVerboseProps;\n  }\n  /**\n   * The current connection mode, initially read.\n   */\n\n\n  get connectionMode() {\n    var _a, _b;\n\n    return (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : \"read\";\n  }\n\n  get connected() {\n    return this.connection !== undefined;\n  }\n\n  get clientId() {\n    var _a;\n\n    return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.clientId;\n  }\n  /**\n   * Automatic reconnecting enabled or disabled.\n   * If set to Never, then reconnecting will never be allowed.\n   */\n\n\n  get reconnectMode() {\n    return this._reconnectMode;\n  }\n\n  get maxMessageSize() {\n    var _a, _b, _c;\n\n    return (_c = (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.serviceConfiguration) === null || _b === void 0 ? void 0 : _b.maxMessageSize) !== null && _c !== void 0 ? _c : DefaultChunkSize;\n  }\n\n  get version() {\n    if (this.connection === undefined) {\n      throw new Error(\"Cannot check version without a connection\");\n    }\n\n    return this.connection.version;\n  }\n\n  get serviceConfiguration() {\n    var _a;\n\n    return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.serviceConfiguration;\n  }\n\n  get scopes() {\n    var _a;\n\n    return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.claims.scopes;\n  }\n\n  get outbound() {\n    return this._outbound;\n  }\n  /**\n   * Returns set of props that can be logged in telemetry that provide some insights / statistics\n   * about current or last connection (if there is no connection at the moment)\n  */\n\n\n  get connectionProps() {\n    if (this.connection !== undefined) {\n      return this._connectionProps;\n    } else {\n      return Object.assign(Object.assign({}, this._connectionProps), {\n        // Report how many ops this client sent in last disconnected session\n        sentOps: this.clientSequenceNumber\n      });\n    }\n  }\n\n  shouldJoinWrite() {\n    // We don't have to wait for ack for topmost NoOps. So subtract those.\n    return this.clientSequenceNumberObserved < this.clientSequenceNumber - this.trailingNoopCount;\n  }\n  /**\n   * Tells if container is in read-only mode.\n   * Data stores should listen for \"readonly\" notifications and disallow user\n   * making changes to data stores.\n   * Readonly state can be because of no storage write permission,\n   * or due to host forcing readonly mode for container.\n   * It is undefined if we have not yet established websocket connection\n   * and do not know if user has write access to a file.\n   */\n\n\n  get readonly() {\n    if (this._forceReadonly) {\n      return true;\n    }\n\n    return this._readonlyPermissions;\n  }\n\n  get readOnlyInfo() {\n    const storageOnly = this.connection !== undefined && this.connection instanceof NoDeltaStream;\n\n    if (storageOnly || this._forceReadonly || this._readonlyPermissions === true) {\n      return {\n        readonly: true,\n        forced: this._forceReadonly,\n        permissions: this._readonlyPermissions,\n        storageOnly\n      };\n    }\n\n    return {\n      readonly: this._readonlyPermissions\n    };\n  }\n\n  static detailsFromConnection(connection) {\n    return {\n      claims: connection.claims,\n      clientId: connection.clientId,\n      existing: connection.existing,\n      checkpointSequenceNumber: connection.checkpointSequenceNumber,\n\n      get initialClients() {\n        return connection.initialClients;\n      },\n\n      mode: connection.mode,\n      serviceConfiguration: connection.serviceConfiguration,\n      version: connection.version\n    };\n  }\n\n  dispose(error) {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n    this.pendingConnection = undefined; // Ensure that things like triggerConnect() will short circuit\n\n    this._reconnectMode = ReconnectMode.Never;\n\n    this._outbound.clear();\n\n    const disconnectReason = error !== undefined ? `Closing DeltaManager (${error.message})` : \"Closing DeltaManager\"; // This raises \"disconnect\" event if we have active connection.\n\n    this.disconnectFromDeltaStream(disconnectReason); // Notify everyone we are in read-only state.\n    // Useful for data stores in case we hit some critical error,\n    // to switch to a mode where user edits are not accepted\n\n    this.set_readonlyPermissions(true);\n  }\n  /**\n   * Enables or disables automatic reconnecting.\n   * Will throw an error if reconnectMode set to Never.\n  */\n\n\n  setAutoReconnect(mode) {\n    assert(mode !== ReconnectMode.Never && this._reconnectMode !== ReconnectMode.Never, 0x278\n    /* \"API is not supported for non-connecting or closed container\" */\n    );\n    this._reconnectMode = mode;\n\n    if (mode !== ReconnectMode.Enabled) {\n      // immediately disconnect - do not rely on service eventually dropping connection.\n      this.disconnectFromDeltaStream(\"setAutoReconnect\");\n    }\n  }\n  /**\n   * Sends signal to runtime (and data stores) to be read-only.\n   * Hosts may have read only views, indicating to data stores that no edits are allowed.\n   * This is independent from this._readonlyPermissions (permissions) and this.connectionMode\n   * (server can return \"write\" mode even when asked for \"read\")\n   * Leveraging same \"readonly\" event as runtime & data stores should behave the same in such case\n   * as in read-only permissions.\n   * But this.active can be used by some DDSes to figure out if ops can be sent\n   * (for example, read-only view still participates in code proposals / upgrades decisions)\n   *\n   * Forcing Readonly does not prevent DDS from generating ops. It is up to user code to honour\n   * the readonly flag. If ops are generated, they will accumulate locally and not be sent. If\n   * there are pending in the outbound queue, it will stop sending until force readonly is\n   * cleared.\n   *\n   * @param readonly - set or clear force readonly.\n   */\n\n\n  forceReadonly(readonly) {\n    if (readonly !== this._forceReadonly) {\n      this.logger.sendTelemetryEvent({\n        eventName: \"ForceReadOnly\",\n        value: readonly\n      });\n    }\n\n    const oldValue = this.readonly;\n    this._forceReadonly = readonly;\n\n    if (oldValue !== this.readonly) {\n      if (this._reconnectMode === ReconnectMode.Never) {\n        throw new UsageError(\"API is not supported for non-connecting or closed container\");\n      }\n\n      let reconnect = false;\n\n      if (this.readonly === true) {\n        // If we switch to readonly while connected, we should disconnect first\n        // See comment in the \"readonly\" event handler to deltaManager set up by\n        // the ContainerRuntime constructor\n        if (this.shouldJoinWrite()) {\n          // If we have pending changes, then we will never send them - it smells like\n          // host logic error.\n          this.logger.sendErrorEvent({\n            eventName: \"ForceReadonlyPendingChanged\"\n          });\n        }\n\n        reconnect = this.disconnectFromDeltaStream(\"Force readonly\");\n      }\n\n      this.props.readonlyChangeHandler(this.readonly);\n\n      if (reconnect) {\n        // reconnect if we disconnected from before.\n        this.triggerConnect(\"read\");\n      }\n    }\n  }\n\n  set_readonlyPermissions(readonly) {\n    const oldValue = this.readonly;\n    this._readonlyPermissions = readonly;\n\n    if (oldValue !== this.readonly) {\n      this.props.readonlyChangeHandler(this.readonly);\n    }\n  }\n\n  connect(connectionMode) {\n    this.connectCore(connectionMode).catch(error => {\n      const normalizedError = normalizeError(error, {\n        props: fatalConnectErrorProp\n      });\n      this.props.closeHandler(normalizedError);\n    });\n  }\n\n  connectCore(connectionMode) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      assert(!_this.closed, 0x26a\n      /* \"not closed\" */\n      );\n\n      if (_this.connection !== undefined) {\n        return; // Connection attempt already completed successfully\n      }\n\n      let pendingConnectionMode;\n\n      if (_this.pendingConnection !== undefined) {\n        pendingConnectionMode = _this.pendingConnection.connectionMode;\n\n        _this.cancelConnection(); // Throw out in-progress connection attempt in favor of new attempt\n\n\n        assert(_this.pendingConnection === undefined, 0x344\n        /* this.pendingConnection should be undefined */\n        );\n      } // If there is no specified ConnectionMode, try the previous mode, if there is no previous mode use default\n\n\n      let requestedMode = (_a = connectionMode !== null && connectionMode !== void 0 ? connectionMode : pendingConnectionMode) !== null && _a !== void 0 ? _a : _this.defaultReconnectionMode; // if we have any non-acked ops from last connection, reconnect as \"write\".\n      // without that we would connect in view-only mode, which will result in immediate\n      // firing of \"connected\" event from Container and switch of current clientId (as tracked\n      // by all DDSes). This will make it impossible to figure out if ops actually made it through,\n      // so DDSes will immediately resubmit all pending ops, and some of them will be duplicates, corrupting document\n\n      if (_this.shouldJoinWrite()) {\n        requestedMode = \"write\";\n      }\n\n      const docService = _this.serviceProvider();\n\n      assert(docService !== undefined, 0x2a7\n      /* \"Container is not attached\" */\n      );\n      let connection;\n\n      if (((_b = docService.policies) === null || _b === void 0 ? void 0 : _b.storageOnly) === true) {\n        connection = new NoDeltaStream();\n\n        _this.setupNewSuccessfulConnection(connection, \"read\");\n\n        assert(_this.pendingConnection === undefined, 0x2b3\n        /* \"logic error\" */\n        );\n        return;\n      }\n\n      let delayMs = InitialReconnectDelayInMs;\n      let connectRepeatCount = 0;\n      const connectStartTime = performance.now();\n      let lastError;\n      const abortController = new AbortController();\n      const abortSignal = abortController.signal;\n      _this.pendingConnection = {\n        abort: () => {\n          abortController.abort();\n        },\n        connectionMode: requestedMode\n      }; // This loop will keep trying to connect until successful, with a delay between each iteration.\n\n      while (connection === undefined) {\n        if (_this.closed) {\n          throw new Error(\"Attempting to connect a closed DeltaManager\");\n        }\n\n        if (abortSignal.aborted === true) {\n          _this.logger.sendTelemetryEvent({\n            eventName: \"ConnectionAttemptCancelled\",\n            attempts: connectRepeatCount,\n            duration: TelemetryLogger.formatTick(performance.now() - connectStartTime),\n            connectionEstablished: false\n          });\n\n          return;\n        }\n\n        connectRepeatCount++;\n\n        try {\n          _this.client.mode = requestedMode;\n          connection = yield docService.connectToDeltaStream(Object.assign(Object.assign({}, _this.client), {\n            mode: requestedMode\n          }));\n\n          if (connection.disposed) {\n            // Nobody observed this connection, so drop it on the floor and retry.\n            _this.logger.sendTelemetryEvent({\n              eventName: \"ReceivedClosedConnection\"\n            });\n\n            connection = undefined;\n          }\n        } catch (origError) {\n          if (typeof origError === \"object\" && origError !== null && (origError === null || origError === void 0 ? void 0 : origError.errorType) === DeltaStreamConnectionForbiddenError.errorType) {\n            connection = new NoDeltaStream();\n            requestedMode = \"read\";\n            break;\n          } // Socket.io error when we connect to wrong socket, or hit some multiplexing bug\n\n\n          if (!canRetryOnError(origError)) {\n            const error = normalizeError(origError, {\n              props: fatalConnectErrorProp\n            });\n\n            _this.props.closeHandler(error);\n\n            throw error;\n          } // Since the error is retryable this will not log to the error table\n\n\n          logNetworkFailure(_this.logger, {\n            attempts: connectRepeatCount,\n            delay: delayMs,\n            eventName: \"DeltaConnectionFailureToConnect\",\n            duration: TelemetryLogger.formatTick(performance.now() - connectStartTime)\n          }, origError);\n          lastError = origError;\n          const retryDelayFromError = getRetryDelayFromError(origError);\n          delayMs = retryDelayFromError !== null && retryDelayFromError !== void 0 ? retryDelayFromError : Math.min(delayMs * 2, MaxReconnectDelayInMs);\n\n          if (retryDelayFromError !== undefined) {\n            _this.props.reconnectionDelayHandler(retryDelayFromError, origError);\n          }\n\n          yield waitForConnectedState(delayMs);\n        }\n      } // If we retried more than once, log an event about how long it took (this will not log to error table)\n\n\n      if (connectRepeatCount > 1) {\n        logNetworkFailure(_this.logger, {\n          eventName: \"MultipleDeltaConnectionFailures\",\n          attempts: connectRepeatCount,\n          duration: TelemetryLogger.formatTick(performance.now() - connectStartTime)\n        }, lastError);\n      } // Check for abort signal after while loop as well\n\n\n      if (abortSignal.aborted === true) {\n        connection.dispose();\n\n        _this.logger.sendTelemetryEvent({\n          eventName: \"ConnectionAttemptCancelled\",\n          attempts: connectRepeatCount,\n          duration: TelemetryLogger.formatTick(performance.now() - connectStartTime),\n          connectionEstablished: true\n        });\n\n        return;\n      }\n\n      _this.setupNewSuccessfulConnection(connection, requestedMode);\n    })();\n  }\n  /**\n   * Start the connection. Any error should result in container being close.\n   * And report the error if it excape for any reason.\n   * @param args - The connection arguments\n   */\n\n\n  triggerConnect(connectionMode) {\n    assert(this.connection === undefined, 0x239\n    /* \"called only in disconnected state\" */\n    );\n\n    if (this.reconnectMode !== ReconnectMode.Enabled) {\n      return;\n    }\n\n    this.connect(connectionMode);\n  }\n  /**\n   * Disconnect the current connection.\n   * @param reason - Text description of disconnect reason to emit with disconnect event\n   * @returns A boolean that indicates if there was an existing connection (or pending connection) to disconnect\n   */\n\n\n  disconnectFromDeltaStream(reason) {\n    this.pendingReconnect = false;\n\n    if (this.connection === undefined) {\n      if (this.pendingConnection !== undefined) {\n        this.cancelConnection();\n        return true;\n      }\n\n      return false;\n    }\n\n    assert(this.pendingConnection === undefined, 0x27b\n    /* \"reentrancy may result in incorrect behavior\" */\n    );\n    const connection = this.connection; // Avoid any re-entrancy - clear object reference\n\n    this.connection = undefined; // Remove listeners first so we don't try to retrigger this flow accidentally through reconnectOnError\n\n    connection.off(\"op\", this.opHandler);\n    connection.off(\"signal\", this.props.signalHandler);\n    connection.off(\"nack\", this.nackHandler);\n    connection.off(\"disconnect\", this.disconnectHandlerInternal);\n    connection.off(\"error\", this.errorHandler);\n    connection.off(\"pong\", this.props.pongHandler); // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    this._outbound.pause();\n\n    this._outbound.clear();\n\n    this.props.disconnectHandler(reason);\n    connection.dispose();\n    this._connectionVerboseProps = {};\n    return true;\n  }\n  /**\n   * Cancel in-progress connection attempt.\n   */\n\n\n  cancelConnection() {\n    assert(this.pendingConnection !== undefined, 0x345\n    /* this.pendingConnection is undefined when trying to cancel */\n    );\n    this.pendingConnection.abort();\n    this.pendingConnection = undefined;\n    this.logger.sendTelemetryEvent({\n      eventName: \"ConnectionCancelReceived\"\n    });\n  }\n  /**\n   * Once we've successfully gotten a connection, we need to set up state, attach event listeners, and process\n   * initial messages.\n   * @param connection - The newly established connection\n   */\n\n\n  setupNewSuccessfulConnection(connection, requestedMode) {\n    // Old connection should have been cleaned up before establishing a new one\n    assert(this.connection === undefined, 0x0e6\n    /* \"old connection exists on new connection setup\" */\n    );\n    assert(!connection.disposed, 0x28a\n    /* \"can't be disposed - Callers need to ensure that!\" */\n    );\n    this.pendingConnection = undefined;\n    this.connection = connection; // Does information in scopes & mode matches?\n    // If we asked for \"write\" and got \"read\", then file is read-only\n    // But if we ask read, server can still give us write.\n\n    const readonly = !connection.claims.scopes.includes(ScopeType.DocWrite); // This connection mode validation logic is moving to the driver layer in 0.44.  These two asserts can be\n    // removed after those packages have released and become ubiquitous.\n\n    assert(requestedMode === \"read\" || readonly === (this.connectionMode === \"read\"), 0x0e7\n    /* \"claims/connectionMode mismatch\" */\n    );\n    assert(!readonly || this.connectionMode === \"read\", 0x0e8\n    /* \"readonly perf with write connection\" */\n    );\n    this.set_readonlyPermissions(readonly);\n\n    if (this.closed) {\n      // Raise proper events, Log telemetry event and close connection.\n      this.disconnectFromDeltaStream(\"ConnectionManager already closed\");\n      return;\n    }\n\n    this._outbound.resume();\n\n    connection.on(\"op\", this.opHandler);\n    connection.on(\"signal\", this.props.signalHandler);\n    connection.on(\"nack\", this.nackHandler);\n    connection.on(\"disconnect\", this.disconnectHandlerInternal);\n    connection.on(\"error\", this.errorHandler);\n    connection.on(\"pong\", this.props.pongHandler); // Initial messages are always sorted. However, due to early op handler installed by drivers and appending those\n    // ops to initialMessages, resulting set is no longer sorted, which would result in client hitting storage to\n    // fill in gap. We will recover by cancelling this request once we process remaining ops, but it's a waste that\n    // we could avoid\n\n    const initialMessages = connection.initialMessages.sort((a, b) => a.sequenceNumber - b.sequenceNumber); // Some storages may provide checkpointSequenceNumber to identify how far client is behind.\n\n    let checkpointSequenceNumber = connection.checkpointSequenceNumber;\n    this._connectionVerboseProps = {\n      clientId: connection.clientId,\n      mode: connection.mode\n    }; // reset connection props\n\n    this._connectionProps = {};\n\n    if (connection.relayServiceAgent !== undefined) {\n      this._connectionVerboseProps.relayServiceAgent = connection.relayServiceAgent;\n      this._connectionProps.relayServiceAgent = connection.relayServiceAgent;\n    }\n\n    this._connectionProps.socketDocumentId = connection.claims.documentId;\n    this._connectionProps.connectionMode = connection.mode;\n    let last = -1;\n\n    if (initialMessages.length !== 0) {\n      this._connectionVerboseProps.connectionInitialOpsFrom = initialMessages[0].sequenceNumber;\n      last = initialMessages[initialMessages.length - 1].sequenceNumber;\n      this._connectionVerboseProps.connectionInitialOpsTo = last + 1; // Update knowledge of how far we are behind, before raising \"connect\" event\n      // This is duplication of what incomingOpHandler() does, but we have to raise event before we get there,\n      // so duplicating update logic here as well.\n\n      if (checkpointSequenceNumber === undefined || checkpointSequenceNumber < last) {\n        checkpointSequenceNumber = last;\n      }\n    }\n\n    this.props.incomingOpHandler(initialMessages, this.connectFirstConnection ? \"InitialOps\" : \"ReconnectOps\");\n\n    if (connection.initialSignals !== undefined) {\n      for (const signal of connection.initialSignals) {\n        this.props.signalHandler(signal);\n      }\n    }\n\n    const details = ConnectionManager.detailsFromConnection(connection);\n    details.checkpointSequenceNumber = checkpointSequenceNumber;\n    this.props.connectHandler(details);\n    this.connectFirstConnection = false;\n  }\n  /**\n   * Disconnect the current connection and reconnect. Closes the container if it fails.\n   * @param connection - The connection that wants to reconnect - no-op if it's different from this.connection\n   * @param requestedMode - Read or write\n   * @param error - Error reconnect information including whether or not to reconnect\n   * @returns A promise that resolves when the connection is reestablished or we stop trying\n   */\n\n\n  reconnectOnError(requestedMode, error) {\n    this.reconnect(requestedMode, error.message, error).catch(this.props.closeHandler);\n  }\n  /**\n   * Disconnect the current connection and reconnect.\n   * @param connection - The connection that wants to reconnect - no-op if it's different from this.connection\n   * @param requestedMode - Read or write\n   * @param error - Error reconnect information including whether or not to reconnect\n   * @returns A promise that resolves when the connection is reestablished or we stop trying\n   */\n\n\n  reconnect(requestedMode, disconnectMessage, error) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // We quite often get protocol errors before / after observing nack/disconnect\n      // we do not want to run through same sequence twice.\n      // If we're already disconnected/disconnecting it's not appropriate to call this again.\n      assert(_this2.connection !== undefined, 0x0eb\n      /* \"Missing connection for reconnect\" */\n      );\n\n      _this2.disconnectFromDeltaStream(disconnectMessage); // We will always trigger reconnect, even if canRetry is false.\n      // Any truly fatal error state will result in container close upon attempted reconnect,\n      // which is a preferable to closing abruptly when a live connection fails.\n\n\n      if (error !== undefined && !error.canRetry) {\n        _this2.logger.sendTelemetryEvent({\n          eventName: \"reconnectingDespiteFatalError\",\n          reconnectMode: _this2.reconnectMode\n        }, error);\n      }\n\n      if (_this2.reconnectMode === ReconnectMode.Never) {\n        // Do not raise container error if we are closing just because we lost connection.\n        // Those errors (like IdleDisconnect) would show up in telemetry dashboards and\n        // are very misleading, as first initial reaction - some logic is broken.\n        _this2.props.closeHandler();\n      } // If closed then we can't reconnect\n\n\n      if (_this2.closed || _this2.reconnectMode !== ReconnectMode.Enabled) {\n        return;\n      }\n\n      const delayMs = getRetryDelayFromError(error);\n\n      if (error !== undefined && delayMs !== undefined) {\n        _this2.props.reconnectionDelayHandler(delayMs, error);\n\n        yield waitForConnectedState(delayMs);\n      }\n\n      _this2.triggerConnect(requestedMode);\n    })();\n  }\n\n  prepareMessageToSend(message) {\n    var _a, _b;\n\n    if (this.readonly === true) {\n      assert(this.readOnlyInfo.readonly === true, 0x1f0\n      /* \"Unexpected mismatch in readonly\" */\n      );\n      const error = new GenericError(\"deltaManagerReadonlySubmit\", undefined\n      /* error */\n      , {\n        readonly: this.readOnlyInfo.readonly,\n        forcedReadonly: this.readOnlyInfo.forced,\n        readonlyPermissions: this.readOnlyInfo.permissions,\n        storageOnly: this.readOnlyInfo.storageOnly\n      });\n      this.props.closeHandler(error);\n      return undefined;\n    } // reset clientSequenceNumber if we are using new clientId.\n    // we keep info about old connection as long as possible to be able to account for all non-acked ops\n    // that we pick up on next connection.\n\n\n    assert(!!this.connection, 0x0e4\n    /* \"Lost old connection!\" */\n    );\n\n    if (this.lastSubmittedClientId !== ((_a = this.connection) === null || _a === void 0 ? void 0 : _a.clientId)) {\n      this.lastSubmittedClientId = (_b = this.connection) === null || _b === void 0 ? void 0 : _b.clientId;\n      this.clientSequenceNumber = 0;\n      this.clientSequenceNumberObserved = 0;\n    }\n\n    if (message.type === MessageType.NoOp) {\n      this.trailingNoopCount++;\n    } else {\n      this.trailingNoopCount = 0;\n    }\n\n    return Object.assign(Object.assign({}, message), {\n      clientSequenceNumber: ++this.clientSequenceNumber\n    });\n  }\n\n  submitSignal(content) {\n    if (this.connection !== undefined) {\n      this.connection.submitSignal(content);\n    } else {\n      this.logger.sendErrorEvent({\n        eventName: \"submitSignalDisconnected\"\n      });\n    }\n  }\n\n  sendMessages(messages) {\n    var _this3 = this;\n\n    assert(this.connected, 0x2b4\n    /* \"not connected on sending ops!\" */\n    ); // If connection is \"read\" or implicit \"read\" (got leave op for \"write\" connection),\n    // then op can't make it through - we will get a nack if op is sent.\n    // We can short-circuit this process.\n    // Note that we also want nacks to be rare and be treated as catastrophic failures.\n    // Be careful with reentrancy though - disconnected event should not be be raised in the\n    // middle of the current workflow, but rather on clean stack!\n\n    if (this.connectionMode === \"read\") {\n      if (!this.pendingReconnect) {\n        this.pendingReconnect = true;\n        Promise.resolve().then( /*#__PURE__*/_asyncToGenerator(function* () {\n          if (_this3.pendingReconnect) {\n            // still valid?\n            yield _this3.reconnect(\"write\", // connectionMode\n            \"Switch to write\");\n          }\n        })).catch(() => {});\n      }\n\n      return;\n    }\n\n    assert(!this.pendingReconnect, 0x2b5\n    /* \"logic error\" */\n    );\n\n    this._outbound.push(messages);\n  }\n\n  beforeProcessingIncomingOp(message) {\n    // if we have connection, and message is local, then we better treat is as local!\n    assert(this.clientId !== message.clientId || this.lastSubmittedClientId === message.clientId, 0x0ee\n    /* \"Not accounting local messages correctly\" */\n    );\n\n    if (this.lastSubmittedClientId !== undefined && this.lastSubmittedClientId === message.clientId) {\n      const clientSequenceNumber = message.clientSequenceNumber;\n      assert(this.clientSequenceNumberObserved < clientSequenceNumber, 0x0ef\n      /* \"client seq# not growing\" */\n      );\n      assert(clientSequenceNumber <= this.clientSequenceNumber, 0x0f0\n      /* \"Incoming local client seq# > generated by this client\" */\n      );\n      this.clientSequenceNumberObserved = clientSequenceNumber;\n    }\n\n    if (message.type === MessageType.ClientLeave) {\n      const systemLeaveMessage = message;\n      const clientId = JSON.parse(systemLeaveMessage.data);\n\n      if (clientId === this.clientId) {\n        // We have been kicked out from quorum\n        this.logger.sendPerformanceEvent({\n          eventName: \"ReadConnectionTransition\"\n        }); // Please see #8483 for more details on why maintaining connection further as is would not work.\n        // Short story - connection properties are immutable, and many processes (consensus DDSes, summarizer)\n        // assume that connection stays \"write\" connection until disconnect, and act accordingly, which may\n        // not work well with de-facto \"read\" connection we are in after receiving own leave op on timeout.\n        // Clients need to be able to transition to \"read\" state after some time of inactivity!\n        // Note - this may close container!\n\n        this.reconnect(\"read\", // connectionMode\n        \"Switch to read\").catch(error => {\n          this.logger.sendErrorEvent({\n            eventName: \"SwitchToReadConnection\"\n          }, error);\n        });\n      }\n    }\n  }\n\n} //# sourceMappingURL=connectionManager.js.map","map":null,"metadata":{},"sourceType":"module"}