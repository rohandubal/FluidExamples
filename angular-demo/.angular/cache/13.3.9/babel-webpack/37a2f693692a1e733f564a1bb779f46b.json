{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { performance } from \"@fluidframework/common-utils\";\n/**\n * Helper class that executes a specified code block and writes an\n * {@link @fluidframework/common-definitions#ITelemetryPerformanceEvent} to a specified logger every time a specified\n * number of executions is reached (or when the class is disposed). The `duration` field in the telemetry event is\n * the duration of the latest execution (sample) of the specified function. See the documentation of the\n * `includeAggregateMetrics` parameter for additional details that can be included.\n */\n\nexport class SampledTelemetryHelper {\n  /**\n   * @param eventBase -\n   * Custom properties to include in the telemetry performance event when it is written.\n   * @param logger -\n   * The logger to use to write the telemetry performance event.\n   * @param sampleThreshold -\n   * Telemetry performance events will be generated every time we hit this many executions of the code block.\n   * @param includeAggregateMetrics -\n   * If set to `true`, the telemetry performance event will include aggregated metrics (total duration, min duration,\n   * max duration) for all the executions in between generated events.\n   * @param perBucketProperties -\n   * Map of strings that represent different buckets (which can be specified when calling the 'measure' method), to\n   * properties which should be added to the telemetry event for that bucket. If a bucket being measured does not\n   * have an entry in this map, no additional properties will be added to its telemetry events. The following keys are\n   * reserved for use by this class: \"duration\", \"count\", \"totalDuration\", \"minDuration\", \"maxDuration\". If any of\n   * them is specified as a key in one of the ITelemetryProperties objects in this map, that key-value pair will be\n   * ignored.\n   */\n  constructor(eventBase, logger, sampleThreshold, includeAggregateMetrics = false, perBucketProperties = new Map()) {\n    this.eventBase = eventBase;\n    this.logger = logger;\n    this.sampleThreshold = sampleThreshold;\n    this.includeAggregateMetrics = includeAggregateMetrics;\n    this.perBucketProperties = perBucketProperties;\n    this.disposed = false;\n    this.measurementsMap = new Map();\n  }\n  /**\n   * @param codeToMeasure -\n   * The code to be executed and measured.\n   * @param bucket -\n   * A key to track executions of the code block separately. Each different value of this parameter has a separate\n   * set of executions and metrics tracked by the class. If no such distinction needs to be made, do not provide a\n   * value.\n   * @returns Whatever the passed-in code block returns.\n   */\n\n\n  measure(codeToMeasure, bucket = \"\") {\n    var _a, _b, _c;\n\n    const start = performance.now();\n    const returnValue = codeToMeasure();\n    const duration = performance.now() - start;\n    let m = this.measurementsMap.get(bucket);\n\n    if (m === undefined) {\n      m = {\n        count: 0,\n        duration: -1\n      };\n      this.measurementsMap.set(bucket, m);\n    }\n\n    m.count++;\n    m.duration = duration;\n\n    if (this.includeAggregateMetrics) {\n      m.totalDuration = ((_a = m.totalDuration) !== null && _a !== void 0 ? _a : 0) + duration;\n      m.minDuration = Math.min((_b = m.minDuration) !== null && _b !== void 0 ? _b : duration, duration);\n      m.maxDuration = Math.max((_c = m.maxDuration) !== null && _c !== void 0 ? _c : 0, duration);\n    }\n\n    if (m.count >= this.sampleThreshold) {\n      this.flushBucket(bucket);\n    }\n\n    return returnValue;\n  }\n\n  flushBucket(bucket) {\n    const measurements = this.measurementsMap.get(bucket);\n\n    if (measurements === undefined) {\n      return;\n    }\n\n    if (measurements.count !== 0) {\n      const bucketProperties = this.perBucketProperties.get(bucket);\n      const telemetryEvent = Object.assign(Object.assign(Object.assign({}, this.eventBase), bucketProperties), measurements);\n      this.logger.sendPerformanceEvent(telemetryEvent);\n      this.measurementsMap.delete(bucket);\n    }\n  }\n\n  dispose(error) {\n    this.measurementsMap.forEach((_, k) => this.flushBucket(k));\n  }\n\n} //# sourceMappingURL=sampledTelemetryHelper.js.map","map":null,"metadata":{},"sourceType":"module"}