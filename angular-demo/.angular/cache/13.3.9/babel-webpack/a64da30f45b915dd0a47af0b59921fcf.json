{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n// eslint-disable-next-line import/no-internal-modules\nimport cloneDeep from \"lodash/cloneDeep\";\nimport { readAndParse } from \"@fluidframework/driver-utils\";\nimport { DataProcessingError } from \"@fluidframework/container-utils\";\nimport { assert, Lazy } from \"@fluidframework/common-utils\";\nimport { createServiceEndpoints, summarizeChannel, summarizeChannelAsync } from \"./channelContext\";\n/**\n * Channel context for a locally created channel\n */\n\nexport class LocalChannelContextBase {\n  constructor(id, registry, runtime, servicesGetter) {\n    this.id = id;\n    this.registry = registry;\n    this.runtime = runtime;\n    this.servicesGetter = servicesGetter;\n    this.globallyVisible = false;\n    this.pending = [];\n    assert(!this.id.includes(\"/\"), 0x30f\n    /* Channel context ID cannot contain slashes */\n    );\n  }\n\n  getChannel() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      assert(_this.channel !== undefined, 0x207\n      /* \"Channel should be defined\" */\n      );\n      return _this.channel;\n    })();\n  }\n\n  get isLoaded() {\n    return this.channel !== undefined;\n  }\n\n  setConnectionState(connected, clientId) {\n    // Connection events are ignored if the data store is not yet globallyVisible or loaded\n    if (this.globallyVisible && this.isLoaded) {\n      this.servicesGetter().value.deltaConnection.setConnectionState(connected);\n    }\n  }\n\n  processOp(message, local, localOpMetadata) {\n    assert(this.globallyVisible, 0x2d3\n    /* \"Local channel must be globally visible when processing op\" */\n    ); // A local channel may not be loaded in case where we rehydrate the container from a snapshot because of\n    // delay loading. So after the container is attached and some other client joins which start generating\n    // ops for this channel. So not loaded local channel can still receive ops and we store them to process later.\n\n    if (this.isLoaded) {\n      this.servicesGetter().value.deltaConnection.process(message, local, localOpMetadata);\n    } else {\n      assert(local === false, 0x189\n      /* \"Should always be remote because a local dds shouldn't generate ops before loading\" */\n      );\n      this.pending.push(message);\n    }\n  }\n\n  reSubmit(content, localOpMetadata) {\n    assert(this.isLoaded, 0x18a\n    /* \"Channel should be loaded to resubmit ops\" */\n    );\n    assert(this.globallyVisible, 0x2d4\n    /* \"Local channel must be globally visible when resubmitting op\" */\n    );\n    this.servicesGetter().value.deltaConnection.reSubmit(content, localOpMetadata);\n  }\n\n  rollback(content, localOpMetadata) {\n    assert(this.isLoaded, 0x2ee\n    /* \"Channel should be loaded to rollback ops\" */\n    );\n    assert(this.globallyVisible, 0x2ef\n    /* \"Local channel must be globally visible when rolling back op\" */\n    );\n    this.servicesGetter().value.deltaConnection.rollback(content, localOpMetadata);\n  }\n\n  applyStashedOp() {\n    throw new Error(\"no stashed ops on local channel\");\n  }\n  /**\n   * Returns a summary at the current sequence number.\n   * @param fullTree - true to bypass optimizations and force a full summary tree\n   * @param trackState - This tells whether we should track state from this summary.\n   * @param telemetryContext - summary data passed through the layers for telemetry purposes\n   */\n\n\n  summarize(fullTree = false, trackState = false, telemetryContext) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      assert(_this2.isLoaded && _this2.channel !== undefined, 0x18c\n      /* \"Channel should be loaded to summarize\" */\n      );\n      return summarizeChannelAsync(_this2.channel, fullTree, trackState, telemetryContext);\n    })();\n  }\n\n  getAttachSummary(telemetryContext) {\n    assert(this.isLoaded && this.channel !== undefined, 0x18d\n    /* \"Channel should be loaded to take snapshot\" */\n    );\n    return summarizeChannel(this.channel, true\n    /* fullTree */\n    , false\n    /* trackState */\n    , telemetryContext);\n  }\n\n  makeVisible() {\n    if (this.globallyVisible) {\n      throw new Error(\"Channel is already globally visible\");\n    }\n\n    if (this.isLoaded) {\n      assert(!!this.channel, 0x192\n      /* \"Channel should be there if loaded!!\" */\n      );\n      this.channel.connect(this.servicesGetter().value);\n    }\n\n    this.globallyVisible = true;\n  }\n  /**\n   * Returns the data used for garbage collection. This includes a list of GC nodes that represent this context.\n   * Each node has a set of outbound routes to other GC nodes in the document. This should be called only after\n   * the context has loaded.\n   * @param fullGC - true to bypass optimizations and force full generation of GC data.\n   */\n\n\n  getGCData(fullGC = false) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      assert(_this3.isLoaded && _this3.channel !== undefined, 0x193\n      /* \"Channel should be loaded to run GC\" */\n      );\n      return _this3.channel.getGCData(fullGC);\n    })();\n  }\n\n  updateUsedRoutes(usedRoutes, gcTimestamp) {\n    /**\n     * Currently, DDSes are always considered referenced and are not garbage collected.\n     * Once we have GC at DDS level, this channel context's used routes will be updated as per the passed\n     * value. See - https://github.com/microsoft/FluidFramework/issues/4611\n     */\n  }\n\n}\nexport class RehydratedLocalChannelContext extends LocalChannelContextBase {\n  constructor(id, registry, runtime, dataStoreContext, storageService, logger, submitFn, dirtyFn, addedGCOutboundReferenceFn, snapshotTree) {\n    super(id, registry, runtime, () => this.services);\n    this.snapshotTree = snapshotTree;\n    const blobMap = new Map();\n    const clonedSnapshotTree = cloneDeep(this.snapshotTree); // 0.47 back-compat Need to sanitize if snapshotTree.blobs still contains blob contents too.\n    // This is for older snapshot which is generated by loader <=0.47 version which still contains\n    // the contents within blobs. After a couple of revisions we can remove it.\n\n    if (this.isSnapshotInOldFormatAndCollectBlobs(clonedSnapshotTree, blobMap)) {\n      this.sanitizeSnapshot(clonedSnapshotTree);\n    }\n\n    this.services = new Lazy(() => {\n      return createServiceEndpoints(this.id, dataStoreContext.connected, submitFn, this.dirtyFn, addedGCOutboundReferenceFn, storageService, logger, clonedSnapshotTree, blobMap);\n    });\n\n    this.dirtyFn = () => {\n      dirtyFn(id);\n    };\n  }\n\n  getChannel() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this4.channel === undefined) {\n        _this4.channel = yield _this4.loadChannel().catch(err => {\n          throw DataProcessingError.wrapIfUnrecognized(err, \"rehydratedLocalChannelContextFailedToLoadChannel\", undefined);\n        });\n      }\n\n      return _this4.channel;\n    })();\n  }\n\n  loadChannel() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      assert(!_this5.isLoaded, 0x18e\n      /* \"Channel must not already be loaded when loading\" */\n      );\n      assert(yield _this5.services.value.objectStorage.contains(\".attributes\"), 0x190\n      /* \".attributes blob should be present\" */\n      );\n      const attributes = yield readAndParse(_this5.services.value.objectStorage, \".attributes\");\n      assert(_this5.factory === undefined, 0x208\n      /* \"Factory should be undefined before loading\" */\n      );\n      _this5.factory = _this5.registry.get(attributes.type);\n\n      if (_this5.factory === undefined) {\n        throw new Error(`Channel Factory ${attributes.type} not registered`);\n      } // Services will be assigned during this load.\n\n\n      const channel = yield _this5.factory.load(_this5.runtime, _this5.id, _this5.services.value, attributes); // Commit changes.\n\n      _this5.channel = channel; // Send all pending messages to the channel\n\n      for (const message of _this5.pending) {\n        _this5.services.value.deltaConnection.process(message, false, undefined\n        /* localOpMetadata */\n        );\n      }\n\n      return _this5.channel;\n    })();\n  }\n\n  isSnapshotInOldFormatAndCollectBlobs(snapshotTree, blobMap) {\n    let sanitize = false;\n    const blobsContents = snapshotTree.blobsContents;\n    Object.entries(blobsContents).forEach(([key, value]) => {\n      blobMap.set(key, value);\n\n      if (snapshotTree.blobs[key] !== undefined) {\n        sanitize = true;\n      }\n    });\n\n    for (const value of Object.values(snapshotTree.trees)) {\n      sanitize = sanitize || this.isSnapshotInOldFormatAndCollectBlobs(value, blobMap);\n    }\n\n    return sanitize;\n  }\n\n  sanitizeSnapshot(snapshotTree) {\n    const blobMapInitial = new Map(Object.entries(snapshotTree.blobs));\n\n    for (const [blobName, blobId] of blobMapInitial.entries()) {\n      const blobValue = blobMapInitial.get(blobId);\n\n      if (blobValue === undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete snapshotTree.blobs[blobName];\n      }\n    }\n\n    for (const value of Object.values(snapshotTree.trees)) {\n      this.sanitizeSnapshot(value);\n    }\n  }\n\n}\nexport class LocalChannelContext extends LocalChannelContextBase {\n  constructor(id, registry, type, runtime, dataStoreContext, storageService, logger, submitFn, dirtyFn, addedGCOutboundReferenceFn) {\n    super(id, registry, runtime, () => this.services);\n    assert(type !== undefined, 0x209\n    /* \"Factory Type should be defined\" */\n    );\n    this.factory = registry.get(type);\n\n    if (this.factory === undefined) {\n      throw new Error(`Channel Factory ${type} not registered`);\n    }\n\n    this.channel = this.factory.create(runtime, id);\n    this.services = new Lazy(() => {\n      return createServiceEndpoints(this.id, dataStoreContext.connected, submitFn, this.dirtyFn, addedGCOutboundReferenceFn, storageService, logger);\n    });\n\n    this.dirtyFn = () => {\n      dirtyFn(id);\n    };\n  }\n\n} //# sourceMappingURL=localChannelContext.js.map","map":null,"metadata":{},"sourceType":"module"}