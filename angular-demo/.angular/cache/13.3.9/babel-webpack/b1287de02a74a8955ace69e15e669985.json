{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { TypedEventEmitter } from \"@fluidframework/common-utils\";\n/**\n * Base class for providing audience information for sessions interacting with FluidContainer\n * This can be extended by different service-specific client packages to additional parameters to\n * the user and client details returned in IMember\n * @typeParam M - A service-specific member type.\n */\n\nexport class ServiceAudience extends TypedEventEmitter {\n  constructor(\n  /**\n   * Fluid Container to read the audience from.\n   */\n  container) {\n    super();\n    this.container = container;\n    /**\n     * Retain the most recent member list.  This is so we have more information about a member\n     * leaving the audience in the removeMember event.  It allows us to match the behavior of the\n     * addMember event where it only fires on a change to the members this class exposes (and would\n     * actually produce a change in what getMembers returns).  It also allows us to provide the\n     * client details in the event which makes it easier to find that client connection in a map\n     * keyed on the userId and not clientId.\n     * This map will always be up-to-date in a removeMember event because it is set once at\n     * construction and in every addMember event.\n     * It is mapped clientId to M to be better work with what the IAudience event provides\n     */\n\n    this.lastMembers = new Map();\n    this.audience = container.audience; // getMembers will assign lastMembers so the removeMember event has what it needs\n    // in case it would fire before getMembers otherwise gets called the first time\n\n    this.getMembers();\n    this.audience.on(\"addMember\", (clientId, details) => {\n      if (this.shouldIncludeAsMember(details)) {\n        const member = this.getMember(clientId);\n        this.emit(\"memberAdded\", clientId, member);\n        this.emit(\"membersChanged\");\n      }\n    });\n    this.audience.on(\"removeMember\", clientId => {\n      if (this.lastMembers.has(clientId)) {\n        this.emit(\"memberRemoved\", clientId, this.lastMembers.get(clientId));\n        this.emit(\"membersChanged\");\n      }\n    });\n    this.container.on(\"connected\", () => this.emit(\"membersChanged\"));\n  }\n  /**\n   * {@inheritDoc IServiceAudience.getMembers}\n   */\n\n\n  getMembers() {\n    const users = new Map();\n    const clientMemberMap = new Map(); // Iterate through the members and get the user specifics.\n\n    this.audience.getMembers().forEach((member, clientId) => {\n      if (this.shouldIncludeAsMember(member)) {\n        const userId = member.user.id; // Ensure we're tracking the user\n\n        let user = users.get(userId);\n\n        if (user === undefined) {\n          user = this.createServiceMember(member);\n          users.set(userId, user);\n        } // Add this connection to their collection\n\n\n        user.connections.push({\n          id: clientId,\n          mode: member.mode\n        });\n        clientMemberMap.set(clientId, user);\n      }\n    });\n    this.lastMembers = clientMemberMap;\n    return users;\n  }\n  /**\n   * {@inheritDoc IServiceAudience.getMyself}\n   */\n\n\n  getMyself() {\n    const clientId = this.container.clientId;\n\n    if (clientId === undefined) {\n      return undefined;\n    }\n\n    return this.getMember(clientId);\n  }\n\n  getMember(clientId) {\n    // Fetch the user ID assoicated with this client ID from the runtime\n    const internalAudienceMember = this.audience.getMember(clientId);\n\n    if (internalAudienceMember === undefined) {\n      return undefined;\n    } // Return the member object with any other clients associated for this user\n\n\n    const allMembers = this.getMembers();\n    const member = allMembers.get(internalAudienceMember === null || internalAudienceMember === void 0 ? void 0 : internalAudienceMember.user.id);\n\n    if (member === undefined) {\n      throw Error(`Attempted to fetch client ${clientId} that is not part of the current member list`);\n    }\n\n    return member;\n  }\n  /**\n   * Provides ability for the inheriting class to include/omit specific members.\n   * An example use case is omitting the summarizer client.\n   * @param member - Member to be included/omitted.\n   */\n\n\n  shouldIncludeAsMember(member) {\n    // Include only human members\n    return member.details.capabilities.interactive;\n  }\n\n} //# sourceMappingURL=serviceAudience.js.map","map":null,"metadata":{},"sourceType":"module"}