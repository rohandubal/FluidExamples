{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar _a, _b;\n\nimport { assert, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { UsageError } from \"@fluidframework/container-utils\";\nimport { readAndParse } from \"@fluidframework/driver-utils\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { SharedObject, ValueType } from \"@fluidframework/shared-object-base\";\nimport { SummaryTreeBuilder } from \"@fluidframework/runtime-utils\";\nimport * as path from \"path-browserify\";\nimport { LocalValueMaker, makeSerializable } from \"./localValues\";\nimport { pkgVersion } from \"./packageVersion\"; // We use path-browserify since this code can run safely on the server or the browser.\n// We standardize on using posix slashes everywhere.\n\nconst posix = path.posix;\nconst snapshotFileName = \"header\";\n/**\n * The factory that defines the directory.\n * @sealed\n */\n\nexport class DirectoryFactory {\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n   */\n  get type() {\n    return DirectoryFactory.Type;\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n   */\n\n\n  get attributes() {\n    return DirectoryFactory.Attributes;\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n   */\n\n\n  load(runtime, id, services, attributes) {\n    return _asyncToGenerator(function* () {\n      const directory = new SharedDirectory(id, runtime, attributes);\n      yield directory.load(services);\n      return directory;\n    })();\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.create}\n   */\n\n\n  create(runtime, id) {\n    const directory = new SharedDirectory(id, runtime, DirectoryFactory.Attributes);\n    directory.initializeLocal();\n    return directory;\n  }\n\n}\n/**\n * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n */\n\nDirectoryFactory.Type = \"https://graph.microsoft.com/types/directory\";\n/**\n * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n */\n\nDirectoryFactory.Attributes = {\n  type: DirectoryFactory.Type,\n  snapshotFormatVersion: \"0.1\",\n  packageVersion: pkgVersion\n};\n/**\n * SharedDirectory provides a hierarchical organization of map-like data structures as SubDirectories.\n * The values stored within can be accessed like a map, and the hierarchy can be navigated using path syntax.\n * SubDirectories can be retrieved for use as working directories.\n *\n * @example\n * ```typescript\n * mySharedDirectory.createSubDirectory(\"a\").createSubDirectory(\"b\").createSubDirectory(\"c\").set(\"foo\", val1);\n * const mySubDir = mySharedDirectory.getWorkingDirectory(\"/a/b/c\");\n * mySubDir.get(\"foo\"); // returns val1\n * ```\n *\n * @sealed\n */\n\nexport class SharedDirectory extends SharedObject {\n  /**\n   * Constructs a new shared directory. If the object is non-local an id and service interfaces will\n   * be provided.\n   * @param id - String identifier for the SharedDirectory\n   * @param runtime - Data store runtime\n   * @param type - Type identifier\n   */\n  constructor(id, runtime, attributes) {\n    super(id, runtime, attributes, \"fluid_directory_\");\n    /**\n     * String representation for the class.\n     */\n\n    this[_a] = \"SharedDirectory\";\n    /**\n     * Root of the SharedDirectory, most operations on the SharedDirectory itself act on the root.\n     */\n\n    this.root = new SubDirectory(this, this.runtime, this.serializer, posix.sep);\n    /**\n     * Mapping of op types to message handlers.\n     */\n\n    this.messageHandlers = new Map();\n    this.localValueMaker = new LocalValueMaker(this.serializer);\n    this.setMessageHandlers(); // Mirror the containedValueChanged op on the SharedDirectory\n\n    this.root.on(\"containedValueChanged\", (changed, local) => {\n      this.emit(\"containedValueChanged\", changed, local, this);\n    });\n    this.root.on(\"subDirectoryCreated\", (relativePath, local) => {\n      this.emit(\"subDirectoryCreated\", relativePath, local, this);\n    });\n    this.root.on(\"subDirectoryDeleted\", (relativePath, local) => {\n      this.emit(\"subDirectoryDeleted\", relativePath, local, this);\n    });\n  }\n  /**\n   * Create a new shared directory\n   *\n   * @param runtime - Data store runtime the new shared directory belongs to\n   * @param id - Optional name of the shared directory\n   * @returns Newly create shared directory (but not attached yet)\n   */\n\n\n  static create(runtime, id) {\n    return runtime.createChannel(id, DirectoryFactory.Type);\n  }\n  /**\n   * Get a factory for SharedDirectory to register with the data store.\n   *\n   * @returns A factory that creates and load SharedDirectory\n   */\n\n\n  static getFactory() {\n    return new DirectoryFactory();\n  }\n  /**\n   * {@inheritDoc IDirectory.absolutePath}\n   */\n\n\n  get absolutePath() {\n    return this.root.absolutePath;\n  }\n  /**\n   * {@inheritDoc IDirectory.get}\n   */\n\n\n  get(key) {\n    return this.root.get(key);\n  }\n  /**\n   * {@inheritDoc IDirectory.set}\n   */\n\n\n  set(key, value) {\n    this.root.set(key, value);\n    return this;\n  }\n\n  dispose(error) {\n    this.root.dispose(error);\n  }\n\n  get disposed() {\n    return this.root.disposed;\n  }\n  /**\n   * Deletes the given key from within this IDirectory.\n   * @param key - The key to delete\n   * @returns True if the key existed and was deleted, false if it did not exist\n   */\n\n\n  delete(key) {\n    return this.root.delete(key);\n  }\n  /**\n   * Deletes all keys from within this IDirectory.\n   */\n\n\n  clear() {\n    this.root.clear();\n  }\n  /**\n   * Checks whether the given key exists in this IDirectory.\n   * @param key - The key to check\n   * @returns True if the key exists, false otherwise\n   */\n\n\n  has(key) {\n    return this.root.has(key);\n  }\n  /**\n   * The number of entries under this IDirectory.\n   */\n\n\n  get size() {\n    return this.root.size;\n  }\n  /**\n   * Issue a callback on each entry under this IDirectory.\n   * @param callback - Callback to issue\n   */\n\n\n  forEach(callback) {\n    this.root.forEach(callback);\n  }\n  /**\n   * Get an iterator over the entries under this IDirectory.\n   * @returns The iterator\n   */\n\n\n  [(_a = Symbol.toStringTag, Symbol.iterator)]() {\n    return this.root[Symbol.iterator]();\n  }\n  /**\n   * Get an iterator over the entries under this IDirectory.\n   * @returns The iterator\n   */\n\n\n  entries() {\n    return this.root.entries();\n  }\n  /**\n   * {@inheritDoc IDirectory.countSubDirectory}\n   */\n\n\n  countSubDirectory() {\n    return this.root.countSubDirectory();\n  }\n  /**\n   * Get an iterator over the keys under this IDirectory.\n   * @returns The iterator\n   */\n\n\n  keys() {\n    return this.root.keys();\n  }\n  /**\n   * Get an iterator over the values under this IDirectory.\n   * @returns The iterator\n   */\n\n\n  values() {\n    return this.root.values();\n  }\n  /**\n   * {@inheritDoc IDirectory.createSubDirectory}\n   */\n\n\n  createSubDirectory(subdirName) {\n    return this.root.createSubDirectory(subdirName);\n  }\n  /**\n   * {@inheritDoc IDirectory.getSubDirectory}\n   */\n\n\n  getSubDirectory(subdirName) {\n    return this.root.getSubDirectory(subdirName);\n  }\n  /**\n   * {@inheritDoc IDirectory.hasSubDirectory}\n   */\n\n\n  hasSubDirectory(subdirName) {\n    return this.root.hasSubDirectory(subdirName);\n  }\n  /**\n   * {@inheritDoc IDirectory.deleteSubDirectory}\n   */\n\n\n  deleteSubDirectory(subdirName) {\n    return this.root.deleteSubDirectory(subdirName);\n  }\n  /**\n   * {@inheritDoc IDirectory.subdirectories}\n   */\n\n\n  subdirectories() {\n    return this.root.subdirectories();\n  }\n  /**\n   * {@inheritDoc IDirectory.getWorkingDirectory}\n   */\n\n\n  getWorkingDirectory(relativePath) {\n    const absolutePath = this.makeAbsolute(relativePath);\n\n    if (absolutePath === posix.sep) {\n      return this.root;\n    }\n\n    let currentSubDir = this.root;\n    const subdirs = absolutePath.substr(1).split(posix.sep);\n\n    for (const subdir of subdirs) {\n      currentSubDir = currentSubDir.getSubDirectory(subdir);\n\n      if (!currentSubDir) {\n        return undefined;\n      }\n    }\n\n    return currentSubDir;\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.summarizeCore}\n   * @internal\n   */\n\n\n  summarizeCore(serializer, telemetryContext) {\n    return this.serializeDirectory(this.root, serializer);\n  }\n  /**\n   * Submits an operation\n   * @param op - Op to submit\n   * @param localOpMetadata - The local metadata associated with the op. We send a unique id that is used to track\n   * this op while it has not been ack'd. This will be sent when we receive this op back from the server.\n   * @internal\n   */\n\n\n  submitDirectoryMessage(op, localOpMetadata) {\n    this.submitLocalMessage(op, localOpMetadata);\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.onDisconnect}\n   * @internal\n   */\n\n\n  onDisconnect() {}\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.reSubmitCore}\n   * @internal\n   */\n\n\n  reSubmitCore(content, localOpMetadata) {\n    const message = content;\n    const handler = this.messageHandlers.get(message.type);\n    assert(handler !== undefined, 0x00d\n    /* Missing message handler for message type */\n    );\n    handler.submit(message, localOpMetadata);\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n   * @internal\n   */\n\n\n  loadCore(storage) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const data = yield readAndParse(storage, snapshotFileName);\n      const newFormat = data;\n\n      if (Array.isArray(newFormat.blobs)) {\n        // New storage format\n        _this.populate(newFormat.content);\n\n        yield Promise.all(newFormat.blobs.map( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (value) {\n            const dataExtra = yield readAndParse(storage, value);\n\n            _this.populate(dataExtra);\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()));\n      } else {\n        // Old storage format\n        _this.populate(data);\n      }\n    })();\n  }\n  /**\n   * Populate the directory with the given directory data.\n   * @param data - A JSON string containing serialized directory data\n   * @internal\n   */\n\n\n  populate(data) {\n    const stack = [];\n    stack.push([this.root, data]);\n\n    while (stack.length > 0) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const [currentSubDir, currentSubDirObject] = stack.pop();\n\n      if (currentSubDirObject.subdirectories) {\n        for (const [subdirName, subdirObject] of Object.entries(currentSubDirObject.subdirectories)) {\n          let newSubDir = currentSubDir.getSubDirectory(subdirName);\n\n          if (!newSubDir) {\n            newSubDir = new SubDirectory(this, this.runtime, this.serializer, posix.join(currentSubDir.absolutePath, subdirName));\n            currentSubDir.populateSubDirectory(subdirName, newSubDir);\n          }\n\n          stack.push([newSubDir, subdirObject]);\n        }\n      }\n\n      if (currentSubDirObject.storage) {\n        for (const [key, serializable] of Object.entries(currentSubDirObject.storage)) {\n          const localValue = this.makeLocal(key, currentSubDir.absolutePath, serializable);\n          currentSubDir.populateStorage(key, localValue);\n        }\n      }\n    }\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.processCore}\n   * @internal\n   */\n\n\n  processCore(message, local, localOpMetadata) {\n    if (message.type === MessageType.Operation) {\n      const op = message.contents;\n      const handler = this.messageHandlers.get(op.type);\n      assert(handler !== undefined, 0x00e\n      /* Missing message handler for message type */\n      );\n      handler.process(op, local, localOpMetadata);\n    }\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.rollback}\n   * @internal\n  */\n\n\n  rollback(content, localOpMetadata) {\n    const op = content;\n    const subdir = this.getWorkingDirectory(op.path);\n\n    if (subdir) {\n      subdir.rollback(op, localOpMetadata);\n    }\n  }\n  /**\n   * Converts the given relative path to absolute against the root.\n   * @param relativePath - The path to convert\n   */\n\n\n  makeAbsolute(relativePath) {\n    return posix.resolve(posix.sep, relativePath);\n  }\n  /**\n   * The remote ISerializableValue we're receiving (either as a result of a snapshot load or an incoming set op)\n   * will have the information we need to create a real object, but will not be the real object yet.  For example,\n   * we might know it's a map and the ID but not have the actual map or its data yet.  makeLocal's job\n   * is to convert that information into a real object for local usage.\n   * @param key - Key of element being converted\n   * @param absolutePath - Path of element being converted\n   * @param serializable - The remote information that we can convert into a real object\n   * @returns The local value that was produced\n   */\n\n\n  makeLocal(key, absolutePath, serializable) {\n    assert(serializable.type === ValueType[ValueType.Plain] || serializable.type === ValueType[ValueType.Shared], 0x1e4\n    /* \"Unexpected serializable type\" */\n    );\n    return this.localValueMaker.fromSerializable(serializable);\n  }\n  /**\n   * Set the message handlers for the directory.\n   */\n\n\n  setMessageHandlers() {\n    this.messageHandlers.set(\"clear\", {\n      process: (op, local, localOpMetadata) => {\n        const subdir = this.getWorkingDirectory(op.path);\n\n        if (subdir) {\n          subdir.processClearMessage(op, local, localOpMetadata);\n        }\n      },\n      submit: (op, localOpMetadata) => {\n        const subdir = this.getWorkingDirectory(op.path);\n\n        if (subdir) {\n          subdir.resubmitClearMessage(op, localOpMetadata);\n        }\n      }\n    });\n    this.messageHandlers.set(\"delete\", {\n      process: (op, local, localOpMetadata) => {\n        const subdir = this.getWorkingDirectory(op.path);\n\n        if (subdir) {\n          subdir.processDeleteMessage(op, local, localOpMetadata);\n        }\n      },\n      submit: (op, localOpMetadata) => {\n        const subdir = this.getWorkingDirectory(op.path);\n\n        if (subdir) {\n          subdir.resubmitKeyMessage(op, localOpMetadata);\n        }\n      }\n    });\n    this.messageHandlers.set(\"set\", {\n      process: (op, local, localOpMetadata) => {\n        const subdir = this.getWorkingDirectory(op.path);\n\n        if (subdir) {\n          const context = local ? undefined : this.makeLocal(op.key, op.path, op.value);\n          subdir.processSetMessage(op, context, local, localOpMetadata);\n        }\n      },\n      submit: (op, localOpMetadata) => {\n        const subdir = this.getWorkingDirectory(op.path);\n\n        if (subdir) {\n          subdir.resubmitKeyMessage(op, localOpMetadata);\n        }\n      }\n    });\n    this.messageHandlers.set(\"createSubDirectory\", {\n      process: (op, local, localOpMetadata) => {\n        const parentSubdir = this.getWorkingDirectory(op.path);\n\n        if (parentSubdir) {\n          parentSubdir.processCreateSubDirectoryMessage(op, local, localOpMetadata);\n        }\n      },\n      submit: (op, localOpMetadata) => {\n        const parentSubdir = this.getWorkingDirectory(op.path);\n\n        if (parentSubdir) {\n          // We don't reuse the metadata but send a new one on each submit.\n          parentSubdir.resubmitSubDirectoryMessage(op, localOpMetadata);\n        }\n      }\n    });\n    this.messageHandlers.set(\"deleteSubDirectory\", {\n      process: (op, local, localOpMetadata) => {\n        const parentSubdir = this.getWorkingDirectory(op.path);\n\n        if (parentSubdir) {\n          parentSubdir.processDeleteSubDirectoryMessage(op, local, localOpMetadata);\n        }\n      },\n      submit: (op, localOpMetadata) => {\n        const parentSubdir = this.getWorkingDirectory(op.path);\n\n        if (parentSubdir) {\n          // We don't reuse the metadata but send a new one on each submit.\n          parentSubdir.resubmitSubDirectoryMessage(op, localOpMetadata);\n        }\n      }\n    });\n  }\n  /**\n   * @internal\n   */\n\n\n  applyStashedOp() {\n    throw new Error(\"not implemented\");\n  }\n\n  serializeDirectory(root, serializer, telemetryContext) {\n    const MinValueSizeSeparateSnapshotBlob = 8 * 1024;\n    const builder = new SummaryTreeBuilder();\n    let counter = 0;\n    const blobs = [];\n    const stack = [];\n    const content = {};\n    stack.push([root, content]);\n\n    while (stack.length > 0) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const [currentSubDir, currentSubDirObject] = stack.pop();\n\n      for (const [key, value] of currentSubDir.getSerializedStorage(serializer)) {\n        if (!currentSubDirObject.storage) {\n          currentSubDirObject.storage = {};\n        }\n\n        const result = {\n          type: value.type,\n          // eslint-disable-next-line @typescript-eslint/ban-types\n          value: value.value && JSON.parse(value.value)\n        };\n\n        if (value.value && value.value.length >= MinValueSizeSeparateSnapshotBlob) {\n          const extraContent = {};\n          let largeContent = extraContent;\n\n          if (currentSubDir.absolutePath !== posix.sep) {\n            for (const dir of currentSubDir.absolutePath.substr(1).split(posix.sep)) {\n              const subDataObject = {};\n              largeContent.subdirectories = {\n                [dir]: subDataObject\n              };\n              largeContent = subDataObject;\n            }\n          }\n\n          largeContent.storage = {\n            [key]: result\n          };\n          const blobName = `blob${counter}`;\n          counter++;\n          blobs.push(blobName);\n          builder.addBlob(blobName, JSON.stringify(extraContent));\n        } else {\n          currentSubDirObject.storage[key] = result;\n        }\n      }\n\n      for (const [subdirName, subdir] of currentSubDir.subdirectories()) {\n        if (!currentSubDirObject.subdirectories) {\n          currentSubDirObject.subdirectories = {};\n        }\n\n        const subDataObject = {};\n        currentSubDirObject.subdirectories[subdirName] = subDataObject;\n        stack.push([subdir, subDataObject]);\n      }\n    }\n\n    const newFormat = {\n      blobs,\n      content\n    };\n    builder.addBlob(snapshotFileName, JSON.stringify(newFormat));\n    return builder.getSummaryTree();\n  }\n\n}\n\nfunction isKeyEditLocalOpMetadata(metadata) {\n  return metadata !== undefined && typeof metadata.pendingMessageId === \"number\" && metadata.type === \"edit\";\n}\n\nfunction isClearLocalOpMetadata(metadata) {\n  return metadata !== undefined && metadata.type === \"clear\" && typeof metadata.pendingMessageId === \"number\" && typeof metadata.previousStorage === \"object\";\n}\n\nfunction isSubDirLocalOpMetadata(metadata) {\n  return metadata !== undefined && typeof metadata.pendingMessageId === \"number\" && (metadata.type === \"createSubDir\" && typeof metadata.previouslyExisted === \"boolean\" || metadata.type === \"deleteSubDir\");\n}\n\nfunction isDirectoryLocalOpMetadata(metadata) {\n  return metadata !== undefined && typeof metadata.pendingMessageId === \"number\" && (metadata.type === \"edit\" || metadata.type === \"deleteSubDir\" || metadata.type === \"clear\" && typeof metadata.previousStorage === \"object\" || metadata.type === \"createSubDir\" && typeof metadata.previouslyExisted === \"boolean\");\n}\n/**\n * Node of the directory tree.\n * @sealed\n */\n\n\nclass SubDirectory extends TypedEventEmitter {\n  /**\n   * Constructor.\n   * @param directory - Reference back to the SharedDirectory to perform operations\n   * @param runtime - The data store runtime this directory is associated with\n   * @param serializer - The serializer to serialize / parse handles\n   * @param absolutePath - The absolute path of this IDirectory\n   */\n  constructor(directory, runtime, serializer, absolutePath) {\n    super();\n    this.directory = directory;\n    this.runtime = runtime;\n    this.serializer = serializer;\n    this.absolutePath = absolutePath;\n    /**\n     * Tells if the sub directory is deleted or not.\n     */\n\n    this._deleted = false;\n    /**\n     * String representation for the class.\n     */\n\n    this[_b] = \"SubDirectory\";\n    /**\n     * The in-memory data the directory is storing.\n     */\n\n    this._storage = new Map();\n    /**\n     * The subdirectories the directory is holding.\n     */\n\n    this._subdirectories = new Map();\n    /**\n     * Keys that have been modified locally but not yet ack'd from the server.\n     */\n\n    this.pendingKeys = new Map();\n    /**\n     * Subdirectories that have been modified locally but not yet ack'd from the server.\n     */\n\n    this.pendingSubDirectories = new Map();\n    /**\n     * This is used to assign a unique id to every outgoing operation and helps in tracking unack'd ops.\n     */\n\n    this.pendingMessageId = -1;\n    /**\n     * The pending ids of any clears that have been performed locally but not yet ack'd from the server\n     */\n\n    this.pendingClearMessageIds = [];\n  }\n\n  dispose(error) {\n    this._deleted = true;\n    this.emit(\"disposed\", this);\n  }\n  /**\n   * Unmark the deleted property when rolling back delete.\n   */\n\n\n  undispose() {\n    this._deleted = false;\n  }\n\n  get disposed() {\n    return this._deleted;\n  }\n\n  throwIfDisposed() {\n    if (this._deleted) {\n      throw new UsageError(\"Cannot access Disposed subDirectory\");\n    }\n  }\n  /**\n   * Checks whether the given key exists in this IDirectory.\n   * @param key - The key to check\n   * @returns True if the key exists, false otherwise\n   */\n\n\n  has(key) {\n    this.throwIfDisposed();\n    return this._storage.has(key);\n  }\n  /**\n   * {@inheritDoc IDirectory.get}\n   */\n\n\n  get(key) {\n    var _c;\n\n    this.throwIfDisposed();\n    return (_c = this._storage.get(key)) === null || _c === void 0 ? void 0 : _c.value;\n  }\n  /**\n   * {@inheritDoc IDirectory.set}\n   */\n\n\n  set(key, value) {\n    this.throwIfDisposed(); // Undefined/null keys can't be serialized to JSON in the manner we currently snapshot.\n\n    if (key === undefined || key === null) {\n      throw new Error(\"Undefined and null keys are not supported\");\n    } // Create a local value and serialize it.\n\n\n    const localValue = this.directory.localValueMaker.fromInMemory(value);\n    const serializableValue = makeSerializable(localValue, this.serializer, this.directory.handle); // Set the value locally.\n\n    const previousValue = this.setCore(key, localValue, true); // If we are not attached, don't submit the op.\n\n    if (!this.directory.isAttached()) {\n      return this;\n    }\n\n    const op = {\n      key,\n      path: this.absolutePath,\n      type: \"set\",\n      value: serializableValue\n    };\n    this.submitKeyMessage(op, previousValue);\n    return this;\n  }\n  /**\n   * {@inheritDoc IDirectory.countSubDirectory}\n   */\n\n\n  countSubDirectory() {\n    return this._subdirectories.size;\n  }\n  /**\n   * {@inheritDoc IDirectory.createSubDirectory}\n   */\n\n\n  createSubDirectory(subdirName) {\n    this.throwIfDisposed(); // Undefined/null subdirectory names can't be serialized to JSON in the manner we currently snapshot.\n\n    if (subdirName === undefined || subdirName === null) {\n      throw new Error(\"SubDirectory name may not be undefined or null\");\n    }\n\n    if (subdirName.includes(posix.sep)) {\n      throw new Error(`SubDirectory name may not contain ${posix.sep}`);\n    } // Create the sub directory locally first.\n\n\n    const isNew = this.createSubDirectoryCore(subdirName, true); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n    const subDir = this._subdirectories.get(subdirName); // If we are not attached, don't submit the op.\n\n\n    if (!this.directory.isAttached()) {\n      return subDir;\n    }\n\n    const op = {\n      path: this.absolutePath,\n      subdirName,\n      type: \"createSubDirectory\"\n    };\n    this.submitCreateSubDirectoryMessage(op, !isNew);\n    return subDir;\n  }\n  /**\n   * {@inheritDoc IDirectory.getSubDirectory}\n   */\n\n\n  getSubDirectory(subdirName) {\n    this.throwIfDisposed();\n    return this._subdirectories.get(subdirName);\n  }\n  /**\n   * {@inheritDoc IDirectory.hasSubDirectory}\n   */\n\n\n  hasSubDirectory(subdirName) {\n    this.throwIfDisposed();\n    return this._subdirectories.has(subdirName);\n  }\n  /**\n   * {@inheritDoc IDirectory.deleteSubDirectory}\n   */\n\n\n  deleteSubDirectory(subdirName) {\n    this.throwIfDisposed(); // Delete the sub directory locally first.\n\n    const subDir = this.deleteSubDirectoryCore(subdirName, true); // If we are not attached, don't submit the op.\n\n    if (!this.directory.isAttached()) {\n      return subDir !== undefined;\n    }\n\n    const op = {\n      path: this.absolutePath,\n      subdirName,\n      type: \"deleteSubDirectory\"\n    };\n    this.submitDeleteSubDirectoryMessage(op, subDir);\n    return subDir !== undefined;\n  }\n  /**\n   * {@inheritDoc IDirectory.subdirectories}\n   */\n\n\n  subdirectories() {\n    this.throwIfDisposed();\n    return this._subdirectories.entries();\n  }\n  /**\n   * {@inheritDoc IDirectory.getWorkingDirectory}\n   */\n\n\n  getWorkingDirectory(relativePath) {\n    this.throwIfDisposed();\n    return this.directory.getWorkingDirectory(this.makeAbsolute(relativePath));\n  }\n  /**\n   * Deletes the given key from within this IDirectory.\n   * @param key - The key to delete\n   * @returns True if the key existed and was deleted, false if it did not exist\n   */\n\n\n  delete(key) {\n    this.throwIfDisposed(); // Delete the key locally first.\n\n    const previousValue = this.deleteCore(key, true); // If we are not attached, don't submit the op.\n\n    if (!this.directory.isAttached()) {\n      return previousValue !== undefined;\n    }\n\n    const op = {\n      key,\n      path: this.absolutePath,\n      type: \"delete\"\n    };\n    this.submitKeyMessage(op, previousValue);\n    return previousValue !== undefined;\n  }\n  /**\n   * Deletes all keys from within this IDirectory.\n   */\n\n\n  clear() {\n    this.throwIfDisposed(); // If we are not attached, don't submit the op.\n\n    if (!this.directory.isAttached()) {\n      this.clearCore(true);\n      return;\n    }\n\n    const copy = new Map(this._storage);\n    this.clearCore(true);\n    const op = {\n      path: this.absolutePath,\n      type: \"clear\"\n    };\n    this.submitClearMessage(op, copy);\n  }\n  /**\n   * Issue a callback on each entry under this IDirectory.\n   * @param callback - Callback to issue\n   */\n\n\n  forEach(callback) {\n    this.throwIfDisposed();\n\n    this._storage.forEach((localValue, key, map) => {\n      callback(localValue.value, key, map);\n    });\n  }\n  /**\n   * The number of entries under this IDirectory.\n   */\n\n\n  get size() {\n    this.throwIfDisposed();\n    return this._storage.size;\n  }\n  /**\n   * Get an iterator over the entries under this IDirectory.\n   * @returns The iterator\n   */\n\n\n  entries() {\n    this.throwIfDisposed();\n\n    const localEntriesIterator = this._storage.entries();\n\n    const iterator = {\n      next() {\n        const nextVal = localEntriesIterator.next();\n\n        if (nextVal.done) {\n          return {\n            value: undefined,\n            done: true\n          };\n        } else {\n          // Unpack the stored value\n          return {\n            value: [nextVal.value[0], nextVal.value[1].value],\n            done: false\n          };\n        }\n      },\n\n      [Symbol.iterator]() {\n        return this;\n      }\n\n    };\n    return iterator;\n  }\n  /**\n   * Get an iterator over the keys under this IDirectory.\n   * @returns The iterator\n   */\n\n\n  keys() {\n    this.throwIfDisposed();\n    return this._storage.keys();\n  }\n  /**\n   * Get an iterator over the values under this IDirectory.\n   * @returns The iterator\n   */\n\n\n  values() {\n    this.throwIfDisposed();\n\n    const localValuesIterator = this._storage.values();\n\n    const iterator = {\n      next() {\n        const nextVal = localValuesIterator.next();\n\n        if (nextVal.done) {\n          return {\n            value: undefined,\n            done: true\n          };\n        } else {\n          // Unpack the stored value\n          return {\n            value: nextVal.value.value,\n            done: false\n          };\n        }\n      },\n\n      [Symbol.iterator]() {\n        return this;\n      }\n\n    };\n    return iterator;\n  }\n  /**\n   * Get an iterator over the entries under this IDirectory.\n   * @returns The iterator\n   */\n\n\n  [(_b = Symbol.toStringTag, Symbol.iterator)]() {\n    this.throwIfDisposed();\n    return this.entries();\n  }\n  /**\n   * Process a clear operation.\n   * @param op - The op to process\n   * @param local - Whether the message originated from the local client\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @internal\n   */\n\n\n  processClearMessage(op, local, localOpMetadata) {\n    this.throwIfDisposed();\n\n    if (local) {\n      assert(isClearLocalOpMetadata(localOpMetadata), 0x00f\n      /* pendingMessageId is missing from the local client's operation */\n      );\n      const pendingClearMessageId = this.pendingClearMessageIds.shift();\n      assert(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x32a\n      /* pendingMessageId does not match */\n      );\n      return;\n    }\n\n    this.clearExceptPendingKeys();\n  }\n  /**\n   * Process a delete operation.\n   * @param op - The op to process\n   * @param local - Whether the message originated from the local client\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @internal\n   */\n\n\n  processDeleteMessage(op, local, localOpMetadata) {\n    this.throwIfDisposed();\n\n    if (!this.needProcessStorageOperation(op, local, localOpMetadata)) {\n      return;\n    }\n\n    this.deleteCore(op.key, local);\n  }\n  /**\n   * Process a set operation.\n   * @param op - The op to process\n   * @param local - Whether the message originated from the local client\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @internal\n   */\n\n\n  processSetMessage(op, context, local, localOpMetadata) {\n    this.throwIfDisposed();\n\n    if (!this.needProcessStorageOperation(op, local, localOpMetadata)) {\n      return;\n    } // needProcessStorageOperation should have returned false if local is true\n    // so we can assume context is not undefined\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    this.setCore(op.key, context, local);\n  }\n  /**\n   * Process a create subdirectory operation.\n   * @param op - The op to process\n   * @param local - Whether the message originated from the local client\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @internal\n   */\n\n\n  processCreateSubDirectoryMessage(op, local, localOpMetadata) {\n    this.throwIfDisposed();\n\n    if (!this.needProcessSubDirectoryOperation(op, local, localOpMetadata)) {\n      return;\n    }\n\n    this.createSubDirectoryCore(op.subdirName, local);\n  }\n  /**\n   * Process a delete subdirectory operation.\n   * @param op - The op to process\n   * @param local - Whether the message originated from the local client\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @internal\n   */\n\n\n  processDeleteSubDirectoryMessage(op, local, localOpMetadata) {\n    this.throwIfDisposed();\n\n    if (!this.needProcessSubDirectoryOperation(op, local, localOpMetadata)) {\n      return;\n    }\n\n    this.deleteSubDirectoryCore(op.subdirName, local);\n  }\n  /**\n   * Submit a clear operation.\n   * @param op - The operation\n   */\n\n\n  submitClearMessage(op, previousValue) {\n    this.throwIfDisposed();\n    const pendingMsgId = ++this.pendingMessageId;\n    this.pendingClearMessageIds.push(pendingMsgId);\n    const metadata = {\n      type: \"clear\",\n      pendingMessageId: pendingMsgId,\n      previousStorage: previousValue\n    };\n    this.directory.submitDirectoryMessage(op, metadata);\n  }\n  /**\n   * Resubmit a clear operation.\n   * @param op - The operation\n   * @internal\n   */\n\n\n  resubmitClearMessage(op, localOpMetadata) {\n    assert(isClearLocalOpMetadata(localOpMetadata), 0x32b\n    /* Invalid localOpMetadata for clear */\n    ); // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n\n    const pendingClearMessageId = this.pendingClearMessageIds.shift();\n    assert(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x32c\n    /* pendingMessageId does not match */\n    );\n    this.submitClearMessage(op, localOpMetadata.previousStorage);\n  }\n  /**\n   * Get a new pending message id for the op and cache it to track the pending op\n   */\n\n\n  getKeyMessageId(op) {\n    // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n    const pendingMessageId = ++this.pendingMessageId;\n    const pendingMessageIds = this.pendingKeys.get(op.key);\n\n    if (pendingMessageIds !== undefined) {\n      pendingMessageIds.push(pendingMessageId);\n    } else {\n      this.pendingKeys.set(op.key, [pendingMessageId]);\n    }\n\n    return pendingMessageId;\n  }\n  /**\n   * Submit a key operation.\n   * @param op - The operation\n   * @param previousValue - The value of the key before this op\n   */\n\n\n  submitKeyMessage(op, previousValue) {\n    this.throwIfDisposed();\n    const pendingMessageId = this.getKeyMessageId(op);\n    const localMetadata = {\n      type: \"edit\",\n      pendingMessageId,\n      previousValue\n    };\n    this.directory.submitDirectoryMessage(op, localMetadata);\n  }\n  /**\n   * Submit a key message to remote clients based on a previous submit.\n   * @param op - The map key message\n   * @param localOpMetadata - Metadata from the previous submit\n   * @internal\n   */\n\n\n  resubmitKeyMessage(op, localOpMetadata) {\n    assert(isKeyEditLocalOpMetadata(localOpMetadata), 0x32d\n    /* Invalid localOpMetadata in submit */\n    ); // clear the old pending message id\n\n    const pendingMessageIds = this.pendingKeys.get(op.key);\n    assert(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x32e\n    /* Unexpected pending message received */\n    );\n    pendingMessageIds.shift();\n\n    if (pendingMessageIds.length === 0) {\n      this.pendingKeys.delete(op.key);\n    }\n\n    this.submitKeyMessage(op, localOpMetadata.previousValue);\n  }\n  /**\n   * Get a new pending message id for the op and cache it to track the pending op\n   */\n\n\n  getSubDirMessageId(op) {\n    // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n    const newMessageId = ++this.pendingMessageId;\n    const pendingMessageIds = this.pendingSubDirectories.get(op.subdirName);\n\n    if (pendingMessageIds !== undefined) {\n      pendingMessageIds.push(newMessageId);\n    } else {\n      this.pendingSubDirectories.set(op.subdirName, [newMessageId]);\n    }\n\n    return newMessageId;\n  }\n  /**\n   * Submit a create subdirectory operation.\n   * @param op - The operation\n   * @param prevExisted - Whether the subdirectory existed before the op\n   */\n\n\n  submitCreateSubDirectoryMessage(op, prevExisted) {\n    this.throwIfDisposed();\n    const newMessageId = this.getSubDirMessageId(op);\n    const localOpMetadata = {\n      type: \"createSubDir\",\n      pendingMessageId: newMessageId,\n      previouslyExisted: prevExisted\n    };\n    this.directory.submitDirectoryMessage(op, localOpMetadata);\n  }\n  /**\n   * Submit a delete subdirectory operation.\n   * @param op - The operation\n   * @param subDir - Any subdirectory deleted by the op\n   */\n\n\n  submitDeleteSubDirectoryMessage(op, subDir) {\n    this.throwIfDisposed();\n    const newMessageId = this.getSubDirMessageId(op);\n    const localOpMetadata = {\n      type: \"deleteSubDir\",\n      pendingMessageId: newMessageId,\n      subDirectory: subDir\n    };\n    this.directory.submitDirectoryMessage(op, localOpMetadata);\n  }\n  /**\n   * Submit a subdirectory operation again\n   * @param op - The operation\n   * @param localOpMetadata - metadata submitted with the op originally\n   * @internal\n   */\n\n\n  resubmitSubDirectoryMessage(op, localOpMetadata) {\n    assert(isSubDirLocalOpMetadata(localOpMetadata), 0x32f\n    /* Invalid localOpMetadata for sub directory op */\n    ); // clear the old pending message id\n\n    const pendingMessageIds = this.pendingSubDirectories.get(op.subdirName);\n    assert(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x330\n    /* Unexpected pending message received */\n    );\n    pendingMessageIds.shift();\n\n    if (pendingMessageIds.length === 0) {\n      this.pendingSubDirectories.delete(op.subdirName);\n    }\n\n    if (localOpMetadata.type === \"createSubDir\") {\n      this.submitCreateSubDirectoryMessage(op, localOpMetadata.previouslyExisted);\n    } else {\n      this.submitDeleteSubDirectoryMessage(op, localOpMetadata.subDirectory);\n    }\n  }\n  /**\n   * Get the storage of this subdirectory in a serializable format, to be used in snapshotting.\n   * @param serializer - The serializer to use to serialize handles in its values.\n   * @returns The JSONable string representing the storage of this subdirectory\n   * @internal\n   */\n\n\n  *getSerializedStorage(serializer) {\n    this.throwIfDisposed();\n\n    for (const [key, localValue] of this._storage) {\n      const value = localValue.makeSerialized(serializer, this.directory.handle);\n      const res = [key, value];\n      yield res;\n    }\n  }\n  /**\n   * Populate a key value in this subdirectory's storage, to be used when loading from snapshot.\n   * @param key - The key to populate\n   * @param localValue - The local value to populate into it\n   * @internal\n   */\n\n\n  populateStorage(key, localValue) {\n    this.throwIfDisposed();\n\n    this._storage.set(key, localValue);\n  }\n  /**\n   * Populate a subdirectory into this subdirectory, to be used when loading from snapshot.\n   * @param subdirName - The name of the subdirectory to add\n   * @param newSubDir - The new subdirectory to add\n   * @internal\n   */\n\n\n  populateSubDirectory(subdirName, newSubDir) {\n    this.throwIfDisposed();\n\n    this._subdirectories.set(subdirName, newSubDir);\n  }\n  /**\n   * Retrieve the local value at the given key.  This is used to get value type information stashed on the local\n   * value so op handlers can be retrieved\n   * @param key - The key to retrieve from\n   * @returns The local value\n   * @internal\n   */\n\n\n  getLocalValue(key) {\n    this.throwIfDisposed();\n    return this._storage.get(key);\n  }\n  /**\n   * Remove the pendingMessageId from the map tracking it on rollback\n   * @param map - map tracking the pending messages\n   * @param key - key of the edit in the op\n   */\n\n\n  rollbackPendingMessageId(map, key, pendingMessageId) {\n    const pendingMessageIds = map.get(key);\n    const lastPendingMessageId = pendingMessageIds === null || pendingMessageIds === void 0 ? void 0 : pendingMessageIds.pop();\n\n    if (!pendingMessageIds || lastPendingMessageId !== pendingMessageId) {\n      throw new Error(\"Rollback op does not match last pending\");\n    }\n\n    if (pendingMessageIds.length === 0) {\n      map.delete(key);\n    }\n  }\n  /**\n   * Rollback a local op\n   * @param op - The operation to rollback\n   * @param localOpMetadata - The local metadata associated with the op.\n   */\n\n\n  rollback(op, localOpMetadata) {\n    if (!isDirectoryLocalOpMetadata(localOpMetadata)) {\n      throw new Error(\"Invalid localOpMetadata\");\n    }\n\n    if (op.type === \"clear\" && localOpMetadata.type === \"clear\") {\n      localOpMetadata.previousStorage.forEach((localValue, key) => {\n        this.setCore(key, localValue, true);\n      });\n      const lastPendingClearId = this.pendingClearMessageIds.pop();\n\n      if (lastPendingClearId === undefined || lastPendingClearId !== localOpMetadata.pendingMessageId) {\n        throw new Error(\"Rollback op does match last clear\");\n      }\n    } else if ((op.type === \"delete\" || op.type === \"set\") && localOpMetadata.type === \"edit\") {\n      if (localOpMetadata.previousValue === undefined) {\n        this.deleteCore(op.key, true);\n      } else {\n        this.setCore(op.key, localOpMetadata.previousValue, true);\n      }\n\n      this.rollbackPendingMessageId(this.pendingKeys, op.key, localOpMetadata.pendingMessageId);\n    } else if (op.type === \"createSubDirectory\" && localOpMetadata.type === \"createSubDir\") {\n      if (!localOpMetadata.previouslyExisted) {\n        this.deleteSubDirectoryCore(op.subdirName, true);\n      }\n\n      this.rollbackPendingMessageId(this.pendingSubDirectories, op.subdirName, localOpMetadata.pendingMessageId);\n    } else if (op.type === \"deleteSubDirectory\" && localOpMetadata.type === \"deleteSubDir\") {\n      if (localOpMetadata.subDirectory !== undefined) {\n        this.undeleteSubDirectoryTree(localOpMetadata.subDirectory); // don't need to register events because deleting never unregistered\n\n        this._subdirectories.set(op.subdirName, localOpMetadata.subDirectory);\n\n        this.emit(\"subDirectoryCreated\", op.subdirName, true, this);\n      }\n\n      this.rollbackPendingMessageId(this.pendingSubDirectories, op.subdirName, localOpMetadata.pendingMessageId);\n    } else {\n      throw new Error(\"Unsupported op for rollback\");\n    }\n  }\n  /**\n   * Converts the given relative path into an absolute path.\n   * @param path - Relative path to convert\n   * @returns The equivalent absolute path\n   */\n\n\n  makeAbsolute(relativePath) {\n    return posix.resolve(this.absolutePath, relativePath);\n  }\n  /**\n   * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should\n   * not process the incoming operation.\n   * @param op - Operation to check\n   * @param local - Whether the operation originated from the local client\n   * @param localOpMetadata - For local client ops, this is the metadata that was submitted with the op.\n   * For ops from a remote client, this will be undefined.\n   * @returns True if the operation should be processed, false otherwise\n   */\n\n\n  needProcessStorageOperation(op, local, localOpMetadata) {\n    if (this.pendingClearMessageIds.length > 0) {\n      if (local) {\n        assert(localOpMetadata !== undefined && isKeyEditLocalOpMetadata(localOpMetadata) && localOpMetadata.pendingMessageId < this.pendingClearMessageIds[0], 0x010\n        /* \"Received out of order storage op when there is an unackd clear message\" */\n        );\n      } // If I have a NACK clear, we can ignore all ops.\n\n\n      return false;\n    }\n\n    const pendingKeyMessageId = this.pendingKeys.get(op.key);\n\n    if (pendingKeyMessageId !== undefined) {\n      // Found an NACK op, clear it from the directory if the latest sequence number in the directory\n      // match the message's and don't process the op.\n      if (local) {\n        assert(localOpMetadata !== undefined && isKeyEditLocalOpMetadata(localOpMetadata), 0x011\n        /* pendingMessageId is missing from the local client's operation */\n        );\n        const pendingMessageIds = this.pendingKeys.get(op.key);\n        assert(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x331\n        /* Unexpected pending message received */\n        );\n        pendingMessageIds.shift();\n\n        if (pendingMessageIds.length === 0) {\n          this.pendingKeys.delete(op.key);\n        }\n      }\n\n      return false;\n    } // If we don't have a NACK op on the key, we need to process the remote ops.\n\n\n    return !local;\n  }\n  /**\n   * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should\n   * not process the incoming operation.\n   * @param op - Operation to check\n   * @param local - Whether the message originated from the local client\n   * @param message - The message\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @returns True if the operation should be processed, false otherwise\n   */\n\n\n  needProcessSubDirectoryOperation(op, local, localOpMetadata) {\n    const pendingSubDirectoryMessageId = this.pendingSubDirectories.get(op.subdirName);\n\n    if (pendingSubDirectoryMessageId !== undefined) {\n      if (local) {\n        assert(isSubDirLocalOpMetadata(localOpMetadata), 0x012\n        /* pendingMessageId is missing from the local client's operation */\n        );\n        const pendingMessageIds = this.pendingSubDirectories.get(op.subdirName);\n        assert(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x332\n        /* Unexpected pending message received */\n        );\n        pendingMessageIds.shift();\n\n        if (pendingMessageIds.length === 0) {\n          this.pendingSubDirectories.delete(op.subdirName);\n        }\n      }\n\n      return false;\n    }\n\n    return !local;\n  }\n  /**\n   * Clear all keys in memory in response to a remote clear, but retain keys we have modified but not yet been ack'd.\n   */\n\n\n  clearExceptPendingKeys() {\n    // Assuming the pendingKeys is small and the map is large\n    // we will get the value for the pendingKeys and clear the map\n    const temp = new Map();\n    this.pendingKeys.forEach((value, key, map) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      temp.set(key, this._storage.get(key));\n    });\n    this.clearCore(false);\n    temp.forEach((value, key, map) => {\n      this.setCore(key, value, true);\n    });\n  }\n  /**\n   * Clear implementation used for both locally sourced clears as well as incoming remote clears.\n   * @param local - Whether the message originated from the local client\n   */\n\n\n  clearCore(local) {\n    this._storage.clear();\n\n    this.directory.emit(\"clear\", local, this.directory);\n  }\n  /**\n   * Delete implementation used for both locally sourced deletes as well as incoming remote deletes.\n   * @param key - The key being deleted\n   * @param local - Whether the message originated from the local client\n   * @returns Previous local value of the key if it existed, undefined if it did not exist\n   */\n\n\n  deleteCore(key, local) {\n    const previousLocalValue = this._storage.get(key);\n\n    const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;\n\n    const successfullyRemoved = this._storage.delete(key);\n\n    if (successfullyRemoved) {\n      const event = {\n        key,\n        path: this.absolutePath,\n        previousValue\n      };\n      this.directory.emit(\"valueChanged\", event, local, this.directory);\n      const containedEvent = {\n        key,\n        previousValue\n      };\n      this.emit(\"containedValueChanged\", containedEvent, local, this);\n    }\n\n    return previousLocalValue;\n  }\n  /**\n   * Set implementation used for both locally sourced sets as well as incoming remote sets.\n   * @param key - The key being set\n   * @param value - The value being set\n   * @param local - Whether the message originated from the local client\n   * @returns Previous local value of the key, if any\n   */\n\n\n  setCore(key, value, local) {\n    const previousLocalValue = this._storage.get(key);\n\n    const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;\n\n    this._storage.set(key, value);\n\n    const event = {\n      key,\n      path: this.absolutePath,\n      previousValue\n    };\n    this.directory.emit(\"valueChanged\", event, local, this.directory);\n    const containedEvent = {\n      key,\n      previousValue\n    };\n    this.emit(\"containedValueChanged\", containedEvent, local, this);\n    return previousLocalValue;\n  }\n  /**\n   * Create subdirectory implementation used for both locally sourced creation as well as incoming remote creation.\n   * @param subdirName - The name of the subdirectory being created\n   * @param local - Whether the message originated from the local client\n   * @returns - True if is newly created, false if it already existed.\n   */\n\n\n  createSubDirectoryCore(subdirName, local) {\n    if (!this._subdirectories.has(subdirName)) {\n      const absolutePath = posix.join(this.absolutePath, subdirName);\n      const subDir = new SubDirectory(this.directory, this.runtime, this.serializer, absolutePath);\n      this.registerEventsOnSubDirectory(subDir, subdirName);\n\n      this._subdirectories.set(subdirName, subDir);\n\n      this.emit(\"subDirectoryCreated\", subdirName, local, this);\n      return true;\n    }\n\n    return false;\n  }\n\n  registerEventsOnSubDirectory(subDirectory, subDirName) {\n    subDirectory.on(\"subDirectoryCreated\", (relativePath, local) => {\n      this.emit(\"subDirectoryCreated\", posix.join(subDirName, relativePath), local, this);\n    });\n    subDirectory.on(\"subDirectoryDeleted\", (relativePath, local) => {\n      this.emit(\"subDirectoryDeleted\", posix.join(subDirName, relativePath), local, this);\n    });\n  }\n  /**\n   * Delete subdirectory implementation used for both locally sourced creation as well as incoming remote creation.\n   * @param subdirName - The name of the subdirectory being deleted\n   * @param local - Whether the message originated from the local client\n   */\n\n\n  deleteSubDirectoryCore(subdirName, local) {\n    const previousValue = this._subdirectories.get(subdirName); // This should make the subdirectory structure unreachable so it can be GC'd and won't appear in snapshots\n    // Might want to consider cleaning out the structure more exhaustively though? But not when rollback.\n\n\n    if (previousValue !== undefined) {\n      this._subdirectories.delete(subdirName);\n\n      this.disposeSubDirectoryTree(previousValue);\n      this.emit(\"subDirectoryDeleted\", subdirName, local, this);\n    }\n\n    return previousValue;\n  }\n\n  disposeSubDirectoryTree(directory) {\n    if (!directory) {\n      return;\n    } // Dispose the subdirectory tree. This will dispose the subdirectories from bottom to top.\n\n\n    const subDirectories = directory.subdirectories();\n\n    for (const [_, subDirectory] of subDirectories) {\n      this.disposeSubDirectoryTree(subDirectory);\n    }\n\n    if (typeof directory.dispose === \"function\") {\n      directory.dispose();\n    }\n  }\n\n  undeleteSubDirectoryTree(directory) {\n    // Restore deleted subdirectory tree. This will unmark \"deleted\" from the subdirectories from bottom to top.\n    for (const [_, subDirectory] of this._subdirectories.entries()) {\n      this.undeleteSubDirectoryTree(subDirectory);\n    }\n\n    directory.undispose();\n  }\n\n} //# sourceMappingURL=directory.js.map","map":null,"metadata":{},"sourceType":"module"}