{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, gitHashFile, IsoBuffer, Uint8ArrayToString, unreachableCase } from \"@fluidframework/common-utils\";\nimport { getGitMode, getGitType } from \"@fluidframework/protocol-base\";\nimport { SummaryType } from \"@fluidframework/protocol-definitions\";\n/**\n * Recursively writes summary tree as individual summary blobs.\n */\n\nexport class SummaryTreeUploadManager {\n  constructor(manager, blobsShaCache, getPreviousFullSnapshot) {\n    this.manager = manager;\n    this.blobsShaCache = blobsShaCache;\n    this.getPreviousFullSnapshot = getPreviousFullSnapshot;\n  }\n\n  writeSummaryTree(summaryTree, parentHandle, summaryType, sequenceNumber) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const previousFullSnapshot = yield _this.getPreviousFullSnapshot(parentHandle);\n      return _this.writeSummaryTreeCore(summaryTree, previousFullSnapshot !== null && previousFullSnapshot !== void 0 ? previousFullSnapshot : undefined);\n    })();\n  }\n\n  writeSummaryTreeCore(summaryTree, previousFullSnapshot) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const entries = yield Promise.all(Object.keys(summaryTree.tree).map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (key) {\n          const entry = summaryTree.tree[key];\n          const pathHandle = yield _this2.writeSummaryTreeObject(entry, previousFullSnapshot);\n          const treeEntry = {\n            mode: getGitMode(entry),\n            path: encodeURIComponent(key),\n            sha: pathHandle,\n            type: getGitType(entry)\n          };\n          return treeEntry;\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      const treeHandle = yield _this2.manager.createGitTree({\n        tree: entries\n      });\n      return treeHandle.sha;\n    })();\n  }\n\n  writeSummaryTreeObject(object, previousFullSnapshot) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      switch (object.type) {\n        case SummaryType.Blob:\n          {\n            return _this3.writeSummaryBlob(object.content);\n          }\n\n        case SummaryType.Handle:\n          {\n            if (previousFullSnapshot === undefined) {\n              throw Error(\"Parent summary does not exist to reference by handle.\");\n            }\n\n            return _this3.getIdFromPath(object.handleType, object.handle, previousFullSnapshot);\n          }\n\n        case SummaryType.Tree:\n          {\n            return _this3.writeSummaryTreeCore(object, previousFullSnapshot);\n          }\n\n        case SummaryType.Attachment:\n          {\n            return object.id;\n          }\n\n        default:\n          unreachableCase(object, `Unknown type: ${object.type}`);\n      }\n    })();\n  }\n\n  writeSummaryBlob(content) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        parsedContent,\n        encoding\n      } = typeof content === \"string\" ? {\n        parsedContent: content,\n        encoding: \"utf-8\"\n      } : {\n        parsedContent: Uint8ArrayToString(content, \"base64\"),\n        encoding: \"base64\"\n      }; // The gitHashFile would return the same hash as returned by the server as blob.sha\n\n      const hash = yield gitHashFile(IsoBuffer.from(parsedContent, encoding));\n\n      if (!_this4.blobsShaCache.has(hash)) {\n        _this4.blobsShaCache.set(hash, \"\");\n\n        const blob = yield _this4.manager.createBlob(parsedContent, encoding);\n        assert(hash === blob.sha, 0x0b6\n        /* \"Blob.sha and hash do not match!!\" */\n        );\n      }\n\n      return hash;\n    })();\n  }\n\n  getIdFromPath(handleType, handlePath, previousFullSnapshot) {\n    const path = handlePath.split(\"/\").map(part => decodeURIComponent(part));\n\n    if (path[0] === \"\") {\n      // root of tree should be unnamed\n      path.shift();\n    }\n\n    if (path.length === 0) {\n      return previousFullSnapshot.id;\n    }\n\n    return this.getIdFromPathCore(handleType, path, previousFullSnapshot);\n  }\n\n  getIdFromPathCore(handleType, path,\n  /** Previous snapshot, subtree relative to this path part */\n  previousSnapshot) {\n    var _a;\n\n    assert(path.length > 0, 0x0b3\n    /* \"Expected at least 1 path part\" */\n    );\n    const key = path[0];\n\n    if (path.length === 1) {\n      switch (handleType) {\n        case SummaryType.Blob:\n          {\n            const tryId = previousSnapshot.blobs[key];\n            assert(!!tryId, 0x0b4\n            /* \"Parent summary does not have blob handle for specified path.\" */\n            );\n            return tryId;\n          }\n\n        case SummaryType.Tree:\n          {\n            const tryId = (_a = previousSnapshot.trees[key]) === null || _a === void 0 ? void 0 : _a.id;\n            assert(!!tryId, 0x0b5\n            /* \"Parent summary does not have tree handle for specified path.\" */\n            );\n            return tryId;\n          }\n\n        default:\n          throw Error(`Unexpected handle summary object type: \"${handleType}\".`);\n      }\n    }\n\n    return this.getIdFromPathCore(handleType, path.slice(1), previousSnapshot.trees[key]);\n  }\n\n} //# sourceMappingURL=summaryTreeUploadManager.js.map","map":null,"metadata":{},"sourceType":"module"}