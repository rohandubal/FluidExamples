{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nexport class Stack {\n  constructor() {\n    this.items = [];\n  }\n\n  push(val) {\n    this.items.push(val);\n  }\n\n  empty() {\n    return this.items.length === 0;\n  }\n\n  top() {\n    return this.items[this.items.length - 1];\n  }\n\n  pop() {\n    return this.items.pop();\n  }\n\n}\nexport function ListRemoveEntry(entry) {\n  if (entry === undefined) {\n    return undefined;\n  } else if (entry.isHead) {\n    return undefined;\n  } else {\n    entry.next.prev = entry.prev;\n    entry.prev.next = entry.next;\n  }\n\n  return entry;\n}\n\nfunction ListMakeEntry(data) {\n  return new List(false, data);\n}\n\nexport function ListMakeHead() {\n  return new List(true, undefined);\n}\nexport class List {\n  constructor(isHead, data) {\n    this.isHead = isHead;\n    this.data = data;\n    this.prev = this;\n    this.next = this;\n  }\n\n  clear() {\n    if (this.isHead) {\n      this.prev = this;\n      this.next = this;\n    }\n  }\n\n  add(data) {\n    const entry = ListMakeEntry(data);\n    this.prev.next = entry;\n    entry.next = this;\n    entry.prev = this.prev;\n    this.prev = entry;\n    return entry;\n  }\n\n  dequeue() {\n    if (!this.empty()) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const removedEntry = ListRemoveEntry(this.next);\n      return removedEntry.data;\n    }\n  }\n\n  enqueue(data) {\n    return this.add(data);\n  }\n\n  walk(fn) {\n    for (let entry = this.next; !entry.isHead; entry = entry.next) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      fn(entry.data, entry);\n    }\n  }\n\n  some(fn, rev) {\n    const rtn = [];\n    const start = rev ? this.prev : this.next;\n\n    for (let entry = start; !entry.isHead; entry = rev ? entry.prev : entry.next) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const data = entry.data;\n\n      if (fn(data, entry)) {\n        if (rev) {\n          // preserve list order when in reverse\n          rtn.unshift(data);\n        } else {\n          rtn.push(data);\n        }\n      }\n    }\n\n    return rtn;\n  }\n\n  count() {\n    let entry;\n    let i;\n    entry = this.next;\n\n    for (i = 0; !entry.isHead; i++) {\n      entry = entry.next;\n    }\n\n    return i;\n  }\n\n  first() {\n    if (!this.empty()) {\n      return this.next.data;\n    }\n  }\n\n  last() {\n    if (!this.empty()) {\n      return this.prev.data;\n    }\n  }\n\n  empty() {\n    return this.next === this;\n  }\n  /**\n   * @deprecated - use unshift\n   */\n\n\n  push(data) {\n    this.unshift(data);\n  }\n\n  unshift(data) {\n    const entry = ListMakeEntry(data);\n    entry.data = data;\n    entry.isHead = false;\n    entry.next = this.next;\n    entry.prev = this;\n    this.next = entry;\n    entry.next.prev = entry;\n  }\n\n  [Symbol.iterator]() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let node = this;\n    const iterator = {\n      next() {\n        while (node && node.next.isHead === false) {\n          node = node.next;\n\n          if (node.data !== undefined) {\n            return {\n              value: node.data,\n              done: false\n            };\n          }\n        }\n\n        return {\n          value: undefined,\n          done: true\n        };\n      },\n\n      [Symbol.iterator]() {\n        return this;\n      }\n\n    };\n    return iterator;\n  }\n\n}\nexport class Heap {\n  constructor(a, comp) {\n    this.comp = comp;\n    this.L = [comp.min];\n\n    for (let i = 0, len = a.length; i < len; i++) {\n      this.add(a[i]);\n    }\n  }\n\n  count() {\n    return this.L.length - 1;\n  }\n\n  peek() {\n    return this.L[1];\n  }\n\n  get() {\n    const x = this.L[1];\n    this.L[1] = this.L[this.count()];\n    this.L.pop();\n    this.fixDown(1);\n    return x;\n  }\n\n  add(x) {\n    this.L.push(x);\n    this.fixup(this.count());\n  }\n  /* eslint-disable no-bitwise */\n\n\n  fixup(k) {\n    let _k = k;\n\n    while (_k > 1 && this.comp.compare(this.L[_k >> 1], this.L[_k]) > 0) {\n      const tmp = this.L[_k >> 1];\n      this.L[_k >> 1] = this.L[_k];\n      this.L[_k] = tmp;\n      _k = _k >> 1;\n    }\n  }\n\n  fixDown(k) {\n    let _k = k;\n\n    while (_k << 1 <= this.count()) {\n      let j = _k << 1;\n\n      if (j < this.count() && this.comp.compare(this.L[j], this.L[j + 1]) > 0) {\n        j++;\n      }\n\n      if (this.comp.compare(this.L[_k], this.L[j]) <= 0) {\n        break;\n      }\n\n      const tmp = this.L[_k];\n      this.L[_k] = this.L[j];\n      this.L[j] = tmp;\n      _k = j;\n    }\n  }\n\n}\nexport const RBColor = {\n  RED: 0,\n  BLACK: 1\n};\nexport class RedBlackTree {\n  constructor(compareKeys, aug) {\n    this.compareKeys = compareKeys;\n    this.aug = aug;\n  }\n\n  makeNode(key, data, color, size) {\n    return {\n      key,\n      data,\n      color,\n      size\n    };\n  }\n\n  isRed(node) {\n    return !!node && node.color === RBColor.RED;\n  }\n\n  nodeSize(node) {\n    return node ? node.size : 0;\n  }\n\n  size() {\n    return this.nodeSize(this.root);\n  }\n\n  isEmpty() {\n    return !this.root;\n  }\n\n  get(key) {\n    if (key !== undefined) {\n      return this.nodeGet(this.root, key);\n    }\n  }\n\n  nodeGet(node, key) {\n    let _node = node;\n\n    while (_node) {\n      const cmp = this.compareKeys(key, _node.key);\n\n      if (cmp < 0) {\n        _node = _node.left;\n      } else if (cmp > 0) {\n        _node = _node.right;\n      } else {\n        return _node;\n      }\n    }\n  }\n\n  contains(key) {\n    return this.get(key);\n  }\n\n  gather(key, matcher) {\n    const results = [];\n\n    if (key !== undefined) {\n      this.nodeGather(this.root, results, key, matcher);\n    }\n\n    return results;\n  }\n\n  nodeGather(node, results, key, matcher) {\n    if (node) {\n      if (matcher.continueSubtree(node.left, key)) {\n        this.nodeGather(node.left, results, key, matcher);\n      }\n\n      if (matcher.matchNode(node, key)) {\n        results.push(node);\n      }\n\n      if (matcher.continueSubtree(node.right, key)) {\n        this.nodeGather(node.right, results, key, matcher);\n      }\n    }\n  }\n\n  walkExactMatchesForward(compareFn, actionFn, continueLeftFn, continueRightFn) {\n    this.nodeWalkExactMatchesForward(this.root, compareFn, actionFn, continueLeftFn, continueRightFn);\n  }\n\n  nodeWalkExactMatchesForward(node, compareFn, actionFn, continueLeftFn, continueRightFn) {\n    if (!node) {\n      return;\n    }\n\n    const result = compareFn(node);\n\n    if (continueLeftFn(result)) {\n      this.nodeWalkExactMatchesForward(node.left, compareFn, actionFn, continueLeftFn, continueRightFn);\n    }\n\n    if (result === 0) {\n      actionFn(node);\n    }\n\n    if (continueRightFn(result)) {\n      this.nodeWalkExactMatchesForward(node.right, compareFn, actionFn, continueLeftFn, continueRightFn);\n    }\n  }\n\n  walkExactMatchesBackward(compareFn, actionFn, continueLeftFn, continueRightFn) {\n    this.nodeWalkExactMatchesBackward(this.root, compareFn, actionFn, continueLeftFn, continueRightFn);\n  }\n\n  nodeWalkExactMatchesBackward(node, compareFn, actionFn, continueLeftFn, continueRightFn) {\n    if (!node) {\n      return;\n    }\n\n    const result = compareFn(node);\n\n    if (continueRightFn(result)) {\n      this.nodeWalkExactMatchesBackward(node.right, compareFn, actionFn, continueLeftFn, continueRightFn);\n    }\n\n    if (result === 0) {\n      actionFn(node);\n    }\n\n    if (continueLeftFn(result)) {\n      this.nodeWalkExactMatchesBackward(node.left, compareFn, actionFn, continueLeftFn, continueRightFn);\n    }\n  }\n\n  put(key, data, conflict) {\n    if (key !== undefined) {\n      if (data === undefined) {\n        this.remove(key);\n      } else {\n        this.root = this.nodePut(this.root, key, data, conflict);\n        this.root.color = RBColor.BLACK;\n      }\n    }\n  }\n\n  nodePut(node, key, data, conflict) {\n    let _node = node;\n\n    if (!_node) {\n      return this.makeNode(key, data, RBColor.RED, 1);\n    } else {\n      const cmp = this.compareKeys(key, _node.key);\n\n      if (cmp < 0) {\n        _node.left = this.nodePut(_node.left, key, data, conflict);\n      } else if (cmp > 0) {\n        _node.right = this.nodePut(_node.right, key, data, conflict);\n      } else {\n        if (conflict) {\n          const kd = conflict(key, _node.key, data, _node.data);\n\n          if (kd.key) {\n            _node.key = kd.key;\n          }\n\n          if (kd.data) {\n            _node.data = kd.data;\n          } else {\n            _node.data = data;\n          }\n        } else {\n          _node.data = data;\n        }\n      }\n\n      if (this.isRed(_node.right) && !this.isRed(_node.left)) {\n        _node = this.rotateLeft(_node);\n      } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n      if (this.isRed(_node.left) && this.isRed(_node.left.left)) {\n        _node = this.rotateRight(_node);\n      }\n\n      if (this.isRed(_node.left) && this.isRed(_node.right)) {\n        this.flipColors(_node);\n      }\n\n      _node.size = this.nodeSize(_node.left) + this.nodeSize(_node.right) + 1;\n\n      if (this.aug) {\n        this.updateLocal(_node);\n      }\n\n      return _node;\n    }\n  }\n\n  updateLocal(node) {\n    if (this.aug) {\n      if (this.isRed(node.left)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.aug.update(node.left);\n      }\n\n      if (this.isRed(node.right)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.aug.update(node.right);\n      }\n\n      this.aug.update(node);\n    }\n  }\n\n  nodeRemoveMin(node) {\n    let _node = node;\n\n    if (_node.left) {\n      if (!this.isRed(_node.left) && !this.isRed(_node.left.left)) {\n        _node = this.moveRedLeft(_node);\n      } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n      _node.left = this.nodeRemoveMin(_node.left);\n      return this.balance(_node);\n    }\n  }\n\n  remove(key) {\n    if (key !== undefined) {\n      if (!this.contains(key)) {\n        return;\n      }\n\n      this.removeExisting(key);\n    } // TODO: error on undefined key\n\n  }\n\n  removeExisting(key) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    if (!this.isRed(this.root.left) && !this.isRed(this.root.right)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.root.color = RBColor.RED;\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    this.root = this.nodeRemove(this.root, key);\n  }\n\n  nodeRemove(node, key) {\n    let _node = node;\n\n    if (this.compareKeys(key, _node.key) < 0) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      if (!this.isRed(_node.left) && !this.isRed(_node.left.left)) {\n        _node = this.moveRedLeft(_node);\n      } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n      _node.left = this.nodeRemove(_node.left, key);\n    } else {\n      if (this.isRed(_node.left)) {\n        _node = this.rotateRight(_node);\n      }\n\n      if (this.compareKeys(key, _node.key) === 0 && !_node.right) {\n        return undefined;\n      } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n      if (!this.isRed(_node.right) && !this.isRed(_node.right.left)) {\n        _node = this.moveRedRight(_node);\n      }\n\n      if (this.compareKeys(key, _node.key) === 0) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const subtreeMin = this.nodeMin(_node.right);\n        _node.key = subtreeMin.key;\n        _node.data = subtreeMin.data; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        _node.right = this.nodeRemoveMin(_node.right);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        _node.right = this.nodeRemove(_node.right, key);\n      }\n    }\n\n    return this.balance(_node);\n  }\n\n  floor(key) {\n    if (!this.isEmpty()) {\n      return this.nodeFloor(this.root, key);\n    }\n  }\n\n  nodeFloor(node, key) {\n    if (node) {\n      const cmp = this.compareKeys(key, node.key);\n\n      if (cmp === 0) {\n        return node;\n      } else if (cmp < 0) {\n        return this.nodeFloor(node.left, key);\n      } else {\n        const rightFloor = this.nodeFloor(node.right, key);\n\n        if (rightFloor) {\n          return rightFloor;\n        } else {\n          return node;\n        }\n      }\n    }\n  }\n\n  ceil(key) {\n    if (!this.isEmpty()) {\n      return this.nodeCeil(this.root, key);\n    }\n  }\n\n  nodeCeil(node, key) {\n    if (node) {\n      const cmp = this.compareKeys(key, node.key);\n\n      if (cmp === 0) {\n        return node;\n      } else if (cmp > 0) {\n        return this.nodeCeil(node.right, key);\n      } else {\n        const leftCeil = this.nodeCeil(node.left, key);\n\n        if (leftCeil) {\n          return leftCeil;\n        } else {\n          return node;\n        }\n      }\n    }\n  }\n\n  min() {\n    if (this.root) {\n      return this.nodeMin(this.root);\n    }\n  }\n\n  nodeMin(node) {\n    if (!node.left) {\n      return node;\n    } else {\n      return this.nodeMin(node.left);\n    }\n  }\n\n  max() {\n    if (this.root) {\n      return this.nodeMax(this.root);\n    }\n  }\n\n  nodeMax(node) {\n    if (!node.right) {\n      return node;\n    } else {\n      return this.nodeMax(node.right);\n    }\n  }\n\n  rotateRight(node) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const leftChild = node.left;\n    node.left = leftChild.right;\n    leftChild.right = node;\n    leftChild.color = leftChild.right.color;\n    leftChild.right.color = RBColor.RED;\n    leftChild.size = node.size;\n    node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n\n    if (this.aug) {\n      this.updateLocal(node);\n      this.updateLocal(leftChild);\n    }\n\n    return leftChild;\n  }\n\n  rotateLeft(node) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const rightChild = node.right;\n    node.right = rightChild.left;\n    rightChild.left = node;\n    rightChild.color = rightChild.left.color;\n    rightChild.left.color = RBColor.RED;\n    rightChild.size = node.size;\n    node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n\n    if (this.aug) {\n      this.updateLocal(node);\n      this.updateLocal(rightChild);\n    }\n\n    return rightChild;\n  }\n\n  oppositeColor(c) {\n    return c === RBColor.BLACK ? RBColor.RED : RBColor.BLACK;\n  }\n\n  flipColors(node) {\n    node.color = this.oppositeColor(node.color); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n    node.left.color = this.oppositeColor(node.left.color); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n    node.right.color = this.oppositeColor(node.right.color);\n  }\n\n  moveRedLeft(node) {\n    let _node = node;\n    this.flipColors(_node); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n    if (this.isRed(_node.right.left)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      _node.right = this.rotateRight(_node.right);\n      _node = this.rotateLeft(_node);\n      this.flipColors(_node);\n    }\n\n    return _node;\n  }\n\n  moveRedRight(node) {\n    let _node = node;\n    this.flipColors(_node); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n    if (this.isRed(_node.left.left)) {\n      _node = this.rotateRight(_node);\n      this.flipColors(_node);\n    }\n\n    return _node;\n  }\n\n  balance(input) {\n    let node = input;\n\n    if (this.isRed(node.right)) {\n      node = this.rotateLeft(node);\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    if (this.isRed(node.left) && this.isRed(node.left.left)) {\n      node = this.rotateRight(node);\n    }\n\n    if (this.isRed(node.left) && this.isRed(node.right)) {\n      this.flipColors(node);\n    }\n\n    node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n\n    if (this.aug) {\n      this.aug.update(node);\n    }\n\n    return node;\n  }\n\n  mapRange(action, accum, start, end) {\n    this.nodeMap(this.root, action, start, end);\n  }\n\n  map(action, accum) {\n    // TODO: optimize to avoid comparisons\n    this.nodeMap(this.root, action, accum);\n  }\n\n  keys() {\n    const keyList = [];\n    const actions = {\n      showStructure: true,\n      infix: node => {\n        keyList.push(node.key);\n        return true;\n      }\n    };\n    this.walk(actions);\n    return keyList;\n  }\n  /**\n   * Depth-first traversal with custom action; if action returns\n   * false, traversal is halted.\n   * @param action - action to apply to each node\n   */\n\n\n  walk(actions) {\n    this.nodeWalk(this.root, actions);\n  }\n\n  walkBackward(actions) {\n    this.nodeWalkBackward(this.root, actions);\n  }\n\n  nodeWalk(node, actions) {\n    let go = true;\n\n    if (node) {\n      if (actions.pre) {\n        if (actions.showStructure || node.color === RBColor.BLACK) {\n          go = actions.pre(node);\n        }\n      }\n\n      if (node.left) {\n        go = this.nodeWalk(node.left, actions);\n      }\n\n      if (go && actions.infix) {\n        if (actions.showStructure || node.color === RBColor.BLACK) {\n          go = actions.infix(node);\n        }\n      }\n\n      if (go) {\n        go = this.nodeWalk(node.right, actions);\n      }\n\n      if (go && actions.post) {\n        if (actions.showStructure || node.color === RBColor.BLACK) {\n          go = actions.post(node);\n        }\n      }\n    }\n\n    return go;\n  }\n\n  nodeWalkBackward(node, actions) {\n    let go = true;\n\n    if (node) {\n      if (actions.pre) {\n        if (actions.showStructure || node.color === RBColor.BLACK) {\n          go = actions.pre(node);\n        }\n      }\n\n      if (node.right) {\n        go = this.nodeWalkBackward(node.right, actions);\n      }\n\n      if (go && actions.infix) {\n        if (actions.showStructure || node.color === RBColor.BLACK) {\n          go = actions.infix(node);\n        }\n      }\n\n      if (go) {\n        go = this.nodeWalkBackward(node.left, actions);\n      }\n\n      if (go && actions.post) {\n        if (actions.showStructure || node.color === RBColor.BLACK) {\n          go = actions.post(node);\n        }\n      }\n    }\n\n    return go;\n  }\n\n  nodeMap(node, action, accum, start, end) {\n    let _start = start;\n    let _end = end;\n\n    if (!node) {\n      return true;\n    }\n\n    if (_start === undefined) {\n      _start = this.nodeMin(node).key;\n    }\n\n    if (_end === undefined) {\n      _end = this.nodeMax(node).key;\n    }\n\n    const cmpStart = this.compareKeys(_start, node.key);\n    const cmpEnd = this.compareKeys(_end, node.key);\n    let go = true;\n\n    if (cmpStart < 0) {\n      go = this.nodeMap(node.left, action, accum, _start, _end);\n    }\n\n    if (go && cmpStart <= 0 && cmpEnd >= 0) {\n      // REVIEW: test for black node here\n      go = action(node, accum);\n    }\n\n    if (go && cmpEnd > 0) {\n      go = this.nodeMap(node.right, action, accum, _start, _end);\n    }\n\n    return go;\n  }\n\n}\nexport const integerRangeToString = range => `[${range.start},${range.end})`;\n\nconst intervalComparer = (a, b) => a.compare(b);\n\nexport class IntervalTree {\n  constructor() {\n    this.intervals = new RedBlackTree(intervalComparer, this);\n  }\n\n  remove(x) {\n    this.intervals.remove(x);\n  }\n\n  removeExisting(x) {\n    this.intervals.removeExisting(x);\n  }\n\n  put(x, conflict) {\n    let rbConflict;\n\n    if (conflict) {\n      rbConflict = (key, currentKey) => {\n        const ival = conflict(key, currentKey);\n        return {\n          key: ival\n        };\n      };\n    }\n\n    this.intervals.put(x, {\n      minmax: x.clone()\n    }, rbConflict);\n  }\n\n  map(fn) {\n    const actions = {\n      infix: node => {\n        fn(node.key);\n        return true;\n      },\n      showStructure: true\n    };\n    this.intervals.walk(actions);\n  }\n\n  mapUntil(fn) {\n    const actions = {\n      infix: node => {\n        return fn(node.key);\n      },\n      showStructure: true\n    };\n    this.intervals.walk(actions);\n  }\n\n  mapBackward(fn) {\n    const actions = {\n      infix: node => {\n        fn(node.key);\n        return true;\n      },\n      showStructure: true\n    };\n    this.intervals.walkBackward(actions);\n  } // TODO: toString()\n\n\n  match(x) {\n    return this.intervals.gather(x, this);\n  }\n\n  matchNode(node, key) {\n    return !!node && node.key.overlaps(key);\n  }\n\n  continueSubtree(node, key) {\n    return !!node && node.data.minmax.overlaps(key);\n  }\n\n  update(node) {\n    if (node.left && node.right) {\n      node.data.minmax = node.key.union(node.left.data.minmax.union(node.right.data.minmax));\n    } else {\n      if (node.left) {\n        node.data.minmax = node.key.union(node.left.data.minmax);\n      } else if (node.right) {\n        node.data.minmax = node.key.union(node.right.data.minmax);\n      } else {\n        node.data.minmax = node.key.clone();\n      }\n    }\n  }\n\n}\nexport class TST {\n  constructor() {\n    this.n = 0;\n  }\n\n  size() {\n    return this.n;\n  }\n\n  contains(key) {\n    return this.get(key);\n  }\n\n  get(key) {\n    const x = this.nodeGet(this.root, key, 0);\n\n    if (x === undefined) {\n      return undefined;\n    }\n\n    return x.val;\n  }\n\n  nodeGet(x, key, d) {\n    if (x === undefined) {\n      return undefined;\n    }\n\n    const c = key.charAt(d);\n\n    if (c < x.c) {\n      return this.nodeGet(x.left, key, d);\n    } else if (c > x.c) {\n      return this.nodeGet(x.right, key, d);\n    } else if (d < key.length - 1) {\n      return this.nodeGet(x.mid, key, d + 1);\n    } else {\n      return x;\n    }\n  }\n\n  put(key, val) {\n    if (!this.contains(key)) {\n      this.n++;\n    }\n\n    this.root = this.nodePut(this.root, key, val, 0);\n  }\n\n  nodePut(x, key, val, d) {\n    let _x = x;\n    const c = key.charAt(d);\n\n    if (_x === undefined) {\n      _x = {\n        c\n      };\n    }\n\n    if (c < _x.c) {\n      _x.left = this.nodePut(_x.left, key, val, d);\n    } else if (c > _x.c) {\n      _x.right = this.nodePut(_x.right, key, val, d);\n    } else if (d < key.length - 1) {\n      _x.mid = this.nodePut(_x.mid, key, val, d + 1);\n    } else {\n      _x.val = val;\n    }\n\n    return _x;\n  }\n\n  neighbors(text, distance = 2) {\n    let q = [];\n    this.nodeProximity(this.root, {\n      text: \"\"\n    }, 0, text, distance, q);\n    q = q.filter(value => value.text.length > 0);\n    return q;\n  }\n\n  keysWithPrefix(text) {\n    const q = [];\n    const x = this.nodeGet(this.root, text, 0);\n\n    if (x === undefined) {\n      return q;\n    }\n\n    if (x.val !== undefined) {\n      q.push(text);\n    }\n\n    this.collect(x.mid, {\n      text\n    }, q);\n    return q;\n  }\n\n  collect(x, prefix, q) {\n    if (x === undefined) {\n      return;\n    }\n\n    this.collect(x.left, prefix, q);\n\n    if (x.val !== undefined) {\n      q.push(prefix.text + x.c);\n    }\n\n    this.collect(x.mid, {\n      text: prefix.text + x.c\n    }, q);\n    this.collect(x.right, prefix, q);\n  }\n\n  mapNode(x, prefix, fn) {\n    if (x === undefined) {\n      return;\n    }\n\n    const key = prefix.text + x.c;\n    this.mapNode(x.left, prefix, fn);\n\n    if (x.val) {\n      fn(key, x.val);\n    }\n\n    this.mapNode(x.mid, {\n      text: key\n    }, fn);\n    this.mapNode(x.right, prefix, fn);\n  }\n\n  map(fn) {\n    this.mapNode(this.root, {\n      text: \"\"\n    }, fn);\n  }\n\n  pairsWithPrefix(text) {\n    const q = [];\n    const x = this.nodeGet(this.root, text, 0);\n\n    if (x === undefined) {\n      return q;\n    }\n\n    if (x.val !== undefined) {\n      q.push({\n        key: text,\n        val: x.val\n      });\n    }\n\n    this.collectPairs(x.mid, {\n      text\n    }, q);\n    return q;\n  }\n\n  collectPairs(x, prefix, q) {\n    if (x === undefined) {\n      return;\n    }\n\n    this.collectPairs(x.left, prefix, q);\n\n    if (x.val !== undefined) {\n      q.push({\n        key: prefix.text + x.c,\n        val: x.val\n      });\n    }\n\n    this.collectPairs(x.mid, {\n      text: prefix.text + x.c\n    }, q);\n    this.collectPairs(x.right, prefix, q);\n  }\n\n  nodeProximity(x, prefix, d, pattern, distance, q) {\n    if (x === undefined || distance < 0) {\n      return;\n    }\n\n    const c = pattern.charAt(d);\n\n    if (distance > 0 || c < x.c) {\n      this.nodeProximity(x.left, prefix, d, pattern, distance, q);\n    }\n\n    if (x.val !== undefined) {\n      const remD = distance - (pattern.length - d);\n\n      if (remD >= 0) {\n        let invD = distance;\n\n        if (c !== x.c) {\n          invD--;\n        }\n\n        q.push({\n          text: prefix.text + x.c,\n          val: x.val,\n          invDistance: invD\n        });\n      }\n    }\n\n    const recurD = d < pattern.length - 1 ? d + 1 : d;\n\n    if (c === x.c) {\n      this.nodeProximity(x.mid, {\n        text: prefix.text + x.c\n      }, recurD, pattern, distance, q);\n    } else {\n      this.nodeProximity(x.mid, {\n        text: prefix.text + x.c\n      }, recurD, pattern, distance - 1, q);\n    }\n\n    if (distance > 0 || c > x.c) {\n      this.nodeProximity(x.right, prefix, d, pattern, distance, q);\n    }\n  }\n\n} //# sourceMappingURL=collections.js.map","map":null,"metadata":{},"sourceType":"module"}