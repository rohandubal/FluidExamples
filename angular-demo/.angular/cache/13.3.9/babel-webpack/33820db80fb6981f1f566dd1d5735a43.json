{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { SnapshotLegacy } from \"./snapshotlegacy\";\n/**\n * Returns true if the given 'spec' is an IJSONSegmentWithMergeInfo.\n */\n\nexport function hasMergeInfo(spec) {\n  return !!spec && typeof spec === \"object\" && \"json\" in spec;\n}\nexport function serializeAsMinSupportedVersion(path, chunk, logger, options, serializer, bind) {\n  let targetChuck;\n\n  if (chunk.version !== undefined) {\n    logger.send({\n      eventName: \"MergeTreeChunk:serializeAsMinSupportedVersion\",\n      category: \"generic\",\n      fromChunkVersion: chunk.version,\n      toChunkVersion: undefined\n    });\n  }\n\n  switch (chunk.version) {\n    case undefined:\n      targetChuck = chunk;\n      targetChuck.headerMetadata = buildHeaderMetadataForLegacyChunk(path, targetChuck, options);\n      break;\n\n    case \"1\":\n      const chunkV1 = chunk;\n      const headerMetadata = path === SnapshotLegacy.header ? chunkV1.headerMetadata : undefined;\n      targetChuck = {\n        version: undefined,\n        chunkStartSegmentIndex: chunkV1.startIndex,\n        chunkLengthChars: chunkV1.length,\n        chunkSegmentCount: chunkV1.segmentCount,\n        segmentTexts: chunkV1.segments,\n        totalLengthChars: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.totalLength,\n        totalSegmentCount: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.totalSegmentCount,\n        chunkSequenceNumber: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.sequenceNumber,\n        chunkMinSequenceNumber: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.minSequenceNumber,\n        headerMetadata\n      };\n      break;\n\n    default:\n      throw new Error(`Unsupported chunk path: ${path} version: ${chunk.version}`);\n  }\n\n  return serializer.stringify(targetChuck, bind);\n}\nexport function serializeAsMaxSupportedVersion(path, chunk, logger, options, serializer, bind) {\n  const targetChuck = toLatestVersion(path, chunk, logger, options);\n  return serializer.stringify(targetChuck, bind);\n}\nexport function toLatestVersion(path, chunk, logger, options) {\n  switch (chunk.version) {\n    case undefined:\n      {\n        const chunkLegacy = chunk;\n        return {\n          version: \"1\",\n          length: chunkLegacy.chunkLengthChars,\n          segmentCount: chunkLegacy.chunkSegmentCount,\n          headerMetadata: buildHeaderMetadataForLegacyChunk(path, chunkLegacy, options),\n          segments: chunkLegacy.segmentTexts,\n          startIndex: chunkLegacy.chunkStartSegmentIndex\n        };\n      }\n\n    case \"1\":\n      return chunk;\n\n    default:\n      throw new Error(`Unsupported chunk path: ${path} version: ${chunk.version}`);\n  }\n}\n\nfunction buildHeaderMetadataForLegacyChunk(path, chunk, options) {\n  if (path === SnapshotLegacy.header) {\n    if (chunk.headerMetadata !== undefined) {\n      return chunk.headerMetadata;\n    }\n\n    const chunkIds = [{\n      id: SnapshotLegacy.header\n    }];\n\n    if (chunk.chunkLengthChars < chunk.totalLengthChars) {\n      chunkIds.push({\n        id: SnapshotLegacy.body\n      });\n    }\n\n    return {\n      orderedChunkMetadata: chunkIds,\n      minSequenceNumber: chunk.chunkMinSequenceNumber,\n      sequenceNumber: chunk.chunkSequenceNumber,\n      totalLength: chunk.totalLengthChars,\n      totalSegmentCount: chunk.totalSegmentCount\n    };\n  }\n\n  return undefined;\n} //# sourceMappingURL=snapshotChunks.js.map","map":null,"metadata":{},"sourceType":"module"}