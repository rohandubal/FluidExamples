{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { ensureFluidResolvedUrl, getDocAttributesFromProtocolSummary, getQuorumValuesFromProtocolSummary, RateLimiter } from \"@fluidframework/driver-utils\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nimport { DocumentService } from \"./documentService\";\nimport { RouterliciousOrdererRestWrapper } from \"./restWrapper\";\nimport { convertSummaryToCreateNewSummary } from \"./createNewUtils\";\nimport { parseFluidUrl, replaceDocumentIdInPath, getDiscoveredFluidResolvedUrl } from \"./urlUtils\";\nimport { InMemoryCache } from \"./cache\";\nimport { pkgVersion as driverVersion } from \"./packageVersion\";\nconst defaultRouterliciousDriverPolicies = {\n  enablePrefetch: true,\n  maxConcurrentStorageRequests: 100,\n  maxConcurrentOrdererRequests: 100,\n  aggregateBlobsSmallerThanBytes: undefined,\n  enableDiscovery: false,\n  enableWholeSummaryUpload: false,\n  enableRestLess: true\n};\n/**\n * Factory for creating the routerlicious document service. Use this if you want to\n * use the routerlicious implementation.\n */\n\nexport class RouterliciousDocumentServiceFactory {\n  constructor(tokenProvider, driverPolicies = {}) {\n    this.tokenProvider = tokenProvider;\n    this.protocolName = \"fluid:\";\n    this.blobCache = new InMemoryCache();\n    this.snapshotTreeCache = new InMemoryCache();\n    this.driverPolicies = Object.assign(Object.assign({}, defaultRouterliciousDriverPolicies), driverPolicies);\n  }\n  /**\n   * {@inheritDoc @fluidframework/driver-definitions#IDocumentServiceFactory.createContainer}\n   *\n   * @throws {@link DocumentPostCreateError}\n   * If an exception is thrown while invoking the provided {@link ITokenProvider.documentPostCreateCallback}.\n   */\n\n\n  createContainer(createNewSummary, resolvedUrl, logger, clientIsSummarizer) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      ensureFluidResolvedUrl(resolvedUrl);\n\n      if (createNewSummary === undefined) {\n        throw new Error(\"Empty file summary creation isn't supported in this driver.\");\n      }\n\n      assert(!!resolvedUrl.endpoints.ordererUrl, 0x0b2\n      /* \"Missing orderer URL!\" */\n      );\n      let parsedUrl = parseFluidUrl(resolvedUrl.url);\n\n      if (!parsedUrl.pathname) {\n        throw new Error(\"Parsed url should contain tenant and doc Id!!\");\n      }\n\n      const [, tenantId] = parsedUrl.pathname.split(\"/\");\n      const protocolSummary = createNewSummary.tree[\".protocol\"];\n      const appSummary = createNewSummary.tree[\".app\"];\n\n      if (!(protocolSummary && appSummary)) {\n        throw new Error(\"Protocol and App Summary required in the full summary\");\n      }\n\n      const documentAttributes = getDocAttributesFromProtocolSummary(protocolSummary);\n      const quorumValues = getQuorumValuesFromProtocolSummary(protocolSummary);\n      const logger2 = ChildLogger.create(logger, \"RouterliciousDriver\");\n      const rateLimiter = new RateLimiter(_this.driverPolicies.maxConcurrentOrdererRequests);\n      const ordererRestWrapper = yield RouterliciousOrdererRestWrapper.load(tenantId, undefined, _this.tokenProvider, logger2, rateLimiter, _this.driverPolicies.enableRestLess, resolvedUrl.endpoints.ordererUrl); // @TODO: Remove returned \"string\" type when removing back-compat code\n\n      const res = yield ordererRestWrapper.post(`/documents/${tenantId}`, {\n        summary: convertSummaryToCreateNewSummary(appSummary),\n        sequenceNumber: documentAttributes.sequenceNumber,\n        values: quorumValues,\n        enableDiscovery: _this.driverPolicies.enableDiscovery,\n        generateToken: _this.tokenProvider.documentPostCreateCallback !== undefined\n      }); // For supporting backward compatibility, when the request has generateToken === true, it will return\n      // an object instead of string\n      // @TODO: Remove the logic when no need to support back-compat\n\n      let documentId;\n      let token;\n      let session;\n\n      if (typeof res === \"string\") {\n        documentId = res;\n      } else {\n        documentId = res.id;\n        token = res.token;\n        session = _this.driverPolicies.enableDiscovery ? res.session : undefined;\n      }\n\n      parsedUrl = parseFluidUrl(resolvedUrl.url); // @TODO: Remove token from the condition, checking the documentPostCreateCallback !== undefined\n      // is sufficient to determine if the token will be undefined or not.\n\n      if (token && _this.tokenProvider.documentPostCreateCallback !== undefined) {\n        try {\n          yield _this.tokenProvider.documentPostCreateCallback(documentId, token);\n        } catch (error) {\n          throw new DocumentPostCreateError(error);\n        }\n      }\n\n      parsedUrl.set(\"pathname\", replaceDocumentIdInPath(parsedUrl.pathname, documentId));\n      const deltaStorageUrl = resolvedUrl.endpoints.deltaStorageUrl;\n\n      if (!deltaStorageUrl) {\n        throw new Error(`All endpoints urls must be provided. [deltaStorageUrl:${deltaStorageUrl}]`);\n      }\n\n      const parsedDeltaStorageUrl = new URL(deltaStorageUrl);\n      parsedDeltaStorageUrl.pathname = replaceDocumentIdInPath(parsedDeltaStorageUrl.pathname, documentId);\n      return _this.createDocumentService(Object.assign(Object.assign({}, resolvedUrl), {\n        url: parsedUrl.toString(),\n        id: documentId,\n        endpoints: Object.assign(Object.assign({}, resolvedUrl.endpoints), {\n          deltaStorageUrl: parsedDeltaStorageUrl.toString()\n        })\n      }), logger, clientIsSummarizer, session);\n    })();\n  }\n  /**\n   * {@inheritDoc @fluidframework/driver-definitions#IDocumentServiceFactory.createDocumentService}\n   *\n   * @returns Routerlicious document service.\n   */\n\n\n  createDocumentService(resolvedUrl, logger, clientIsSummarizer, session) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      ensureFluidResolvedUrl(resolvedUrl);\n      const parsedUrl = parseFluidUrl(resolvedUrl.url);\n      const [, tenantId, documentId] = parsedUrl.pathname.split(\"/\");\n\n      if (!documentId || !tenantId) {\n        throw new Error(`Couldn't parse documentId and/or tenantId. [documentId:${documentId}][tenantId:${tenantId}]`);\n      }\n\n      const logger2 = ChildLogger.create(logger, \"RouterliciousDriver\", {\n        all: {\n          driverVersion\n        }\n      });\n\n      const discoverFluidResolvedUrl = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* () {\n          if (!_this2.driverPolicies.enableDiscovery) {\n            return resolvedUrl;\n          }\n\n          const rateLimiter = new RateLimiter(_this2.driverPolicies.maxConcurrentOrdererRequests);\n          const ordererRestWrapper = yield RouterliciousOrdererRestWrapper.load(tenantId, documentId, _this2.tokenProvider, logger2, rateLimiter, _this2.driverPolicies.enableRestLess, resolvedUrl.endpoints.ordererUrl); // The service responds with the current document session associated with the container.\n\n          const discoveredSession = yield ordererRestWrapper.get(`/documents/${tenantId}/session/${documentId}`);\n          return getDiscoveredFluidResolvedUrl(resolvedUrl, discoveredSession);\n        });\n\n        return function discoverFluidResolvedUrl() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      const fluidResolvedUrl = session !== undefined ? getDiscoveredFluidResolvedUrl(resolvedUrl, session) : yield discoverFluidResolvedUrl();\n      const storageUrl = fluidResolvedUrl.endpoints.storageUrl;\n      const ordererUrl = fluidResolvedUrl.endpoints.ordererUrl;\n      const deltaStorageUrl = fluidResolvedUrl.endpoints.deltaStorageUrl;\n\n      if (!ordererUrl || !deltaStorageUrl) {\n        throw new Error(`All endpoints urls must be provided. [ordererUrl:${ordererUrl}][deltaStorageUrl:${deltaStorageUrl}]`);\n      }\n\n      return new DocumentService(fluidResolvedUrl, ordererUrl, deltaStorageUrl, storageUrl, logger2, _this2.tokenProvider, tenantId, documentId, _this2.driverPolicies, _this2.blobCache, _this2.snapshotTreeCache, discoverFluidResolvedUrl);\n    })();\n  }\n\n}\n/**\n * Error returned by {@link RouterliciousDocumentServiceFactory.createContainer} when an error is thrown\n * in {@link ITokenProvider.documentPostCreateCallback}.\n * It is the consumer's responsibility to ensure that any state related to container creation is appropriately\n * cleaned up in the event of failure.\n * This includes the document itself, which will have been created by the time this error was thrown.\n *\n * @remarks TODO: examples of suggested actions for recovery.\n * - How would a user delete the created document?\n * - What would a retry pattern look like here?\n */\n\nexport class DocumentPostCreateError extends Error {\n  constructor(\n  /**\n   * Inner error being wrapped.\n   */\n  innerError) {\n    super(innerError.message);\n    this.innerError = innerError;\n    this.name = \"DocumentPostCreateError\";\n  }\n\n  get stack() {\n    return this.innerError.stack;\n  }\n\n} //# sourceMappingURL=documentServiceFactory.js.map","map":null,"metadata":{},"sourceType":"module"}