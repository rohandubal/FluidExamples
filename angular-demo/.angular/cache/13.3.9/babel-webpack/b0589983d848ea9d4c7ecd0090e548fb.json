{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { performance } from \"@fluidframework/common-utils\";\nimport { TelemetryLogger } from \"@fluidframework/telemetry-utils\";\n/**\n * DeltaScheduler is responsible for the scheduling of inbound delta queue in cases where there\n * is more than one op a particular run of the queue. It does not schedule if there is just one\n * op or just one batch in the run. It does the following two things:\n * 1. If the ops have been processed for more than a specific amount of time, it pauses the queue\n *    and calls setTimeout to schedule a resume of the queue. This ensures that we don't block\n *    the JS thread for a long time processing ops synchronously (for example, when catching up\n *    ops right after boot or catching up ops / delayed realizing data stores by summarizer).\n * 2. If we scheduled a particular run of the queue, it logs telemetry for the number of ops\n *    processed, the time and number of turns it took to process the ops.\n */\n\nexport let DeltaScheduler = /*#__PURE__*/(() => {\n  class DeltaScheduler {\n    constructor(deltaManager, logger) {\n      this.logger = logger; // The increase in time for processing ops after each turn.\n\n      this.processingTimeIncrement = 10;\n      this.currentAllowedProcessingTimeForTurn = DeltaScheduler.processingTime; // This keeps track of the number of times inbound queue has been scheduled. After a particular\n      // count, we log telemetry for the number of ops processed, the time and number of turns it took\n      // to process the ops.\n\n      this.schedulingCount = 0;\n      this.deltaManager = deltaManager;\n      this.deltaManager.inbound.on(\"idle\", () => {\n        this.inboundQueueIdle();\n      });\n    }\n\n    batchBegin(message) {\n      if (!this.processingStartTime) {\n        this.processingStartTime = performance.now();\n      }\n\n      if (this.schedulingLog === undefined && this.schedulingCount % 500 === 0) {\n        // Every 500th time we are scheduling the inbound queue, we log telemetry for the\n        // number of ops processed, the time and number of turns it took to process the ops.\n        this.schedulingLog = {\n          opsRemainingToProcess: 0,\n          numberOfTurns: 1,\n          totalProcessingTime: 0,\n          numberOfBatchesProcessed: 0,\n          firstSequenceNumber: message.sequenceNumber,\n          lastSequenceNumber: message.sequenceNumber,\n          startTime: performance.now()\n        };\n      }\n    }\n\n    batchEnd(message) {\n      if (this.schedulingLog) {\n        this.schedulingLog.numberOfBatchesProcessed++;\n        this.schedulingLog.lastSequenceNumber = message.sequenceNumber;\n        this.schedulingLog.opsRemainingToProcess = this.deltaManager.inbound.length;\n      }\n\n      if (this.shouldRunScheduler()) {\n        const currentTime = performance.now(); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const elapsedTime = currentTime - this.processingStartTime;\n\n        if (elapsedTime > this.currentAllowedProcessingTimeForTurn) {\n          // We have processed ops for more than the total processing time. So, pause the\n          // queue, yield the thread and schedule a resume.\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          this.deltaManager.inbound.pause(); // Increase the total processing time. Keep doing this after each turn until all the ops have\n          // been processed. This way we keep the responsiveness at the beginning while also making sure\n          // that all the ops process fairly quickly.\n\n          this.currentAllowedProcessingTimeForTurn += this.processingTimeIncrement; // If we are logging the telemetry this time, update the telemetry log object.\n\n          if (this.schedulingLog) {\n            this.schedulingLog.numberOfTurns++;\n            this.schedulingLog.totalProcessingTime += elapsedTime;\n          }\n\n          setTimeout(() => {\n            if (this.schedulingLog) {\n              this.logger.sendTelemetryEvent({\n                eventName: \"InboundOpsPartialProcessingTime\",\n                duration: TelemetryLogger.formatTick(elapsedTime),\n                opsProcessed: this.schedulingLog.lastSequenceNumber - this.schedulingLog.firstSequenceNumber + 1,\n                opsRemainingToProcess: this.deltaManager.inbound.length,\n                processingTime: TelemetryLogger.formatTick(this.schedulingLog.totalProcessingTime),\n                numberOfTurns: this.schedulingLog.numberOfTurns,\n                batchesProcessed: this.schedulingLog.numberOfBatchesProcessed,\n                timeToResume: TelemetryLogger.formatTick(performance.now() - currentTime)\n              });\n            }\n\n            this.deltaManager.inbound.resume();\n          });\n          this.processingStartTime = undefined;\n        }\n      }\n    }\n\n    inboundQueueIdle() {\n      if (this.schedulingLog) {\n        // Add the time taken for processing the final ops to the total processing time in the\n        // telemetry log object.\n        const currentTime = performance.now(); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        this.schedulingLog.totalProcessingTime += currentTime - this.processingStartTime;\n        this.logger.sendTelemetryEvent({\n          eventName: \"InboundOpsProcessingTime\",\n          opsRemainingToProcess: this.schedulingLog.opsRemainingToProcess,\n          numberOfTurns: this.schedulingLog.numberOfTurns,\n          processingTime: TelemetryLogger.formatTick(this.schedulingLog.totalProcessingTime),\n          opsProcessed: this.schedulingLog.lastSequenceNumber - this.schedulingLog.firstSequenceNumber + 1,\n          batchesProcessed: this.schedulingLog.numberOfBatchesProcessed,\n          duration: TelemetryLogger.formatTick(currentTime - this.schedulingLog.startTime),\n          schedulingCount: this.schedulingCount\n        });\n        this.schedulingLog = undefined;\n      } // If we scheduled this batch of the inbound queue, increment the counter that tracks the\n      // number of times we have done this.\n\n\n      this.schedulingCount++; // Reset the processing times.\n\n      this.processingStartTime = undefined;\n      this.currentAllowedProcessingTimeForTurn = DeltaScheduler.processingTime;\n    }\n    /**\n     * This function tells whether we should run the scheduler.\n     */\n\n\n    shouldRunScheduler() {\n      // If there are still ops in the queue after the one we are processing now, we should\n      // run the scheduler.\n      return this.deltaManager.inbound.length > 0;\n    }\n\n  }\n\n  // The time for processing ops in a single turn.\n  //# sourceMappingURL=deltaScheduler.js.map\n  DeltaScheduler.processingTime = 50;\n  return DeltaScheduler;\n})();","map":null,"metadata":{},"sourceType":"module"}