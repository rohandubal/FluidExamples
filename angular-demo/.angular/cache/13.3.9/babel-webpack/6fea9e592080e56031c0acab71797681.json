{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n// RATIONALE: Many methods consume and return 'any' by necessity.\n\n/* eslint-disable @typescript-eslint/no-unsafe-return */\nimport { generateHandleContextPath } from \"@fluidframework/runtime-utils\";\nimport { RemoteFluidObjectHandle } from \"./remoteObjectHandle\";\nexport const isSerializedHandle = value => (value === null || value === void 0 ? void 0 : value.type) === \"__fluid_handle__\";\n/**\n * Data Store serializer implementation\n */\n\nexport class FluidSerializer {\n  constructor(context, // To be called whenever a handle is parsed by this serializer.\n  handleParsedCb) {\n    this.context = context;\n    this.handleParsedCb = handleParsedCb; // If the given 'value' is an IFluidHandle, returns the encoded IFluidHandle.\n    // Otherwise returns the original 'value'.  Used by 'encode()' and 'stringify()'.\n\n    this.encodeValue = (value, bind) => {\n      // Detect if 'value' is an IFluidHandle.\n      const handle = value === null || value === void 0 ? void 0 : value.IFluidHandle; // If 'value' is an IFluidHandle return its encoded form.\n\n      return handle !== undefined ? this.serializeHandle(handle, bind) : value;\n    }; // If the given 'value' is an encoded IFluidHandle, returns the decoded IFluidHandle.\n    // Otherwise returns the original 'value'.  Used by 'decode()' and 'parse()'.\n\n\n    this.decodeValue = value => {\n      // If 'value' is a serialized IFluidHandle return the deserialized result.\n      if (isSerializedHandle(value)) {\n        // Old documents may have handles with relative path in their summaries. Convert these to absolute\n        // paths. This will ensure that future summaries will have absolute paths for these handles.\n        const absolutePath = value.url.startsWith(\"/\") ? value.url : generateHandleContextPath(value.url, this.context);\n        const parsedHandle = new RemoteFluidObjectHandle(absolutePath, this.root);\n        this.handleParsedCb(parsedHandle);\n        return parsedHandle;\n      } else {\n        return value;\n      }\n    };\n\n    this.root = this.context;\n\n    while (this.root.routeContext !== undefined) {\n      this.root = this.root.routeContext;\n    }\n  }\n\n  get IFluidSerializer() {\n    return this;\n  }\n  /**\n   * Given a mostly-jsonable object tree that may have handle objects embedded within, will return a\n   * fully-jsonable object tree where any embedded IFluidHandles have been replaced with a serializable form.\n   *\n   * The original `input` object is not mutated.  This method will shallowly clone all objects in the path from\n   * the root to any replaced handles.  (If no handles are found, returns the original object.)\n   *\n   * Any unbound handles encountered are bound to the provided IFluidHandle.\n   */\n\n\n  encode(input, bind) {\n    // If the given 'input' cannot contain handles, return it immediately.  Otherwise,\n    // return the result of 'recursivelyReplace()'.\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    return !!input && typeof input === \"object\" ? this.recursivelyReplace(input, this.encodeValue, bind) : input;\n  }\n  /**\n   * Given a fully-jsonable object tree that may have encoded handle objects embedded within, will return an\n   * equivalent object tree where any encoded IFluidHandles have been replaced with their decoded form.\n   *\n   * The original `input` object is not mutated.  This method will shallowly clone all objects in the path from\n   * the root to any replaced handles.  (If no handles are found, returns the original object.)\n   *\n   * The decoded handles are implicitly bound to the handle context of this serializer.\n   */\n\n\n  decode(input) {\n    // If the given 'input' cannot contain handles, return it immediately.  Otherwise,\n    // return the result of 'recursivelyReplace()'.\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    return !!input && typeof input === \"object\" ? this.recursivelyReplace(input, this.decodeValue) : input;\n  }\n\n  stringify(input, bind) {\n    return JSON.stringify(input, (key, value) => this.encodeValue(value, bind));\n  } // Parses the serialized data - context must match the context with which the JSON was stringified\n\n\n  parse(input) {\n    return JSON.parse(input, (key, value) => this.decodeValue(value));\n  } // Invoked for non-null objects to recursively replace references to IFluidHandles.\n  // Clones as-needed to avoid mutating the `input` object.  If no IFluidHandes are present,\n  // returns the original `input`.\n\n\n  recursivelyReplace(input, replacer, context) {\n    // Note: Caller is responsible for ensuring that `input` is defined / non-null.\n    //       (Required for Object.keys() below.)\n    // Execute the `replace` on the current input.  Note that Caller is responsible for ensuring that `input`\n    // is a non-null object.\n    const maybeReplaced = replacer(input, context); // If the replacer made a substitution there is no need to decscend further. IFluidHandles are always\n    // leaves in the object graph.\n\n    if (maybeReplaced !== input) {\n      return maybeReplaced;\n    } // Otherwise descend into the object graph looking for IFluidHandle instances.\n\n\n    let clone;\n\n    for (const key of Object.keys(input)) {\n      const value = input[key]; // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\n      if (!!value && typeof value === \"object\") {\n        // Note: Except for IFluidHandle, `input` must not contain circular references (as object must\n        //       be JSON serializable.)  Therefore, guarding against infinite recursion here would only\n        //       lead to a later error when attempting to stringify().\n        const replaced = this.recursivelyReplace(value, replacer, context); // If the `replaced` object is different than the original `value` then the subgraph contained one\n        // or more handles.  If this happens, we need to return a clone of the `input` object where the\n        // current property is replaced by the `replaced` value.\n\n        if (replaced !== value) {\n          // Lazily create a shallow clone of the `input` object if we haven't done so already.\n          clone = clone !== null && clone !== void 0 ? clone : Array.isArray(input) ? [...input] : Object.assign({}, input); // Overwrite the current property `key` in the clone with the `replaced` value.\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n          clone[key] = replaced;\n        }\n      }\n    }\n\n    return clone !== null && clone !== void 0 ? clone : input;\n  }\n\n  serializeHandle(handle, bind) {\n    bind.bind(handle);\n    return {\n      type: \"__fluid_handle__\",\n      url: handle.absolutePath\n    };\n  }\n\n} //# sourceMappingURL=serializer.js.map","map":null,"metadata":{},"sourceType":"module"}