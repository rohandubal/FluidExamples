{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { TypedEventEmitter } from \"./typedEventEmitter\";\n/**\n * Base class used for forwarding events from a source EventEmitter.\n * This can be useful when all arbitrary listeners need to be removed,\n * but the primary source needs to stay intact.\n */\n\nexport let EventForwarder = /*#__PURE__*/(() => {\n  class EventForwarder extends TypedEventEmitter {\n    constructor(source) {\n      super();\n      this.isDisposed = false;\n      this.forwardingEvents = new Map();\n\n      if (source !== undefined) {\n        // NewListener event is raised whenever someone starts listening to this events, so\n        // we keep track of events being listened to, and start forwarding from the source\n        // event emitter per event listened to on this\n        const removeListenerHandler = event => this.unforwardEvent(source, event);\n\n        const newListenerHandler = event => this.forwardEvent(source, event);\n\n        this.on(EventForwarder.removeListenerEvent, removeListenerHandler);\n        this.on(EventForwarder.newListenerEvent, newListenerHandler);\n      }\n    }\n\n    static isEmitterEvent(event) {\n      return event === EventForwarder.newListenerEvent || event === EventForwarder.removeListenerEvent;\n    }\n\n    get disposed() {\n      return this.isDisposed;\n    }\n\n    dispose() {\n      this.isDisposed = true;\n\n      for (const listenerRemovers of this.forwardingEvents.values()) {\n        for (const listenerRemover of listenerRemovers.values()) {\n          try {\n            listenerRemover();\n          } catch (_a) {// Should be fine because of removeAllListeners below\n          }\n        }\n      }\n\n      this.removeAllListeners();\n      this.forwardingEvents.clear();\n    }\n\n    forwardEvent(source, ...events) {\n      for (const event of events) {\n        if (source !== undefined && event !== undefined && !EventForwarder.isEmitterEvent(event)) {\n          let sources = this.forwardingEvents.get(event);\n\n          if (sources === undefined) {\n            sources = new Map();\n            this.forwardingEvents.set(event, sources);\n          }\n\n          if (!sources.has(source)) {\n            const listener = (...args) => this.emit(event, ...args);\n\n            sources.set(source, () => source.off(event, listener));\n            source.on(event, listener);\n          }\n        }\n      }\n    }\n\n    unforwardEvent(source, ...events) {\n      for (const event of events) {\n        if (event !== undefined && !EventForwarder.isEmitterEvent(event)) {\n          const sources = this.forwardingEvents.get(event);\n\n          if (sources === null || sources === void 0 ? void 0 : sources.has(source)) {\n            if (this.listenerCount(event) === 0) {\n              const listenerRemover = sources.get(source);\n\n              if (listenerRemover !== undefined) {\n                listenerRemover();\n              }\n\n              sources.delete(source);\n\n              if (sources.size === 0) {\n                this.forwardingEvents.delete(event);\n              }\n            }\n          }\n        }\n      }\n    }\n\n  }\n\n  EventForwarder.newListenerEvent = \"newListener\";\n  EventForwarder.removeListenerEvent = \"removeListener\"; //# sourceMappingURL=eventForwarder.js.map\n\n  return EventForwarder;\n})();","map":null,"metadata":{},"sourceType":"module"}