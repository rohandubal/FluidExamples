{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { Deferred, assert, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nvar SummaryState = /*#__PURE__*/(() => {\n  (function (SummaryState) {\n    SummaryState[SummaryState[\"Local\"] = 0] = \"Local\";\n    SummaryState[SummaryState[\"Broadcast\"] = 1] = \"Broadcast\";\n    SummaryState[SummaryState[\"Acked\"] = 2] = \"Acked\";\n    SummaryState[SummaryState[\"Nacked\"] = -1] = \"Nacked\";\n  })(SummaryState || (SummaryState = {}));\n\n  return SummaryState;\n})();\n\nclass Summary {\n  constructor(clientId, clientSequenceNumber) {\n    this.clientId = clientId;\n    this.clientSequenceNumber = clientSequenceNumber;\n    this.state = SummaryState.Local;\n    this.defSummaryOp = new Deferred();\n    this.defSummaryAck = new Deferred();\n  }\n\n  static createLocal(clientId, clientSequenceNumber) {\n    return new Summary(clientId, clientSequenceNumber);\n  }\n\n  static createFromOp(op) {\n    const summary = new Summary(op.clientId, op.clientSequenceNumber);\n    summary.broadcast(op);\n    return summary;\n  }\n\n  get summaryOp() {\n    return this._summaryOp;\n  }\n\n  get summaryAckNack() {\n    return this._summaryAckNack;\n  }\n\n  hasBeenAcked() {\n    return this.state === SummaryState.Acked;\n  }\n\n  broadcast(op) {\n    assert(this.state === SummaryState.Local, 0x175\n    /* \"Can only broadcast if summarizer starts in local state\" */\n    );\n    this._summaryOp = op;\n    this.defSummaryOp.resolve();\n    this.state = SummaryState.Broadcast;\n    return true;\n  }\n\n  ackNack(op) {\n    assert(this.state === SummaryState.Broadcast, 0x176\n    /* \"Can only ack/nack if summarizer is in broadcasting state\" */\n    );\n    this._summaryAckNack = op;\n    this.defSummaryAck.resolve();\n    this.state = op.type === MessageType.SummaryAck ? SummaryState.Acked : SummaryState.Nacked;\n    return true;\n  }\n\n  waitBroadcast() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this.defSummaryOp.promise; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      return _this._summaryOp;\n    })();\n  }\n\n  waitAckNack() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this2.defSummaryAck.promise; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      return _this2._summaryAckNack;\n    })();\n  }\n\n}\n/**\n * This class watches summaries created by a specific client.\n * It should be created and managed from a SummaryCollection.\n */\n\n\nclass ClientSummaryWatcher {\n  constructor(clientId, summaryCollection) {\n    this.clientId = clientId;\n    this.summaryCollection = summaryCollection; // key: clientSeqNum\n\n    this.localSummaries = new Map();\n    this._disposed = false;\n  }\n\n  get disposed() {\n    return this._disposed;\n  }\n  /**\n   * Watches for a specific sent summary op.\n   * @param clientSequenceNumber - client sequence number of sent summary op\n   */\n\n\n  watchSummary(clientSequenceNumber) {\n    let summary = this.localSummaries.get(clientSequenceNumber);\n\n    if (!summary) {\n      summary = Summary.createLocal(this.clientId, clientSequenceNumber);\n      this.localSummaries.set(summary.clientSequenceNumber, summary);\n    }\n\n    return summary;\n  }\n  /**\n   * Waits until all of the pending summaries in the underlying SummaryCollection\n   * are acked/nacked.\n   */\n  // eslint-disable-next-line @typescript-eslint/promise-function-async\n\n\n  waitFlushed() {\n    return this.summaryCollection.waitFlushed();\n  }\n  /**\n   * Gets a watched summary or returns undefined if not watched.\n   * @param clientSequenceNumber - client sequence number of sent summary op\n   */\n\n\n  tryGetSummary(clientSequenceNumber) {\n    return this.localSummaries.get(clientSequenceNumber);\n  }\n  /**\n   * Starts watching a summary made by this client.\n   * @param summary - summary to start watching\n   */\n\n\n  setSummary(summary) {\n    this.localSummaries.set(summary.clientSequenceNumber, summary);\n  }\n\n  dispose() {\n    this.summaryCollection.removeWatcher(this.clientId);\n    this._disposed = true;\n  }\n\n}\n/**\n * Data structure that looks at the op stream to track summaries as they\n * are broadcast, acked and nacked.\n * It provides functionality for watching specific summaries.\n */\n\n\nexport class SummaryCollection extends TypedEventEmitter {\n  constructor(deltaManager, logger) {\n    super();\n    this.deltaManager = deltaManager;\n    this.logger = logger; // key: clientId\n\n    this.summaryWatchers = new Map(); // key: summarySeqNum\n\n    this.pendingSummaries = new Map();\n    this.refreshWaitNextAck = new Deferred();\n    this.deltaManager.on(\"op\", op => this.handleOp(op));\n  }\n\n  get latestAck() {\n    return this.lastAck;\n  }\n\n  emit(event, ...args) {\n    return super.emit(event, ...args);\n  }\n\n  get opsSinceLastAck() {\n    var _a, _b;\n\n    return this.deltaManager.lastSequenceNumber - ((_b = (_a = this.lastAck) === null || _a === void 0 ? void 0 : _a.summaryAck.sequenceNumber) !== null && _b !== void 0 ? _b : this.deltaManager.initialSequenceNumber);\n  }\n\n  addOpListener(listener) {\n    this.deltaManager.on(\"op\", listener);\n  }\n\n  removeOpListener(listener) {\n    this.deltaManager.off(\"op\", listener);\n  }\n  /**\n   * Creates and returns a summary watcher for a specific client.\n   * This will allow for local sent summaries to be better tracked.\n   * @param clientId - client id for watcher\n   */\n\n\n  createWatcher(clientId) {\n    const watcher = new ClientSummaryWatcher(clientId, this);\n    this.summaryWatchers.set(clientId, watcher);\n    return watcher;\n  }\n\n  removeWatcher(clientId) {\n    this.summaryWatchers.delete(clientId);\n  }\n\n  setPendingAckTimerTimeoutCallback(maxAckWaitTime, timeoutCallback) {\n    this.maxAckWaitTime = maxAckWaitTime;\n    this.pendingAckTimerTimeoutCallback = timeoutCallback;\n  }\n\n  unsetPendingAckTimerTimeoutCallback() {\n    this.maxAckWaitTime = undefined;\n    this.pendingAckTimerTimeoutCallback = undefined;\n  }\n  /**\n   * Returns a promise that resolves once all pending summary ops\n   * have been acked or nacked.\n   */\n\n\n  waitFlushed() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      while (_this3.pendingSummaries.size > 0) {\n        // eslint-disable-next-line @typescript-eslint/promise-function-async\n        const promises = Array.from(_this3.pendingSummaries, ([, summary]) => summary.waitAckNack());\n        yield Promise.all(promises);\n      }\n\n      return _this3.lastAck;\n    })();\n  }\n  /**\n   * Returns a promise that resolves once a summary is acked that has a reference\n   * sequence number greater than or equal to the passed in sequence number.\n   * @param referenceSequenceNumber - reference sequence number to wait for\n   * @returns The latest acked summary\n   */\n\n\n  waitSummaryAck(referenceSequenceNumber) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      while (!_this4.lastAck || _this4.lastAck.summaryOp.referenceSequenceNumber < referenceSequenceNumber) {\n        yield _this4.refreshWaitNextAck.promise;\n      }\n\n      return _this4.lastAck;\n    })();\n  }\n  /**\n   * Handler for ops; only handles ops relating to summaries.\n   * @param op - op message to handle\n   */\n\n\n  handleOp(op) {\n    var _a;\n\n    switch (op.type) {\n      case MessageType.Summarize:\n        {\n          this.handleSummaryOp(op);\n          return;\n        }\n\n      case MessageType.SummaryAck:\n        {\n          this.handleSummaryAck(op);\n          return;\n        }\n\n      case MessageType.SummaryNack:\n        {\n          this.handleSummaryNack(op);\n          return;\n        }\n\n      default:\n        {\n          // If the difference between timestamp of current op and last summary op is greater than\n          // the maxAckWaitTime, then we need to inform summarizer to not wait and summarize\n          // immediately as we have already waited for maxAckWaitTime.\n          const lastOpTimestamp = op.timestamp;\n\n          if (this.lastSummaryTimestamp !== undefined && this.maxAckWaitTime !== undefined && lastOpTimestamp - this.lastSummaryTimestamp >= this.maxAckWaitTime) {\n            (_a = this.pendingAckTimerTimeoutCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n          }\n\n          this.emit(\"default\", op);\n          return;\n        }\n    }\n  }\n\n  handleSummaryOp(op) {\n    let summary; // Check if summary already being watched, broadcast if so\n\n    const watcher = this.summaryWatchers.get(op.clientId);\n\n    if (watcher) {\n      summary = watcher.tryGetSummary(op.clientSequenceNumber);\n\n      if (summary) {\n        summary.broadcast(op);\n      }\n    } // If not watched, create from op\n\n\n    if (!summary) {\n      summary = Summary.createFromOp(op);\n\n      if (watcher) {\n        watcher.setSummary(summary);\n      }\n    }\n\n    this.pendingSummaries.set(op.sequenceNumber, summary);\n    this.lastSummaryTimestamp = op.timestamp;\n    this.emit(MessageType.Summarize, op);\n  }\n\n  handleSummaryAck(op) {\n    const seq = op.contents.summaryProposal.summarySequenceNumber;\n    const summary = this.pendingSummaries.get(seq);\n\n    if (!summary || summary.summaryOp === undefined) {\n      // Summary ack without an op should be rare. We could fetch the\n      // reference sequence number from the snapshot, but instead we\n      // will not emit this ack. It should be the case that the summary\n      // op that this ack is for is earlier than this file was loaded\n      // from. i.e. initialSequenceNumber > summarySequenceNumber.\n      // We really don't care about it for now, since it is older than\n      // the one we loaded from.\n      if (seq >= this.deltaManager.initialSequenceNumber) {\n        // Potential causes for it to be later than our initialSequenceNumber\n        // are that the summaryOp was nacked then acked, double-acked, or\n        // the summarySequenceNumber is incorrect.\n        this.logger.sendErrorEvent({\n          eventName: \"SummaryAckWithoutOp\",\n          sequenceNumber: op.sequenceNumber,\n          summarySequenceNumber: seq,\n          initialSequenceNumber: this.deltaManager.initialSequenceNumber\n        });\n      }\n\n      return;\n    }\n\n    summary.ackNack(op);\n    this.pendingSummaries.delete(seq); // Track latest ack\n\n    if (!this.lastAck || seq > this.lastAck.summaryAck.contents.summaryProposal.summarySequenceNumber) {\n      this.lastAck = {\n        summaryOp: summary.summaryOp,\n        summaryAck: op\n      };\n      this.refreshWaitNextAck.resolve();\n      this.refreshWaitNextAck = new Deferred();\n      this.emit(MessageType.SummaryAck, op);\n    }\n  }\n\n  handleSummaryNack(op) {\n    const seq = op.contents.summaryProposal.summarySequenceNumber;\n    const summary = this.pendingSummaries.get(seq);\n\n    if (summary) {\n      summary.ackNack(op);\n      this.pendingSummaries.delete(seq);\n      this.emit(MessageType.SummaryNack, op);\n    }\n  }\n\n} //# sourceMappingURL=summaryCollection.js.map","map":null,"metadata":{},"sourceType":"module"}