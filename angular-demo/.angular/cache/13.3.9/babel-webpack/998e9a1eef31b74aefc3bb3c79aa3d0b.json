{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { assert, delay, Deferred, PromiseTimer } from \"@fluidframework/common-utils\";\nimport { UsageError } from \"@fluidframework/container-utils\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nimport { SummarizeHeuristicRunner } from \"./summarizerHeuristics\";\nimport { raceTimer, SummarizeResultBuilder, SummaryGenerator } from \"./summaryGenerator\";\nconst maxSummarizeAckWaitTime = 10 * 60 * 1000; // 10 minutes\n\n/**\n * An instance of RunningSummarizer manages the heuristics for summarizing.\n * Until disposed, the instance of RunningSummarizer can assume that it is\n * in a state of running, meaning it is connected and initialized.  It keeps\n * track of summaries that it is generating as they are broadcast and acked/nacked.\n * This object is created and controlled by Summarizer object.\n */\n\nexport class RunningSummarizer {\n  constructor(baseLogger, summaryWatcher, configuration, submitSummaryCallback, heuristicData, raiseSummarizingError, summaryCollection, cancellationToken, stopSummarizerCallback) {\n    this.summaryWatcher = summaryWatcher;\n    this.configuration = configuration;\n    this.submitSummaryCallback = submitSummaryCallback;\n    this.heuristicData = heuristicData;\n    this.raiseSummarizingError = raiseSummarizingError;\n    this.summaryCollection = summaryCollection;\n    this.cancellationToken = cancellationToken;\n    this.stopSummarizerCallback = stopSummarizerCallback;\n    this.stopping = false;\n    this._disposed = false;\n    this.tryWhileSummarizing = false;\n    this.summarizeCount = 0;\n    this.totalSuccessfulAttempts = 0;\n    /**\n     * RunningSummarizer's logger includes the sequenced index of the current summary on each event.\n     * If some other Summarizer code wants that event on their logs they can get it here,\n     * but only if they're logging about that same summary.\n     * @param summaryOpRefSeq - RefSeq number of the summary op, to ensure the log correlation will be correct\n     */\n\n    this.tryGetCorrelatedLogger = summaryOpRefSeq => this.heuristicData.lastAttempt.refSequenceNumber === summaryOpRefSeq ? this.logger : undefined;\n\n    const telemetryProps = {\n      summarizeCount: () => this.summarizeCount,\n      summarizerSuccessfulAttempts: () => this.totalSuccessfulAttempts\n    };\n    this.logger = ChildLogger.create(baseLogger, \"Running\", {\n      all: telemetryProps\n    });\n\n    if (configuration.state !== \"disableHeuristics\") {\n      assert(this.configuration.state === \"enabled\", 0x2ea\n      /* \"Configuration state should be enabled\" */\n      );\n      this.heuristicRunner = new SummarizeHeuristicRunner(heuristicData, this.configuration, reason => this.trySummarize(reason), this.logger);\n    }\n\n    assert(this.configuration.state !== \"disabled\", 0x2eb\n    /* \"Summary not supported with configuration disabled\" */\n    ); // Cap the maximum amount of time client will wait for a summarize op ack to maxSummarizeAckWaitTime\n    // configuration.maxAckWaitTime is composed from defaults, server values, and runtime overrides\n\n    const maxAckWaitTime = Math.min(this.configuration.maxAckWaitTime, maxSummarizeAckWaitTime);\n    this.pendingAckTimer = new PromiseTimer(maxAckWaitTime, () => {\n      // pre-0.58 error message: summaryAckWaitTimeout\n      this.raiseSummarizingError(\"Pending summary ack not received in time\"); // Note: summarizeCount (from ChildLogger definition) may be 0,\n      // since this code path is hit when RunningSummarizer first starts up,\n      // before this instance has kicked off a new summarize run.\n\n      this.logger.sendErrorEvent({\n        eventName: \"SummaryAckWaitTimeout\",\n        maxAckWaitTime,\n        referenceSequenceNumber: this.heuristicData.lastAttempt.refSequenceNumber,\n        summarySequenceNumber: this.heuristicData.lastAttempt.summarySequenceNumber,\n        timePending: Date.now() - this.heuristicData.lastAttempt.summaryTime\n      });\n    }); // Set up pending ack timeout by op timestamp differences for previous summaries.\n\n    summaryCollection.setPendingAckTimerTimeoutCallback(maxAckWaitTime, () => {\n      if (this.pendingAckTimer.hasTimer) {\n        this.logger.sendTelemetryEvent({\n          eventName: \"MissingSummaryAckFoundByOps\",\n          referenceSequenceNumber: this.heuristicData.lastAttempt.refSequenceNumber,\n          summarySequenceNumber: this.heuristicData.lastAttempt.summarySequenceNumber\n        });\n        this.pendingAckTimer.clear();\n      }\n    });\n    this.generator = new SummaryGenerator(this.pendingAckTimer, this.heuristicData, this.submitSummaryCallback, this.raiseSummarizingError, () => {\n      this.totalSuccessfulAttempts++;\n    }, this.summaryWatcher, this.logger);\n  }\n\n  static start(logger, summaryWatcher, configuration, submitSummaryCallback, heuristicData, raiseSummarizingError, summaryCollection, cancellationToken, stopSummarizerCallback) {\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const summarizer = new RunningSummarizer(logger, summaryWatcher, configuration, submitSummaryCallback, heuristicData, raiseSummarizingError, summaryCollection, cancellationToken, stopSummarizerCallback);\n      yield summarizer.waitStart(); // Run the heuristics after starting\n\n      (_a = summarizer.heuristicRunner) === null || _a === void 0 ? void 0 : _a.run();\n      return summarizer;\n    })();\n  }\n\n  get disposed() {\n    return this._disposed;\n  }\n\n  dispose() {\n    var _a;\n\n    this.summaryWatcher.dispose();\n    (_a = this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.dispose();\n    this.heuristicRunner = undefined;\n    this.generator.dispose();\n    this.pendingAckTimer.clear();\n    this.disposeEnqueuedSummary();\n    this._disposed = true;\n    this.stopping = true;\n  }\n\n  handleSystemOp(op) {\n    switch (op.type) {\n      case MessageType.ClientLeave:\n      case MessageType.ClientJoin:\n      case MessageType.Propose:\n        {\n          // Synchronously handle quorum ops like regular ops\n          this.handleOp(undefined, op);\n          return;\n        }\n\n      default:\n        {\n          return;\n        }\n    }\n  }\n\n  handleOp(error, {\n    sequenceNumber,\n    type,\n    clientId,\n    contents\n  }) {\n    var _a;\n\n    if (error !== undefined) {\n      return;\n    }\n\n    this.heuristicData.lastOpSequenceNumber = sequenceNumber; // Check for enqueued on-demand summaries; Intentionally do nothing otherwise\n\n    if (!this.tryRunEnqueuedSummary()) {\n      (_a = this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.run();\n    }\n  }\n\n  waitStop(allowLastSummary) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      if (_this.stopping) {\n        return;\n      }\n\n      _this.stopping = true;\n\n      _this.disposeEnqueuedSummary(); // This will try to run lastSummary if needed.\n\n\n      if (allowLastSummary && ((_a = _this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.shouldRunLastSummary())) {\n        if (_this.summarizingLock === undefined) {\n          _this.trySummarizeOnce( // summarizeProps\n          {\n            reason: \"lastSummary\"\n          }, // ISummarizeOptions, using defaults: { refreshLatestAck: false, fullTree: false }\n          {});\n        }\n      } // Note that trySummarizeOnce() call above returns right away, without waiting.\n      // So we need to wait for its completion, otherwise it would be destroyed right away.\n      // That said, if summary lock was taken upfront, this wait might wait on  multiple retries to\n      // submit summary. We should reconsider this flow and make summarizer move to exit faster.\n      // This resolves when the current pending summary gets an ack or fails.\n\n\n      yield _this.summarizingLock;\n    })();\n  }\n\n  waitStart() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // Wait no longer than ack timeout for all pending\n      const waitStartResult = yield raceTimer(_this2.summaryWatcher.waitFlushed(), _this2.pendingAckTimer.start());\n\n      _this2.pendingAckTimer.clear(); // Remove pending ack wait timeout by op timestamp comparison, because\n      // it has race conditions with summaries submitted by this same client.\n\n\n      _this2.summaryCollection.unsetPendingAckTimerTimeoutCallback();\n\n      if (waitStartResult.result === \"done\" && waitStartResult.value !== undefined) {\n        _this2.heuristicData.updateWithLastSummaryAckInfo({\n          refSequenceNumber: waitStartResult.value.summaryOp.referenceSequenceNumber,\n          // This will be the Summarizer starting point so only use timestamps from client's machine.\n          summaryTime: Date.now(),\n          summarySequenceNumber: waitStartResult.value.summaryOp.sequenceNumber\n        });\n      }\n    })();\n  }\n  /**\n   * Blocks a new summarizer from running in case RefreshSummaryAck is being processed.\n   * Assumes that caller checked upfront for lack of concurrent action (this.refreshSummaryAckLock)\n   * before calling this API. I.e. caller is responsible for either erroring out or waiting on this promise.\n   * Note: The refreshSummaryAckLock makes sure no summarizer gets enqueued or processed\n   * until the refresh has completed. One can't rely uniquely on the summarizingLock as the\n   * refreshLatestSummaryAck also happens during the time summarizingLock !== undefined.\n   * Ex. Summarizer submits a summay + op and then waits for the Summary Ack to proceed\n   * with the refreshLatestSummaryAck and complete the summary.\n   * @param action - action to perform.\n   * @returns - result of action.\n   */\n\n\n  lockedRefreshSummaryAckAction(action) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      assert(_this3.refreshSummaryAckLock === undefined, \"Refresh Summary Ack - Caller is responsible for checking lock\");\n      const refreshSummaryAckLock = new Deferred();\n      _this3.refreshSummaryAckLock = refreshSummaryAckLock.promise;\n      return action().finally(() => {\n        refreshSummaryAckLock.resolve();\n        _this3.refreshSummaryAckLock = undefined;\n      });\n    })();\n  }\n  /**\n   * Runs single summary action that prevents any other concurrent actions.\n   * Assumes that caller checked upfront for lack of concurrent action (this.summarizingLock)\n   * before calling this API. I.e. caller is responsible for either erroring out or waiting on this promise.\n   * @param action - action to perform.\n   * @returns - result of action.\n   */\n\n\n  lockedSummaryAction(action) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      assert(_this4.summarizingLock === undefined, 0x25b\n      /* \"Caller is responsible for checking lock\" */\n      );\n      const summarizingLock = new Deferred();\n      _this4.summarizingLock = summarizingLock.promise;\n      _this4.summarizeCount++; // Make sure the RefreshLatestSummaryAck is not being executed.\n\n      yield _this4.refreshSummaryAckLock;\n      return action().finally(() => {\n        var _a;\n\n        summarizingLock.resolve();\n        _this4.summarizingLock = undefined;\n        const retry = _this4.tryWhileSummarizing;\n        _this4.tryWhileSummarizing = false; // After summarizing, we should check to see if we need to summarize again.\n        // Rerun the heuristics and check for enqueued summaries.\n\n        if (!_this4.stopping && !_this4.tryRunEnqueuedSummary() && retry) {\n          (_a = _this4.heuristicRunner) === null || _a === void 0 ? void 0 : _a.run();\n        }\n      });\n    })();\n  }\n  /**\n   * Runs single summarize attempt\n   * @param summarizeProps - props to log with each telemetry event associated with this attempt\n   * @param options - summary options\n   * @param cancellationToken - cancellation token to use to be able to cancel this summary, if needed\n   * @param resultsBuilder - optional, result builder to use.\n   * @returns ISummarizeResult - result of running a summary.\n   */\n\n\n  trySummarizeOnce(summarizeProps, options, cancellationToken = this.cancellationToken, resultsBuilder = new SummarizeResultBuilder()) {\n    var _this5 = this;\n\n    this.lockedSummaryAction( /*#__PURE__*/_asyncToGenerator(function* () {\n      const summarizeResult = _this5.generator.summarize(summarizeProps, options, cancellationToken, resultsBuilder); // ensure we wait till the end of the process\n\n\n      return summarizeResult.receivedSummaryAckOrNack;\n    })).catch(error => {// SummaryGenerator.summarize() does not throw exceptions - it converts them to failed result\n      // on resultsBuilder\n      // We do not care about exceptions on receivedSummaryAckOrNack - caller should check results\n      // and take a appropriate action.\n    });\n    return resultsBuilder.build();\n  }\n  /** Heuristics summarize attempt. */\n\n\n  trySummarize(reason, cancellationToken = this.cancellationToken) {\n    var _this6 = this;\n\n    if (this.summarizingLock !== undefined) {\n      // lockedSummaryAction() will retry heuristic-based summary at the end of current attempt\n      // if it's still needed\n      this.tryWhileSummarizing = true;\n      return;\n    }\n\n    this.lockedSummaryAction( /*#__PURE__*/_asyncToGenerator(function* () {\n      const attempts = [{\n        refreshLatestAck: false,\n        fullTree: false\n      }, {\n        refreshLatestAck: true,\n        fullTree: false\n      }, {\n        refreshLatestAck: true,\n        fullTree: false,\n        delaySeconds: 2 * 60\n      }, {\n        refreshLatestAck: true,\n        fullTree: true,\n        delaySeconds: 10 * 60\n      }];\n      let overrideDelaySeconds;\n      let summaryAttempts = 0;\n      let summaryAttemptsPerPhase = 0;\n      let lastResult;\n\n      for (let summaryAttemptPhase = 0; summaryAttemptPhase < attempts.length;) {\n        if (_this6.cancellationToken.cancelled) {\n          return;\n        } // We only want to attempt 1 summary when reason is \"lastSummary\"\n\n\n        if (++summaryAttempts > 1 && reason === \"lastSummary\") {\n          return;\n        }\n\n        summaryAttemptsPerPhase++;\n\n        const _a = attempts[summaryAttemptPhase],\n              {\n          delaySeconds: regularDelaySeconds = 0\n        } = _a,\n              options = __rest(_a, [\"delaySeconds\"]);\n\n        const delaySeconds = overrideDelaySeconds !== null && overrideDelaySeconds !== void 0 ? overrideDelaySeconds : regularDelaySeconds;\n        const summarizeProps = Object.assign({\n          reason,\n          summaryAttempts,\n          summaryAttemptsPerPhase,\n          summaryAttemptPhase: summaryAttemptPhase + 1\n        }, options);\n\n        if (delaySeconds > 0) {\n          _this6.logger.sendPerformanceEvent(Object.assign({\n            eventName: \"SummarizeAttemptDelay\",\n            duration: delaySeconds,\n            summaryNackDelay: overrideDelaySeconds !== undefined\n          }, summarizeProps));\n\n          yield delay(delaySeconds * 1000);\n        } // Make sure the refresh Summary Ack is not being executed.\n\n\n        yield _this6.refreshSummaryAckLock; // Note: no need to account for cancellationToken.waitCancelled here, as\n        // this is accounted SummaryGenerator.summarizeCore that controls receivedSummaryAckOrNack.\n\n        const resultSummarize = _this6.generator.summarize(summarizeProps, options, cancellationToken);\n\n        const result = yield resultSummarize.receivedSummaryAckOrNack;\n\n        if (result.success) {\n          return;\n        } // Check for retryDelay that can come from summaryNack or upload summary flow.\n        // Retry the same step only once per retryAfter response.\n\n\n        overrideDelaySeconds = result.retryAfterSeconds;\n\n        if (overrideDelaySeconds === undefined || summaryAttemptsPerPhase > 1) {\n          summaryAttemptPhase++;\n          summaryAttemptsPerPhase = 0;\n        }\n\n        lastResult = result;\n      } // If all attempts failed, log error (with last attempt info) and close the summarizer container\n\n\n      _this6.logger.sendErrorEvent({\n        eventName: \"FailToSummarize\",\n        reason,\n        message: lastResult === null || lastResult === void 0 ? void 0 : lastResult.message\n      }, lastResult === null || lastResult === void 0 ? void 0 : lastResult.error);\n\n      _this6.stopSummarizerCallback(\"failToSummarize\");\n    })).catch(error => {\n      this.logger.sendErrorEvent({\n        eventName: \"UnexpectedSummarizeError\"\n      }, error);\n    });\n  }\n  /** {@inheritdoc (ISummarizer:interface).summarizeOnDemand} */\n\n\n  summarizeOnDemand(resultsBuilder = new SummarizeResultBuilder(), _a) {\n    var {\n      reason\n    } = _a,\n        options = __rest(_a, [\"reason\"]);\n\n    if (this.stopping) {\n      resultsBuilder.fail(\"RunningSummarizer stopped or disposed\", undefined);\n      return resultsBuilder.build();\n    } // Check for concurrent summary attempts. If one is found,\n    // return a promise that caller can await before trying again.\n\n\n    if (this.summarizingLock !== undefined) {\n      // The heuristics are blocking concurrent summarize attempts.\n      throw new UsageError(\"Attempted to run an already-running summarizer on demand\");\n    }\n\n    const result = this.trySummarizeOnce({\n      reason: `onDemand/${reason}`\n    }, options, this.cancellationToken, resultsBuilder);\n    return result;\n  }\n  /** {@inheritdoc (ISummarizer:interface).enqueueSummarize} */\n\n\n  enqueueSummarize(_a) {\n    var {\n      reason,\n      afterSequenceNumber = 0,\n      override = false\n    } = _a,\n        options = __rest(_a, [\"reason\", \"afterSequenceNumber\", \"override\"]);\n\n    const onDemandReason = `enqueue;${reason}`;\n    let overridden = false;\n\n    if (this.enqueuedSummary !== undefined) {\n      if (!override) {\n        return {\n          alreadyEnqueued: true\n        };\n      } // Override existing enqueued summarize attempt.\n\n\n      this.enqueuedSummary.resultsBuilder.fail(\"Aborted; overridden by another enqueue summarize attempt\", undefined);\n      this.enqueuedSummary = undefined;\n      overridden = true;\n    }\n\n    this.enqueuedSummary = {\n      reason: onDemandReason,\n      afterSequenceNumber,\n      options,\n      resultsBuilder: new SummarizeResultBuilder()\n    };\n    const results = this.enqueuedSummary.resultsBuilder.build();\n    this.tryRunEnqueuedSummary();\n    return overridden ? Object.assign(Object.assign({}, results), {\n      alreadyEnqueued: true,\n      overridden: true\n    }) : results;\n  }\n\n  tryRunEnqueuedSummary() {\n    if (this.stopping) {\n      this.disposeEnqueuedSummary();\n      return false;\n    }\n\n    if (this.enqueuedSummary === undefined || this.heuristicData.lastOpSequenceNumber < this.enqueuedSummary.afterSequenceNumber || this.summarizingLock !== undefined) {\n      // If no enqueued summary is ready or a summary is already in progress, take no action.\n      return false;\n    }\n\n    const {\n      reason,\n      resultsBuilder,\n      options\n    } = this.enqueuedSummary; // Set to undefined first, so that subsequent enqueue attempt while summarize will occur later.\n\n    this.enqueuedSummary = undefined;\n    this.trySummarizeOnce({\n      reason: `enqueuedSummary/${reason}`\n    }, options, this.cancellationToken, resultsBuilder);\n    return true;\n  }\n\n  disposeEnqueuedSummary() {\n    if (this.enqueuedSummary !== undefined) {\n      this.enqueuedSummary.resultsBuilder.fail(\"RunningSummarizer stopped or disposed\", undefined);\n      this.enqueuedSummary = undefined;\n    }\n  }\n\n} //# sourceMappingURL=runningSummarizer.js.map","map":null,"metadata":{},"sourceType":"module"}