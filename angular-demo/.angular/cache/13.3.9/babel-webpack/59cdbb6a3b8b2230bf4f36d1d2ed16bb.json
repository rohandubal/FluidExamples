{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport * as api from \"@fluidframework/driver-definitions\";\nimport { RateLimiter } from \"@fluidframework/driver-utils\";\nimport { GitManager, Historian } from \"@fluidframework/server-services-client\";\nimport io from \"socket.io-client\";\nimport { PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { DeltaStorageService, DocumentDeltaStorageService } from \"./deltaStorageService\";\nimport { DocumentStorageService } from \"./documentStorageService\";\nimport { R11sDocumentDeltaConnection } from \"./documentDeltaConnection\";\nimport { NullBlobStorageService } from \"./nullBlobStorageService\";\nimport { RouterliciousOrdererRestWrapper, RouterliciousStorageRestWrapper } from \"./restWrapper\";\n/**\n * Amount of time between discoveries within which we don't need to rediscover on re-connect.\n * Currently, R11s defines session length at 10 minutes. To avoid any weird unknown edge-cases though,\n * we set the limit to 5 minutes here.\n * In the future, we likely want to retrieve this information from service's \"inactive session\" definition.\n */\n\nconst RediscoverAfterTimeSinceDiscoveryMs = 5 * 60000; // 5 minute\n\n/**\n * The DocumentService manages the Socket.IO connection and manages routing requests to connected\n * clients.\n */\n\nexport class DocumentService {\n  constructor(_resolvedUrl, ordererUrl, deltaStorageUrl, storageUrl, logger, tokenProvider, tenantId, documentId, driverPolicies, blobCache, snapshotTreeCache, discoverFluidResolvedUrl) {\n    this._resolvedUrl = _resolvedUrl;\n    this.ordererUrl = ordererUrl;\n    this.deltaStorageUrl = deltaStorageUrl;\n    this.storageUrl = storageUrl;\n    this.logger = logger;\n    this.tokenProvider = tokenProvider;\n    this.tenantId = tenantId;\n    this.documentId = documentId;\n    this.driverPolicies = driverPolicies;\n    this.blobCache = blobCache;\n    this.snapshotTreeCache = snapshotTreeCache;\n    this.discoverFluidResolvedUrl = discoverFluidResolvedUrl;\n    this.lastDiscoveredAt = Date.now();\n  }\n\n  get resolvedUrl() {\n    return this._resolvedUrl;\n  }\n\n  dispose() {}\n  /**\n   * Connects to a storage endpoint for snapshot service.\n   *\n   * @returns returns the document storage service for routerlicious driver.\n   */\n\n\n  connectToStorage() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.documentStorageService !== undefined) {\n        return _this.documentStorageService;\n      }\n\n      if (_this.storageUrl === undefined) {\n        return new NullBlobStorageService();\n      }\n\n      const getStorageManager = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (disableCache) {\n          const shouldUpdateDiscoveredSessionInfo = _this.shouldUpdateDiscoveredSessionInfo();\n\n          if (shouldUpdateDiscoveredSessionInfo) {\n            yield _this.refreshDiscovery();\n          }\n\n          if (!_this.storageManager || !_this.noCacheStorageManager || shouldUpdateDiscoveredSessionInfo) {\n            const rateLimiter = new RateLimiter(_this.driverPolicies.maxConcurrentStorageRequests);\n            const storageRestWrapper = yield RouterliciousStorageRestWrapper.load(_this.tenantId, _this.documentId, _this.tokenProvider, _this.logger, rateLimiter, _this.driverPolicies.enableRestLess, _this.storageUrl);\n            const historian = new Historian(_this.storageUrl, true, false, storageRestWrapper);\n            _this.storageManager = new GitManager(historian);\n            const noCacheHistorian = new Historian(_this.storageUrl, true, true, storageRestWrapper);\n            _this.noCacheStorageManager = new GitManager(noCacheHistorian);\n          }\n\n          return disableCache ? _this.noCacheStorageManager : _this.storageManager;\n        });\n\n        return function getStorageManager(_x) {\n          return _ref.apply(this, arguments);\n        };\n      }(); // Initialize storageManager and noCacheStorageManager\n\n\n      const storageManager = yield getStorageManager();\n      const noCacheStorageManager = yield getStorageManager(true);\n      const documentStorageServicePolicies = {\n        caching: _this.driverPolicies.enablePrefetch ? api.LoaderCachingPolicy.Prefetch : api.LoaderCachingPolicy.NoCaching,\n        minBlobSize: _this.driverPolicies.aggregateBlobsSmallerThanBytes\n      };\n      _this.documentStorageService = new DocumentStorageService(_this.documentId, storageManager, _this.logger, documentStorageServicePolicies, _this.driverPolicies, _this.blobCache, _this.snapshotTreeCache, noCacheStorageManager, getStorageManager);\n      return _this.documentStorageService;\n    })();\n  }\n  /**\n   * Connects to a delta storage endpoint for getting ops between a range.\n   *\n   * @returns returns the document delta storage service for routerlicious driver.\n   */\n\n\n  connectToDeltaStorage() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this2.connectToStorage();\n      assert(!!_this2.documentStorageService, 0x0b1\n      /* \"Storage service not initialized\" */\n      );\n\n      const getRestWrapper = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          const shouldUpdateDiscoveredSessionInfo = _this2.shouldUpdateDiscoveredSessionInfo();\n\n          if (shouldUpdateDiscoveredSessionInfo) {\n            yield _this2.refreshDiscovery();\n          }\n\n          if (!_this2.ordererRestWrapper || shouldUpdateDiscoveredSessionInfo) {\n            const rateLimiter = new RateLimiter(_this2.driverPolicies.maxConcurrentOrdererRequests);\n            _this2.ordererRestWrapper = yield RouterliciousOrdererRestWrapper.load(_this2.tenantId, _this2.documentId, _this2.tokenProvider, _this2.logger, rateLimiter, _this2.driverPolicies.enableRestLess);\n          }\n\n          return _this2.ordererRestWrapper;\n        });\n\n        return function getRestWrapper() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      const restWrapper = yield getRestWrapper();\n      const deltaStorageService = new DeltaStorageService(_this2.deltaStorageUrl, restWrapper, _this2.logger, getRestWrapper, () => _this2.deltaStorageUrl);\n      return new DocumentDeltaStorageService(_this2.tenantId, _this2.documentId, deltaStorageService, _this2.documentStorageService);\n    })();\n  }\n  /**\n   * Connects to a delta stream endpoint for emitting ops.\n   *\n   * @returns returns the document delta stream service for routerlicious driver.\n   */\n\n\n  connectToDeltaStream(client) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const connect = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (refreshToken) {\n          if (_this3.shouldUpdateDiscoveredSessionInfo()) {\n            yield _this3.refreshDiscovery();\n          }\n\n          const ordererToken = yield _this3.tokenProvider.fetchOrdererToken(_this3.tenantId, _this3.documentId, refreshToken);\n          return R11sDocumentDeltaConnection.create(_this3.tenantId, _this3.documentId, ordererToken.jwt, io, client, _this3.ordererUrl, _this3.logger);\n        });\n\n        return function connect(_x2) {\n          return _ref3.apply(this, arguments);\n        };\n      }(); // Attempt to establish connection.\n      // Retry with new token on authorization error; otherwise, allow container layer to handle.\n\n\n      try {\n        const connection = yield connect();\n        return connection;\n      } catch (error) {\n        if ((error === null || error === void 0 ? void 0 : error.statusCode) === 401) {\n          // Fetch new token and retry once,\n          // otherwise 401 will be bubbled up as non-retriable AuthorizationError.\n          return connect(true\n          /* refreshToken */\n          );\n        }\n\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Re-discover session URLs if necessary.\n   */\n\n\n  refreshDiscovery() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this4.discoverP) {\n        _this4.discoverP = PerformanceEvent.timedExecAsync(_this4.logger, {\n          eventName: \"refreshSessionDiscovery\"\n        }, /*#__PURE__*/_asyncToGenerator(function* () {\n          return _this4.refreshDiscoveryCore();\n        }));\n      }\n\n      return _this4.discoverP;\n    })();\n  }\n\n  refreshDiscoveryCore() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const fluidResolvedUrl = yield _this5.discoverFluidResolvedUrl();\n      _this5._resolvedUrl = fluidResolvedUrl;\n      _this5.storageUrl = fluidResolvedUrl.endpoints.storageUrl;\n      _this5.ordererUrl = fluidResolvedUrl.endpoints.ordererUrl;\n      _this5.deltaStorageUrl = fluidResolvedUrl.endpoints.deltaStorageUrl;\n      _this5.lastDiscoveredAt = Date.now();\n    })();\n  }\n  /**\n   * Whether enough time has passed since last disconnect to warrant a new discovery call on reconnect.\n   */\n\n\n  shouldUpdateDiscoveredSessionInfo() {\n    if (!this.driverPolicies.enableDiscovery) {\n      return false;\n    }\n\n    const now = Date.now(); // When connection is disconnected, we cannot know if session has moved or document has been deleted\n    // without re-doing discovery on the next attempt to connect.\n    // Disconnect event is not so reliable in local testing. To ensure re-discovery when necessary,\n    // re-discover if enough time has passed since last discovery.\n\n    const pastLastDiscoveryTimeThreshold = now - this.lastDiscoveredAt > RediscoverAfterTimeSinceDiscoveryMs;\n    return pastLastDiscoveryTimeThreshold;\n  }\n\n} //# sourceMappingURL=documentService.js.map","map":null,"metadata":{},"sourceType":"module"}