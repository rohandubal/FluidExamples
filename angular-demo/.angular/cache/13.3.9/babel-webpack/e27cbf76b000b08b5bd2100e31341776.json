{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { readAndParse, requestOps, emptyMessageStream } from \"@fluidframework/driver-utils\";\nimport { TelemetryNullLogger } from \"@fluidframework/common-utils\";\nimport { PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nconst MaxBatchDeltas = 2000; // Maximum number of ops we can fetch at a time\n\n/**\n * Storage service limited to only being able to fetch documents for a specific document\n */\n\nexport class DocumentDeltaStorageService {\n  constructor(tenantId, id, deltaStorageService, documentStorageService) {\n    this.tenantId = tenantId;\n    this.id = id;\n    this.deltaStorageService = deltaStorageService;\n    this.documentStorageService = documentStorageService;\n    this.logtailSha = this.documentStorageService.logTailSha;\n  }\n\n  fetchMessages(from, to, abortSignal, cachedOnly, fetchReason) {\n    if (cachedOnly) {\n      return emptyMessageStream;\n    }\n\n    return requestOps(this.getCore.bind(this), // Staging: starting with no concurrency, listening for feedback first.\n    // In future releases we will switch to actual concurrency\n    1, // concurrency\n    from, // inclusive\n    to, // exclusive\n    MaxBatchDeltas, new TelemetryNullLogger(), abortSignal, fetchReason);\n  }\n\n  getCore(from, to) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const opsFromLogTail = _this.logtailSha ? yield readAndParse(_this.documentStorageService, _this.logtailSha) : [];\n      _this.logtailSha = undefined;\n\n      if (opsFromLogTail.length > 0) {\n        const messages = opsFromLogTail.filter(op => op.sequenceNumber >= from);\n\n        if (messages.length > 0) {\n          return {\n            messages,\n            partialResult: true\n          };\n        }\n      }\n\n      return _this.deltaStorageService.get(_this.tenantId, _this.id, from, to);\n    })();\n  }\n\n}\n/**\n * Provides access to the underlying delta storage on the server for routerlicious driver.\n */\n\nexport class DeltaStorageService {\n  constructor(url, restWrapper, logger, getRestWrapper = /*#__PURE__*/_asyncToGenerator(function* () {\n    return _this2.restWrapper;\n  }), getDeltaStorageUrl = () => this.url) {\n    var _this2 = this;\n\n    this.url = url;\n    this.restWrapper = restWrapper;\n    this.logger = logger;\n    this.getRestWrapper = getRestWrapper;\n    this.getDeltaStorageUrl = getDeltaStorageUrl;\n  }\n\n  get(tenantId, id, from, // inclusive\n  to) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const ops = yield PerformanceEvent.timedExecAsync(_this3.logger, {\n        eventName: \"getDeltas\",\n        from,\n        to\n      }, /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (event) {\n          const restWrapper = yield _this3.getRestWrapper();\n\n          const url = _this3.getDeltaStorageUrl();\n\n          const response = yield restWrapper.get(url, {\n            from: from - 1,\n            to\n          });\n          event.end({\n            count: response.length\n          });\n          return response;\n        });\n\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }()); // It is assumed that server always returns all the ops that it has in the range that was requested.\n      // This may change in the future, if so, we need to adjust and receive \"end\" value from server in such case.\n\n      return {\n        messages: ops,\n        partialResult: false\n      };\n    })();\n  }\n\n} //# sourceMappingURL=deltaStorageService.js.map","map":null,"metadata":{},"sourceType":"module"}