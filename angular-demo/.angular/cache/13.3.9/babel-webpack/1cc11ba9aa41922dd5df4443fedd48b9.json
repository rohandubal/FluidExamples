{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { ValueType } from \"@fluidframework/shared-object-base\";\nimport { assert } from \"@fluidframework/common-utils\";\nimport { LocalValueMaker, makeSerializable } from \"./localValues\";\n\nfunction isMapKeyLocalOpMetadata(metadata) {\n  return metadata !== undefined && typeof metadata.pendingMessageId === \"number\" && (metadata.type === \"add\" || metadata.type === \"edit\");\n}\n\nfunction isClearLocalOpMetadata(metadata) {\n  return metadata !== undefined && metadata.type === \"clear\" && typeof metadata.pendingMessageId === \"number\";\n}\n\nfunction isMapLocalOpMetadata(metadata) {\n  return metadata !== undefined && typeof metadata.pendingMessageId === \"number\" && (metadata.type === \"add\" || metadata.type === \"edit\" || metadata.type === \"clear\");\n}\n/**\n * A SharedMap is a map-like distributed data structure.\n */\n\n\nexport class MapKernel {\n  /**\n   * Create a new shared map kernel.\n   * @param serializer - The serializer to serialize / parse handles\n   * @param handle - The handle of the shared object using the kernel\n   * @param submitMessage - A callback to submit a message through the shared object\n   * @param isAttached - To query whether the shared object should generate ops\n   * @param valueTypes - The value types to register\n   * @param eventEmitter - The object that will emit map events\n   */\n  constructor(serializer, handle, submitMessage, isAttached, eventEmitter) {\n    this.serializer = serializer;\n    this.handle = handle;\n    this.submitMessage = submitMessage;\n    this.isAttached = isAttached;\n    this.eventEmitter = eventEmitter;\n    /**\n     * Mapping of op types to message handlers.\n     */\n\n    this.messageHandlers = new Map();\n    /**\n     * The in-memory data the map is storing.\n     */\n\n    this.data = new Map();\n    /**\n     * Keys that have been modified locally but not yet ack'd from the server.\n     */\n\n    this.pendingKeys = new Map();\n    /**\n     * This is used to assign a unique id to every outgoing operation and helps in tracking unack'd ops.\n     */\n\n    this.pendingMessageId = -1;\n    /**\n     * The pending ids of any clears that have been performed locally but not yet ack'd from the server\n     */\n\n    this.pendingClearMessageIds = [];\n    this.localValueMaker = new LocalValueMaker(serializer);\n    this.messageHandlers = this.getMessageHandlers();\n  }\n  /**\n   * The number of key/value pairs stored in the map.\n   */\n\n\n  get size() {\n    return this.data.size;\n  }\n  /**\n   * Get an iterator over the keys in this map.\n   * @returns The iterator\n   */\n\n\n  keys() {\n    return this.data.keys();\n  }\n  /**\n   * Get an iterator over the entries in this map.\n   * @returns The iterator\n   */\n\n\n  entries() {\n    const localEntriesIterator = this.data.entries();\n    const iterator = {\n      next() {\n        const nextVal = localEntriesIterator.next();\n\n        if (nextVal.done) {\n          return {\n            value: undefined,\n            done: true\n          };\n        } else {\n          // Unpack the stored value\n          return {\n            value: [nextVal.value[0], nextVal.value[1].value],\n            done: false\n          };\n        }\n      },\n\n      [Symbol.iterator]() {\n        return this;\n      }\n\n    };\n    return iterator;\n  }\n  /**\n   * Get an iterator over the values in this map.\n   * @returns The iterator\n   */\n\n\n  values() {\n    const localValuesIterator = this.data.values();\n    const iterator = {\n      next() {\n        const nextVal = localValuesIterator.next();\n\n        if (nextVal.done) {\n          return {\n            value: undefined,\n            done: true\n          };\n        } else {\n          // Unpack the stored value\n          return {\n            value: nextVal.value.value,\n            done: false\n          };\n        }\n      },\n\n      [Symbol.iterator]() {\n        return this;\n      }\n\n    };\n    return iterator;\n  }\n  /**\n   * Get an iterator over the entries in this map.\n   * @returns The iterator\n   */\n\n\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Executes the given callback on each entry in the map.\n   * @param callbackFn - Callback function\n   */\n\n\n  forEach(callbackFn) {\n    this.data.forEach((localValue, key, m) => {\n      callbackFn(localValue.value, key, m);\n    });\n  }\n  /**\n   * {@inheritDoc ISharedMap.get}\n   */\n\n\n  get(key) {\n    const localValue = this.data.get(key);\n    return localValue === undefined ? undefined : localValue.value;\n  }\n  /**\n   * Check if a key exists in the map.\n   * @param key - The key to check\n   * @returns True if the key exists, false otherwise\n   */\n\n\n  has(key) {\n    return this.data.has(key);\n  }\n  /**\n   * {@inheritDoc ISharedMap.set}\n   */\n\n\n  set(key, value) {\n    // Undefined/null keys can't be serialized to JSON in the manner we currently snapshot.\n    if (key === undefined || key === null) {\n      throw new Error(\"Undefined and null keys are not supported\");\n    } // Create a local value and serialize it.\n\n\n    const localValue = this.localValueMaker.fromInMemory(value);\n    const serializableValue = makeSerializable(localValue, this.serializer, this.handle); // Set the value locally.\n\n    const previousValue = this.setCore(key, localValue, true); // If we are not attached, don't submit the op.\n\n    if (!this.isAttached()) {\n      return;\n    }\n\n    const op = {\n      key,\n      type: \"set\",\n      value: serializableValue\n    };\n    this.submitMapKeyMessage(op, previousValue);\n  }\n  /**\n   * Delete a key from the map.\n   * @param key - Key to delete\n   * @returns True if the key existed and was deleted, false if it did not exist\n   */\n\n\n  delete(key) {\n    // Delete the key locally first.\n    const previousValue = this.deleteCore(key, true); // If we are not attached, don't submit the op.\n\n    if (!this.isAttached()) {\n      return previousValue !== undefined;\n    }\n\n    const op = {\n      key,\n      type: \"delete\"\n    };\n    this.submitMapKeyMessage(op, previousValue);\n    return previousValue !== undefined;\n  }\n  /**\n   * Clear all data from the map.\n   */\n\n\n  clear() {\n    const copy = this.isAttached() ? new Map(this.data) : undefined; // Clear the data locally first.\n\n    this.clearCore(true); // If we are not attached, don't submit the op.\n\n    if (!this.isAttached()) {\n      return;\n    }\n\n    const op = {\n      type: \"clear\"\n    };\n    this.submitMapClearMessage(op, copy);\n  }\n  /**\n   * Serializes the data stored in the shared map to a JSON string\n   * @param serializer - The serializer to use to serialize handles in its values.\n   * @returns A JSON string containing serialized map data\n   */\n\n\n  getSerializedStorage(serializer) {\n    const serializableMapData = {};\n    this.data.forEach((localValue, key) => {\n      serializableMapData[key] = localValue.makeSerialized(serializer, this.handle);\n    });\n    return serializableMapData;\n  }\n\n  getSerializableStorage(serializer) {\n    const serializableMapData = {};\n    this.data.forEach((localValue, key) => {\n      serializableMapData[key] = makeSerializable(localValue, serializer, this.handle);\n    });\n    return serializableMapData;\n  }\n\n  serialize(serializer) {\n    return JSON.stringify(this.getSerializableStorage(serializer));\n  }\n  /**\n   * Populate the kernel with the given map data.\n   * @param data - A JSON string containing serialized map data\n   */\n\n\n  populateFromSerializable(json) {\n    for (const [key, serializable] of Object.entries(json)) {\n      const localValue = {\n        key,\n        value: this.makeLocal(key, serializable)\n      };\n      this.data.set(localValue.key, localValue.value);\n    }\n  }\n\n  populate(json) {\n    this.populateFromSerializable(JSON.parse(json));\n  }\n  /**\n   * Submit the given op if a handler is registered.\n   * @param op - The operation to attempt to submit\n   * @param localOpMetadata - The local metadata associated with the op. This is kept locally by the runtime\n   * and not sent to the server. This will be sent back when this message is received back from the server. This is\n   * also sent if we are asked to resubmit the message.\n   * @returns True if the operation was submitted, false otherwise.\n   */\n\n\n  trySubmitMessage(op, localOpMetadata) {\n    const handler = this.messageHandlers.get(op.type);\n\n    if (handler === undefined) {\n      return false;\n    }\n\n    handler.submit(op, localOpMetadata);\n    return true;\n  }\n\n  tryGetStashedOpLocalMetadata(op) {\n    const handler = this.messageHandlers.get(op.type);\n\n    if (handler === undefined) {\n      throw new Error(\"no apply stashed op handler\");\n    }\n\n    return handler.getStashedOpLocalMetadata(op);\n  }\n  /**\n   * Process the given op if a handler is registered.\n   * @param op - The message to process\n   * @param local - Whether the message originated from the local client\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @returns True if the operation was processed, false otherwise.\n   */\n\n\n  tryProcessMessage(op, local, localOpMetadata) {\n    const handler = this.messageHandlers.get(op.type);\n\n    if (handler === undefined) {\n      return false;\n    }\n\n    handler.process(op, local, localOpMetadata);\n    return true;\n  }\n  /**\n   * Rollback a local op\n   * @param op - The operation to rollback\n   * @param localOpMetadata - The local metadata associated with the op.\n   */\n\n\n  rollback(op, localOpMetadata) {\n    if (!isMapLocalOpMetadata(localOpMetadata)) {\n      throw new Error(\"Invalid localOpMetadata\");\n    }\n\n    if (op.type === \"clear\" && localOpMetadata.type === \"clear\") {\n      if (localOpMetadata.previousMap === undefined) {\n        throw new Error(\"Cannot rollback without previous map\");\n      }\n\n      localOpMetadata.previousMap.forEach((localValue, key) => {\n        this.setCore(key, localValue, true);\n      });\n      const lastPendingClearId = this.pendingClearMessageIds.pop();\n\n      if (lastPendingClearId === undefined || lastPendingClearId !== localOpMetadata.pendingMessageId) {\n        throw new Error(\"Rollback op does match last clear\");\n      }\n    } else if (op.type === \"delete\" || op.type === \"set\") {\n      if (localOpMetadata.type === \"add\") {\n        this.deleteCore(op.key, true);\n      } else if (localOpMetadata.type === \"edit\" && localOpMetadata.previousValue !== undefined) {\n        this.setCore(op.key, localOpMetadata.previousValue, true);\n      } else {\n        throw new Error(\"Cannot rollback without previous value\");\n      }\n\n      const pendingMessageIds = this.pendingKeys.get(op.key);\n      const lastPendingMessageId = pendingMessageIds === null || pendingMessageIds === void 0 ? void 0 : pendingMessageIds.pop();\n\n      if (!pendingMessageIds || lastPendingMessageId !== localOpMetadata.pendingMessageId) {\n        throw new Error(\"Rollback op does not match last pending\");\n      }\n\n      if (pendingMessageIds.length === 0) {\n        this.pendingKeys.delete(op.key);\n      }\n    } else {\n      throw new Error(\"Unsupported op for rollback\");\n    }\n  }\n  /**\n   * Set implementation used for both locally sourced sets as well as incoming remote sets.\n   * @param key - The key being set\n   * @param value - The value being set\n   * @param local - Whether the message originated from the local client\n   * @returns Previous local value of the key, if any\n   */\n\n\n  setCore(key, value, local) {\n    const previousLocalValue = this.data.get(key);\n    const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;\n    this.data.set(key, value);\n    this.eventEmitter.emit(\"valueChanged\", {\n      key,\n      previousValue\n    }, local, this.eventEmitter);\n    return previousLocalValue;\n  }\n  /**\n   * Clear implementation used for both locally sourced clears as well as incoming remote clears.\n   * @param local - Whether the message originated from the local client\n   */\n\n\n  clearCore(local) {\n    this.data.clear();\n    this.eventEmitter.emit(\"clear\", local, this.eventEmitter);\n  }\n  /**\n   * Delete implementation used for both locally sourced deletes as well as incoming remote deletes.\n   * @param key - The key being deleted\n   * @param local - Whether the message originated from the local client\n   * @returns Previous local value of the key if it existed, undefined if it did not exist\n   */\n\n\n  deleteCore(key, local) {\n    const previousLocalValue = this.data.get(key);\n    const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;\n    const successfullyRemoved = this.data.delete(key);\n\n    if (successfullyRemoved) {\n      this.eventEmitter.emit(\"valueChanged\", {\n        key,\n        previousValue\n      }, local, this.eventEmitter);\n    }\n\n    return previousLocalValue;\n  }\n  /**\n   * Clear all keys in memory in response to a remote clear, but retain keys we have modified but not yet been ack'd.\n   */\n\n\n  clearExceptPendingKeys() {\n    // Assuming the pendingKeys is small and the map is large\n    // we will get the value for the pendingKeys and clear the map\n    const temp = new Map();\n    this.pendingKeys.forEach((value, key) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      temp.set(key, this.data.get(key));\n    });\n    this.clearCore(false);\n    temp.forEach((value, key) => {\n      this.setCore(key, value, true);\n    });\n  }\n  /**\n   * The remote ISerializableValue we're receiving (either as a result of a load or an incoming set op) will\n   * have the information we need to create a real object, but will not be the real object yet.  For example,\n   * we might know it's a map and the map's ID but not have the actual map or its data yet.  makeLocal's\n   * job is to convert that information into a real object for local usage.\n   * @param key - The key that the caller intends to store the local value into (used for ops later).  But\n   * doesn't actually store the local value into that key.  So better not lie!\n   * @param serializable - The remote information that we can convert into a real object\n   * @returns The local value that was produced\n   */\n\n\n  makeLocal(key, serializable) {\n    if (serializable.type === ValueType[ValueType.Plain] || serializable.type === ValueType[ValueType.Shared]) {\n      return this.localValueMaker.fromSerializable(serializable);\n    } else {\n      throw new Error(\"Unknown local value type\");\n    }\n  }\n  /**\n   * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should\n   * not process the incoming operation.\n   * @param op - Operation to check\n   * @param local - Whether the message originated from the local client\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   * @returns True if the operation should be processed, false otherwise\n   */\n\n\n  needProcessKeyOperation(op, local, localOpMetadata) {\n    if (this.pendingClearMessageIds.length > 0) {\n      if (local) {\n        assert(localOpMetadata !== undefined && isMapKeyLocalOpMetadata(localOpMetadata) && localOpMetadata.pendingMessageId < this.pendingClearMessageIds[0], 0x013\n        /* \"Received out of order op when there is an unackd clear message\" */\n        );\n      } // If we have an unack'd clear, we can ignore all ops.\n\n\n      return false;\n    }\n\n    const pendingKeyMessageId = this.pendingKeys.get(op.key);\n\n    if (pendingKeyMessageId !== undefined) {\n      // Found an unack'd op. Clear it from the map if the pendingMessageId in the map matches this message's\n      // and don't process the op.\n      if (local) {\n        assert(localOpMetadata !== undefined && isMapKeyLocalOpMetadata(localOpMetadata), 0x014\n        /* pendingMessageId is missing from the local client's operation */\n        );\n        const pendingMessageIds = this.pendingKeys.get(op.key);\n        assert(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x2fa\n        /* Unexpected pending message received */\n        );\n        pendingMessageIds.shift();\n\n        if (pendingMessageIds.length === 0) {\n          this.pendingKeys.delete(op.key);\n        }\n      }\n\n      return false;\n    } // If we don't have a NACK op on the key, we need to process the remote ops.\n\n\n    return !local;\n  }\n  /**\n   * Get the message handlers for the map.\n   * @returns A map of string op names to IMapMessageHandlers for those ops\n   */\n\n\n  getMessageHandlers() {\n    const messageHandlers = new Map();\n    messageHandlers.set(\"clear\", {\n      process: (op, local, localOpMetadata) => {\n        if (local) {\n          assert(isClearLocalOpMetadata(localOpMetadata), 0x015\n          /* \"pendingMessageId is missing from the local client's clear operation\" */\n          );\n          const pendingClearMessageId = this.pendingClearMessageIds.shift();\n          assert(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x2fb\n          /* pendingMessageId does not match */\n          );\n          return;\n        }\n\n        if (this.pendingKeys.size !== 0) {\n          this.clearExceptPendingKeys();\n          return;\n        }\n\n        this.clearCore(local);\n      },\n      submit: (op, localOpMetadata) => {\n        assert(isClearLocalOpMetadata(localOpMetadata), 0x2fc\n        /* Invalid localOpMetadata for clear */\n        ); // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n\n        const pendingClearMessageId = this.pendingClearMessageIds.shift();\n        assert(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x2fd\n        /* pendingMessageId does not match */\n        );\n        this.submitMapClearMessage(op, localOpMetadata.previousMap);\n      },\n      getStashedOpLocalMetadata: op => {\n        // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n        return {\n          type: \"clear\",\n          pendingMessageId: this.getMapClearMessageId()\n        };\n      }\n    });\n    messageHandlers.set(\"delete\", {\n      process: (op, local, localOpMetadata) => {\n        if (!this.needProcessKeyOperation(op, local, localOpMetadata)) {\n          return;\n        }\n\n        this.deleteCore(op.key, local);\n      },\n      submit: (op, localOpMetadata) => {\n        this.resubmitMapKeyMessage(op, localOpMetadata);\n      },\n      getStashedOpLocalMetadata: op => {\n        // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n        return {\n          type: \"edit\",\n          pendingMessageId: this.getMapKeyMessageId(op)\n        };\n      }\n    });\n    messageHandlers.set(\"set\", {\n      process: (op, local, localOpMetadata) => {\n        if (!this.needProcessKeyOperation(op, local, localOpMetadata)) {\n          return;\n        } // needProcessKeyOperation should have returned false if local is true\n\n\n        const context = this.makeLocal(op.key, op.value);\n        this.setCore(op.key, context, local);\n      },\n      submit: (op, localOpMetadata) => {\n        this.resubmitMapKeyMessage(op, localOpMetadata);\n      },\n      getStashedOpLocalMetadata: op => {\n        // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n        return {\n          type: \"edit\",\n          pendingMessageId: this.getMapKeyMessageId(op)\n        };\n      }\n    });\n    return messageHandlers;\n  }\n\n  getMapClearMessageId() {\n    const pendingMessageId = ++this.pendingMessageId;\n    this.pendingClearMessageIds.push(pendingMessageId);\n    return pendingMessageId;\n  }\n  /**\n   * Submit a clear message to remote clients.\n   * @param op - The clear message\n   */\n\n\n  submitMapClearMessage(op, previousMap) {\n    const metadata = {\n      type: \"clear\",\n      pendingMessageId: this.getMapClearMessageId(),\n      previousMap\n    };\n    this.submitMessage(op, metadata);\n  }\n\n  getMapKeyMessageId(op) {\n    const pendingMessageId = ++this.pendingMessageId;\n    const pendingMessageIds = this.pendingKeys.get(op.key);\n\n    if (pendingMessageIds !== undefined) {\n      pendingMessageIds.push(pendingMessageId);\n    } else {\n      this.pendingKeys.set(op.key, [pendingMessageId]);\n    }\n\n    return pendingMessageId;\n  }\n  /**\n   * Submit a map key message to remote clients.\n   * @param op - The map key message\n   * @param previousValue - The value of the key before this op\n   */\n\n\n  submitMapKeyMessage(op, previousValue) {\n    const pendingMessageId = this.getMapKeyMessageId(op);\n    const localMetadata = previousValue ? {\n      type: \"edit\",\n      pendingMessageId,\n      previousValue\n    } : {\n      type: \"add\",\n      pendingMessageId\n    };\n    this.submitMessage(op, localMetadata);\n  }\n  /**\n   * Submit a map key message to remote clients based on a previous submit.\n   * @param op - The map key message\n   * @param localOpMetadata - Metadata from the previous submit\n   */\n\n\n  resubmitMapKeyMessage(op, localOpMetadata) {\n    assert(isMapKeyLocalOpMetadata(localOpMetadata), 0x2fe\n    /* Invalid localOpMetadata in submit */\n    ); // clear the old pending message id\n\n    const pendingMessageIds = this.pendingKeys.get(op.key);\n    assert(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x2ff\n    /* Unexpected pending message received */\n    );\n    pendingMessageIds.shift();\n\n    if (pendingMessageIds.length === 0) {\n      this.pendingKeys.delete(op.key);\n    } // We don't reuse the metadata pendingMessageId but send a new one on each submit.\n\n\n    const pendingMessageId = this.getMapKeyMessageId(op);\n    const localMetadata = localOpMetadata.type === \"edit\" ? {\n      type: \"edit\",\n      pendingMessageId,\n      previousValue: localOpMetadata.previousValue\n    } : {\n      type: \"add\",\n      pendingMessageId\n    };\n    this.submitMessage(op, localMetadata);\n  }\n\n} //# sourceMappingURL=mapKernel.js.map","map":null,"metadata":{},"sourceType":"module"}