{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { SortedSegmentSet } from \"@fluidframework/merge-tree\";\n/**\n * Base class for SequenceDeltaEvent and SequenceMaintenanceEvent.\n *\n * The properties of this object and its sub-objects represent the state of the sequence at the\n * point in time at which the operation was applied.\n * They will not take into any future modifications performed to the underlying sequence and merge tree.\n */\n\nexport class SequenceEvent {\n  constructor(deltaArgs, mergeTreeClient) {\n    this.deltaArgs = deltaArgs;\n    this.mergeTreeClient = mergeTreeClient;\n    assert(deltaArgs.deltaSegments.length > 0, 0x2d8\n    /* \"Empty change event should not be emitted.\" */\n    );\n    this.isEmpty = false;\n    this.deltaOperation = deltaArgs.operation;\n    this.sortedRanges = new Lazy(() => {\n      const set = new SortedSegmentSet();\n      this.deltaArgs.deltaSegments.forEach(delta => {\n        const newRange = {\n          operation: this.deltaArgs.operation,\n          position: this.mergeTreeClient.getPosition(delta.segment),\n          propertyDeltas: delta.propertyDeltas,\n          segment: delta.segment\n        };\n        set.addOrUpdate(newRange);\n      });\n      return set;\n    });\n    this.pFirst = new Lazy(() => this.sortedRanges.value.items[0]);\n    this.pLast = new Lazy(() => this.sortedRanges.value.items[this.sortedRanges.value.size - 1]);\n  }\n  /**\n   * The in-order ranges affected by this delta.\n   * These may not be continuous.\n   */\n\n\n  get ranges() {\n    return this.sortedRanges.value.items;\n  }\n  /**\n   * The client id of the client that made the change which caused the delta event\n   */\n\n\n  get clientId() {\n    return this.mergeTreeClient.longClientId;\n  }\n  /**\n   * The first of the modified ranges.\n   */\n\n\n  get first() {\n    return this.pFirst.value;\n  }\n  /**\n   * The last of the modified ranges.\n   */\n\n\n  get last() {\n    return this.pLast.value;\n  }\n\n}\n/**\n * The event object returned on sequenceDelta events.\n *\n * The properties of this object and its sub-objects represent the state of the sequence at the\n * point in time at which the operation was applied.\n * They will not take into consideration any future modifications performed to the underlying sequence and merge tree.\n *\n * For group ops, each op will get its own event, and the group op property will be set on the op args.\n *\n * Ops may get multiple events. For instance, an insert-replace will get a remove then an insert event.\n */\n\nexport class SequenceDeltaEvent extends SequenceEvent {\n  constructor(opArgs, deltaArgs, mergeTreeClient) {\n    super(deltaArgs, mergeTreeClient);\n    this.opArgs = opArgs;\n    this.isLocal = opArgs.sequencedMessage === undefined;\n  }\n\n}\n/**\n * The event object returned on maintenance events.\n *\n * The properties of this object and its sub-objects represent the state of the sequence at the\n * point in time at which the operation was applied.\n * They will not take into consideration any future modifications performed to the underlying sequence and merge tree.\n */\n\nexport class SequenceMaintenanceEvent extends SequenceEvent {\n  constructor(opArgs, deltaArgs, mergeTreeClient) {\n    super(deltaArgs, mergeTreeClient);\n    this.opArgs = opArgs;\n  }\n\n}\n\nclass Lazy {\n  constructor(valueGenerator) {\n    this.valueGenerator = valueGenerator;\n    this.pEvaluated = false;\n  }\n\n  get evaluated() {\n    return this.pEvaluated;\n  }\n\n  get value() {\n    if (!this.pEvaluated) {\n      this.pEvaluated = true;\n      this.pValue = this.valueGenerator();\n    }\n\n    return this.pValue;\n  }\n\n} //# sourceMappingURL=sequenceDeltaEvent.js.map","map":null,"metadata":{},"sourceType":"module"}