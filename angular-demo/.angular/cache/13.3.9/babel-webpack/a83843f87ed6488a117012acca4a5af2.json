{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n/* eslint-disable no-bitwise */\n\n\nimport { assert, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { UsageError } from \"@fluidframework/container-utils\";\nimport { addProperties, createMap, IntervalTree, LocalReference, MergeTreeDeltaType, PropertiesManager, RedBlackTree, ReferenceType, refTypeIncludesFlag, reservedRangeLabelsKey, UnassignedSequenceNumber } from \"@fluidframework/merge-tree\";\nimport { LoggingError } from \"@fluidframework/telemetry-utils\";\nimport { v4 as uuid } from \"uuid\";\nconst reservedIntervalIdKey = \"intervalId\";\nexport var IntervalType = /*#__PURE__*/(() => {\n  (function (IntervalType) {\n    IntervalType[IntervalType[\"Simple\"] = 0] = \"Simple\";\n    IntervalType[IntervalType[\"Nest\"] = 1] = \"Nest\";\n    /**\n     * SlideOnRemove indicates that the ends of the interval will slide if the segment\n     * they reference is removed and acked.\n     * See `packages\\dds\\merge-tree\\REFERENCEPOSITIONS.md` for details\n     * SlideOnRemove is the default interval behavior and does not need to be specified.\n     */\n\n    IntervalType[IntervalType[\"SlideOnRemove\"] = 2] = \"SlideOnRemove\";\n    /**\n     * @internal\n     * A temporary interval, used internally\n     */\n\n    IntervalType[IntervalType[\"Transient\"] = 4] = \"Transient\";\n  })(IntervalType || (IntervalType = {}));\n\n  return IntervalType;\n})();\n\n/**\n * Decompress an interval after loading a summary from JSON. The exact format\n * of this compression is unspecified and subject to change\n */\nfunction decompressInterval(interval, label) {\n  return {\n    start: interval[0],\n    end: interval[1],\n    sequenceNumber: interval[2],\n    intervalType: interval[3],\n    properties: Object.assign(Object.assign({}, interval[4]), {\n      [reservedRangeLabelsKey]: label\n    })\n  };\n}\n/**\n * Compress an interval prior to serialization as JSON. The exact format of this\n * compression is unspecified and subject to change\n */\n\n\nfunction compressInterval(interval) {\n  const {\n    start,\n    end,\n    sequenceNumber,\n    intervalType,\n    properties\n  } = interval;\n  return [start, end, sequenceNumber, intervalType, Object.assign(Object.assign({}, properties), {\n    [reservedRangeLabelsKey]: undefined\n  })];\n}\n\nexport class Interval {\n  constructor(start, end, props) {\n    this.start = start;\n    this.end = end;\n    this.propertyManager = new PropertiesManager();\n    this.properties = {};\n\n    if (props) {\n      this.addProperties(props);\n    }\n  }\n\n  getIntervalId() {\n    var _a;\n\n    const id = (_a = this.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];\n\n    if (id === undefined) {\n      return undefined;\n    }\n\n    return `${id}`;\n  }\n\n  getAdditionalPropertySets() {\n    return this.auxProps;\n  }\n\n  addPropertySet(props) {\n    if (this.auxProps === undefined) {\n      this.auxProps = [];\n    }\n\n    this.auxProps.push(props);\n  }\n\n  serialize(client) {\n    let seq = 0;\n\n    if (client) {\n      seq = client.getCurrentSeq();\n    }\n\n    const serializedInterval = {\n      end: this.end,\n      intervalType: 0,\n      sequenceNumber: seq,\n      start: this.start\n    };\n\n    if (this.properties) {\n      serializedInterval.properties = this.properties;\n    }\n\n    return serializedInterval;\n  }\n\n  clone() {\n    return new Interval(this.start, this.end, this.properties);\n  }\n\n  compare(b) {\n    const startResult = this.compareStart(b);\n\n    if (startResult === 0) {\n      const endResult = this.compareEnd(b);\n\n      if (endResult === 0) {\n        const thisId = this.getIntervalId();\n\n        if (thisId) {\n          const bId = b.getIntervalId();\n\n          if (bId) {\n            return thisId > bId ? 1 : thisId < bId ? -1 : 0;\n          }\n\n          return 0;\n        }\n\n        return 0;\n      } else {\n        return endResult;\n      }\n    } else {\n      return startResult;\n    }\n  }\n\n  compareStart(b) {\n    return this.start - b.start;\n  }\n\n  compareEnd(b) {\n    return this.end - b.end;\n  }\n\n  overlaps(b) {\n    const result = this.start <= b.end && this.end >= b.start;\n    return result;\n  }\n\n  union(b) {\n    return new Interval(Math.min(this.start, b.start), Math.max(this.end, b.end), this.properties);\n  }\n\n  getProperties() {\n    return this.properties;\n  }\n\n  addProperties(newProps, collaborating = false, seq, op) {\n    if (newProps) {\n      this.initializeProperties();\n      return this.propertyManager.addProperties(this.properties, newProps, op, seq, collaborating);\n    }\n  }\n\n  modify(label, start, end, op) {\n    const startPos = start !== null && start !== void 0 ? start : this.start;\n    const endPos = end !== null && end !== void 0 ? end : this.end;\n\n    if (this.start === startPos && this.end === endPos) {\n      // Return undefined to indicate that no change is necessary.\n      return;\n    }\n\n    const newInterval = new Interval(startPos, endPos);\n\n    if (this.properties) {\n      newInterval.initializeProperties();\n      this.propertyManager.copyTo(this.properties, newInterval.properties, newInterval.propertyManager);\n    }\n\n    return newInterval;\n  }\n\n  initializeProperties() {\n    if (!this.propertyManager) {\n      this.propertyManager = new PropertiesManager();\n    }\n\n    if (!this.properties) {\n      this.properties = createMap();\n    }\n  }\n\n}\nexport class SequenceInterval {\n  constructor(start, end, intervalType, props) {\n    this.start = start;\n    this.end = end;\n    this.intervalType = intervalType;\n    this.propertyManager = new PropertiesManager();\n    this.properties = {};\n\n    if (props) {\n      this.addProperties(props);\n    }\n  }\n  /**\n   * @internal\n   * Subscribes to position change events on this interval if there are no current listeners.\n   */\n\n\n  addPositionChangeListeners(beforePositionChange, afterPositionChange) {\n    var _a, _b;\n\n    var _c, _d;\n\n    if (this.callbacks === undefined) {\n      this.callbacks = {\n        beforePositionChange,\n        afterPositionChange\n      };\n      const startCbs = (_a = (_c = this.start).callbacks) !== null && _a !== void 0 ? _a : _c.callbacks = {};\n      const endCbs = (_b = (_d = this.end).callbacks) !== null && _b !== void 0 ? _b : _d.callbacks = {};\n      startCbs.beforeSlide = endCbs.beforeSlide = beforePositionChange;\n      startCbs.afterSlide = endCbs.afterSlide = afterPositionChange;\n    }\n  }\n  /**\n   * @internal\n   * Removes the currently subscribed position change listeners.\n   */\n\n\n  removePositionChangeListeners() {\n    if (this.callbacks) {\n      this.callbacks = undefined;\n      this.start.callbacks = undefined;\n      this.end.callbacks = undefined;\n    }\n  }\n\n  serialize(client) {\n    const startPosition = this.start.toPosition();\n    const endPosition = this.end.toPosition();\n    const serializedInterval = {\n      end: endPosition,\n      intervalType: this.intervalType,\n      sequenceNumber: client.getCurrentSeq(),\n      start: startPosition\n    };\n\n    if (this.properties) {\n      serializedInterval.properties = this.properties;\n    }\n\n    return serializedInterval;\n  }\n\n  clone() {\n    return new SequenceInterval(this.start, this.end, this.intervalType, this.properties);\n  }\n\n  compare(b) {\n    const startResult = this.compareStart(b);\n\n    if (startResult === 0) {\n      const endResult = this.compareEnd(b);\n\n      if (endResult === 0) {\n        const thisId = this.getIntervalId();\n\n        if (thisId) {\n          const bId = b.getIntervalId();\n\n          if (bId) {\n            return thisId > bId ? 1 : thisId < bId ? -1 : 0;\n          }\n\n          return 0;\n        }\n\n        return 0;\n      } else {\n        return endResult;\n      }\n    } else {\n      return startResult;\n    }\n  }\n\n  compareStart(b) {\n    return this.start.compare(b.start);\n  }\n\n  compareEnd(b) {\n    return this.end.compare(b.end);\n  }\n\n  overlaps(b) {\n    const result = this.start.compare(b.end) <= 0 && this.end.compare(b.start) >= 0;\n    return result;\n  }\n\n  getIntervalId() {\n    var _a;\n\n    const id = (_a = this.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];\n\n    if (id === undefined) {\n      return undefined;\n    }\n\n    return `${id}`;\n  }\n\n  union(b) {\n    return new SequenceInterval(this.start.min(b.start), this.end.max(b.end), this.intervalType);\n  }\n\n  addProperties(newProps, collab = false, seq, op) {\n    this.initializeProperties();\n    return this.propertyManager.addProperties(this.properties, newProps, op, seq, collab);\n  }\n\n  overlapsPos(bstart, bend) {\n    const startPos = this.start.toPosition();\n    const endPos = this.start.toPosition();\n    return endPos > bstart && startPos < bend;\n  }\n\n  modify(label, start, end, op) {\n    const getRefType = baseType => {\n      let refType = baseType;\n\n      if (op === undefined) {\n        refType &= ~ReferenceType.SlideOnRemove;\n        refType |= ReferenceType.StayOnRemove;\n      }\n\n      return refType;\n    };\n\n    let startRef = this.start;\n\n    if (start !== undefined) {\n      startRef = createPositionReference(this.start.getClient(), start, getRefType(this.start.refType), op);\n      startRef.addProperties(this.start.properties);\n    }\n\n    let endRef = this.end;\n\n    if (end !== undefined) {\n      endRef = createPositionReference(this.end.getClient(), end, getRefType(this.end.refType), op);\n      endRef.addProperties(this.end.properties);\n    }\n\n    startRef.pairedRef = endRef;\n    endRef.pairedRef = startRef;\n    const newInterval = new SequenceInterval(startRef, endRef, this.intervalType);\n\n    if (this.properties) {\n      newInterval.initializeProperties();\n      this.propertyManager.copyTo(this.properties, newInterval.properties, newInterval.propertyManager);\n    }\n\n    return newInterval;\n  }\n\n  initializeProperties() {\n    if (!this.propertyManager) {\n      this.propertyManager = new PropertiesManager();\n    }\n\n    if (!this.properties) {\n      this.properties = createMap();\n    }\n  }\n\n}\n\nfunction createPositionReferenceFromSegoff(client, segoff, refType, op) {\n  if (segoff.segment) {\n    const ref = client.createLocalReferencePosition(segoff.segment, segoff.offset, refType, undefined);\n    return ref;\n  } else {\n    if (!op && !refTypeIncludesFlag(refType, ReferenceType.Transient)) {\n      throw new UsageError(\"Non-transient references need segment\");\n    }\n\n    return new LocalReference(client, undefined, 0, refType);\n  }\n}\n\nfunction createPositionReference(client, pos, refType, op) {\n  let segoff;\n\n  if (op) {\n    assert((refType & ReferenceType.SlideOnRemove) !== 0, 0x2f5\n    /* op create references must be SlideOnRemove */\n    );\n    segoff = client.getContainingSegment(pos, op);\n    segoff = client.getSlideToSegment(segoff);\n  } else {\n    assert((refType & ReferenceType.SlideOnRemove) === 0, 0x2f6\n    /* SlideOnRemove references must be op created */\n    );\n    segoff = client.getContainingSegment(pos);\n  }\n\n  return createPositionReferenceFromSegoff(client, segoff, refType, op);\n}\n\nfunction createSequenceInterval(label, start, end, client, intervalType, op) {\n  let beginRefType = ReferenceType.RangeBegin;\n  let endRefType = ReferenceType.RangeEnd;\n\n  if (intervalType === IntervalType.Transient) {\n    beginRefType = ReferenceType.Transient;\n    endRefType = ReferenceType.Transient;\n  } else {\n    if (intervalType === IntervalType.Nest) {\n      beginRefType = ReferenceType.NestBegin;\n      endRefType = ReferenceType.NestEnd;\n    } // All non-transient interval references must eventually be SlideOnRemove\n    // To ensure eventual consistency, they must start as StayOnRemove when\n    // pending (created locally and creation op is not acked)\n\n\n    if (op) {\n      beginRefType |= ReferenceType.SlideOnRemove;\n      endRefType |= ReferenceType.SlideOnRemove;\n    } else {\n      beginRefType |= ReferenceType.StayOnRemove;\n      endRefType |= ReferenceType.StayOnRemove;\n    }\n  }\n\n  const startLref = createPositionReference(client, start, beginRefType, op);\n  const endLref = createPositionReference(client, end, endRefType, op);\n  startLref.pairedRef = endLref;\n  endLref.pairedRef = startLref;\n  const rangeProp = {\n    [reservedRangeLabelsKey]: [label]\n  };\n  startLref.addProperties(rangeProp);\n  endLref.addProperties(rangeProp);\n  const ival = new SequenceInterval(startLref, endLref, intervalType, rangeProp);\n  return ival;\n}\n\nexport function defaultIntervalConflictResolver(a, b) {\n  a.addPropertySet(b.properties);\n  return a;\n}\nexport function createIntervalIndex(conflict) {\n  const helpers = {\n    compareEnds: compareIntervalEnds,\n    create: createInterval\n  };\n  const lc = new LocalIntervalCollection(undefined, \"\", helpers);\n\n  if (conflict) {\n    lc.addConflictResolver(conflict);\n  } else {\n    lc.addConflictResolver(defaultIntervalConflictResolver);\n  }\n\n  return lc;\n}\nexport let LocalIntervalCollection = /*#__PURE__*/(() => {\n  class LocalIntervalCollection {\n    constructor(client, label, helpers,\n    /** Callback invoked each time one of the endpoints of an interval slides. */\n    onPositionChange) {\n      this.client = client;\n      this.label = label;\n      this.helpers = helpers;\n      this.onPositionChange = onPositionChange;\n      this.intervalTree = new IntervalTree();\n      this.intervalIdMap = new Map(); // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.endIntervalTree = new RedBlackTree(helpers.compareEnds);\n    }\n\n    addConflictResolver(conflictResolver) {\n      this.conflictResolver = conflictResolver;\n\n      this.endConflictResolver = (key, currentKey) => {\n        const ival = conflictResolver(key, currentKey);\n        return {\n          data: ival,\n          key: ival\n        };\n      };\n    }\n\n    map(fn) {\n      this.intervalTree.map(fn);\n    }\n\n    createLegacyId(start, end) {\n      // Create a non-unique ID based on start and end to be used on intervals that come from legacy clients\n      // without ID's.\n      return `${LocalIntervalCollection.legacyIdPrefix}${start}-${end}`;\n    }\n    /**\n     * Validates that a serialized interval has the ID property. Creates an ID\n     * if one does not already exist\n     *\n     * @param serializedInterval - The interval to be checked\n     * @returns The interval's existing or newly created id\n     */\n\n\n    ensureSerializedId(serializedInterval) {\n      var _a;\n\n      let id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];\n\n      if (id === undefined) {\n        // An interval came over the wire without an ID, so create a non-unique one based on start/end.\n        // This will allow all clients to refer to this interval consistently.\n        id = this.createLegacyId(serializedInterval.start, serializedInterval.end);\n        const newProps = {\n          [reservedIntervalIdKey]: id\n        };\n        serializedInterval.properties = addProperties(serializedInterval.properties, newProps);\n      } // Make the ID immutable for safety's sake.\n\n\n      Object.defineProperty(serializedInterval.properties, reservedIntervalIdKey, {\n        configurable: false,\n        enumerable: true,\n        writable: false\n      });\n      return id;\n    }\n\n    mapUntil(fn) {\n      this.intervalTree.mapUntil(fn);\n    }\n\n    gatherIterationResults(results, iteratesForward, start, end) {\n      if (this.intervalTree.intervals.isEmpty()) {\n        return;\n      }\n\n      if (start === undefined && end === undefined) {\n        // No start/end provided. Gather the whole tree in the specified order.\n        if (iteratesForward) {\n          this.intervalTree.map(interval => {\n            results.push(interval);\n          });\n        } else {\n          this.intervalTree.mapBackward(interval => {\n            results.push(interval);\n          });\n        }\n      } else {\n        const transientInterval = this.helpers.create(\"transient\", start, end, this.client, IntervalType.Transient);\n\n        if (start === undefined) {\n          // Only end position provided. Since the tree is not sorted by end position,\n          // walk the whole tree in the specified order, gathering intervals that match the end.\n          if (iteratesForward) {\n            this.intervalTree.map(interval => {\n              if (transientInterval.compareEnd(interval) === 0) {\n                results.push(interval);\n              }\n            });\n          } else {\n            this.intervalTree.mapBackward(interval => {\n              if (transientInterval.compareEnd(interval) === 0) {\n                results.push(interval);\n              }\n            });\n          }\n        } else {\n          // Start and (possibly) end provided. Walk the subtrees that may contain\n          // this start position.\n          const compareFn = end === undefined ? node => {\n            return transientInterval.compareStart(node.key);\n          } : node => {\n            return transientInterval.compare(node.key);\n          };\n\n          const continueLeftFn = cmpResult => cmpResult <= 0;\n\n          const continueRightFn = cmpResult => cmpResult >= 0;\n\n          const actionFn = node => {\n            results.push(node.key);\n          };\n\n          if (iteratesForward) {\n            this.intervalTree.intervals.walkExactMatchesForward(compareFn, actionFn, continueLeftFn, continueRightFn);\n          } else {\n            this.intervalTree.intervals.walkExactMatchesBackward(compareFn, actionFn, continueLeftFn, continueRightFn);\n          }\n        }\n      }\n    }\n\n    findOverlappingIntervals(startPosition, endPosition) {\n      if (endPosition < startPosition || this.intervalTree.intervals.isEmpty()) {\n        return [];\n      }\n\n      const transientInterval = this.helpers.create(\"transient\", startPosition, endPosition, this.client, IntervalType.Transient);\n      const overlappingIntervalNodes = this.intervalTree.match(transientInterval);\n      return overlappingIntervalNodes.map(node => node.key);\n    }\n\n    previousInterval(pos) {\n      const transientInterval = this.helpers.create(\"transient\", pos, pos, this.client, IntervalType.Transient);\n      const rbNode = this.endIntervalTree.floor(transientInterval);\n\n      if (rbNode) {\n        return rbNode.data;\n      }\n    }\n\n    nextInterval(pos) {\n      const transientInterval = this.helpers.create(\"transient\", pos, pos, this.client, IntervalType.Transient);\n      const rbNode = this.endIntervalTree.ceil(transientInterval);\n\n      if (rbNode) {\n        return rbNode.data;\n      }\n    }\n\n    removeInterval(startPosition, endPosition) {\n      const transientInterval = this.helpers.create(\"transient\", startPosition, endPosition, this.client, IntervalType.Transient);\n      this.intervalTree.remove(transientInterval);\n      this.endIntervalTree.remove(transientInterval);\n      return transientInterval;\n    }\n\n    removeIntervalFromIndex(interval) {\n      this.intervalTree.removeExisting(interval);\n      this.endIntervalTree.remove(interval);\n      const id = interval.getIntervalId();\n      assert(id !== undefined, 0x311\n      /* expected id to exist on interval */\n      );\n      this.intervalIdMap.delete(id);\n    }\n\n    removeExistingInterval(interval) {\n      this.removeIntervalFromIndex(interval);\n      this.removeIntervalListeners(interval);\n    }\n\n    createInterval(start, end, intervalType, op) {\n      return this.helpers.create(this.label, start, end, this.client, intervalType, op);\n    }\n\n    addInterval(start, end, intervalType, props, op) {\n      const interval = this.createInterval(start, end, intervalType, op);\n\n      if (interval) {\n        if (!interval.properties) {\n          interval.properties = createMap();\n        }\n\n        if (props) {\n          interval.addProperties(props);\n        }\n\n        if (interval.properties[reservedIntervalIdKey] === undefined) {\n          // Create a new ID.\n          interval.properties[reservedIntervalIdKey] = uuid();\n        }\n\n        this.add(interval);\n      }\n\n      return interval;\n    }\n\n    addIntervalToIndex(interval) {\n      const id = interval.getIntervalId();\n      assert(id !== undefined, 0x2c0\n      /* \"ID must be created before adding interval to collection\" */\n      ); // Make the ID immutable.\n\n      Object.defineProperty(interval.properties, reservedIntervalIdKey, {\n        configurable: false,\n        enumerable: true,\n        writable: false\n      });\n      this.intervalTree.put(interval, this.conflictResolver);\n      this.endIntervalTree.put(interval, interval, this.endConflictResolver);\n      this.intervalIdMap.set(id, interval);\n    }\n\n    add(interval) {\n      this.addIntervalToIndex(interval);\n      this.addIntervalListeners(interval);\n    }\n\n    getIntervalById(id) {\n      return this.intervalIdMap.get(id);\n    }\n\n    changeInterval(interval, start, end, op) {\n      const newInterval = interval.modify(this.label, start, end, op);\n\n      if (newInterval) {\n        this.removeExistingInterval(interval);\n        this.add(newInterval);\n      }\n\n      return newInterval;\n    }\n\n    serialize() {\n      const client = this.client;\n      const intervals = this.intervalTree.intervals.keys();\n      return {\n        label: this.label,\n        intervals: intervals.map(interval => compressInterval(interval.serialize(client))),\n        version: 2\n      };\n    }\n\n    addIntervalListeners(interval) {\n      if (interval instanceof SequenceInterval) {\n        interval.addPositionChangeListeners(() => this.removeIntervalFromIndex(interval), () => {\n          var _a;\n\n          this.addIntervalToIndex(interval);\n          (_a = this.onPositionChange) === null || _a === void 0 ? void 0 : _a.call(this, interval);\n        });\n      }\n    }\n\n    removeIntervalListeners(interval) {\n      if (interval instanceof SequenceInterval) {\n        interval.removePositionChangeListeners();\n      }\n    }\n\n  }\n\n  LocalIntervalCollection.legacyIdPrefix = \"legacy\";\n  return LocalIntervalCollection;\n})();\n\nconst compareSequenceIntervalEnds = (a, b) => a.end.compare(b.end);\n\nclass SequenceIntervalCollectionFactory {\n  load(emitter, raw = []) {\n    const helpers = {\n      compareEnds: compareSequenceIntervalEnds,\n      create: createSequenceInterval\n    };\n    return new IntervalCollection(helpers, true, emitter, raw);\n  }\n\n  store(value) {\n    return value.serializeInternal();\n  }\n\n}\n\nexport class SequenceIntervalCollectionValueType {\n  get name() {\n    return SequenceIntervalCollectionValueType.Name;\n  }\n\n  get factory() {\n    return SequenceIntervalCollectionValueType._factory;\n  }\n\n  get ops() {\n    return SequenceIntervalCollectionValueType._ops;\n  }\n\n}\nSequenceIntervalCollectionValueType.Name = \"sharedStringIntervalCollection\";\nSequenceIntervalCollectionValueType._factory = new SequenceIntervalCollectionFactory();\nSequenceIntervalCollectionValueType._ops = makeOpsMap();\n\nconst compareIntervalEnds = (a, b) => a.end - b.end;\n\nfunction createInterval(label, start, end, client) {\n  const rangeProp = {};\n\n  if (label && label.length > 0) {\n    rangeProp[reservedRangeLabelsKey] = [label];\n  }\n\n  return new Interval(start, end, rangeProp);\n}\n\nclass IntervalCollectionFactory {\n  load(emitter, raw = []) {\n    const helpers = {\n      compareEnds: compareIntervalEnds,\n      create: createInterval\n    };\n    const collection = new IntervalCollection(helpers, false, emitter, raw);\n    collection.attachGraph(undefined, \"\");\n    return collection;\n  }\n\n  store(value) {\n    return value.serializeInternal();\n  }\n\n}\n\nexport class IntervalCollectionValueType {\n  get name() {\n    return IntervalCollectionValueType.Name;\n  }\n\n  get factory() {\n    return IntervalCollectionValueType._factory;\n  }\n\n  get ops() {\n    return IntervalCollectionValueType._ops;\n  }\n\n}\nIntervalCollectionValueType.Name = \"sharedIntervalCollection\";\nIntervalCollectionValueType._factory = new IntervalCollectionFactory();\nIntervalCollectionValueType._ops = makeOpsMap();\n\nfunction makeOpsMap() {\n  const rebase = (collection, op, localOpMetadata) => {\n    const {\n      localSeq\n    } = localOpMetadata;\n    const rebasedValue = collection.rebaseLocalInterval(op.opName, op.value, localSeq);\n    const rebasedOp = Object.assign(Object.assign({}, op), {\n      value: rebasedValue\n    });\n    return {\n      rebasedOp,\n      rebasedLocalOpMetadata: localOpMetadata\n    };\n  };\n\n  return new Map([[\"add\", {\n    process: (collection, params, local, op) => {\n      collection.ackAdd(params, local, op);\n    },\n    rebase\n  }], [\"delete\", {\n    process: (collection, params, local, op) => {\n      collection.ackDelete(params, local, op);\n    },\n    rebase: (collection, op, localOpMetadata) => {\n      // Deletion of intervals is based on id, so requires no rebasing.\n      return {\n        rebasedOp: op,\n        rebasedLocalOpMetadata: localOpMetadata\n      };\n    }\n  }], [\"change\", {\n    process: (collection, params, local, op) => {\n      collection.ackChange(params, local, op);\n    },\n    rebase\n  }]]);\n}\n\nexport class IntervalCollectionIterator {\n  constructor(collection, iteratesForward = true, start, end) {\n    this.results = [];\n    this.index = 0;\n    collection.gatherIterationResults(this.results, iteratesForward, start, end);\n  }\n\n  next() {\n    let _value;\n\n    let _done = true;\n\n    if (this.index < this.results.length) {\n      _value = this.results[this.index++];\n      _done = false;\n    }\n\n    return {\n      value: _value,\n      done: _done\n    };\n  }\n\n}\nexport class IntervalCollection extends TypedEventEmitter {\n  /** @internal */\n  constructor(helpers, requiresClient, emitter, serializedIntervals) {\n    super();\n    this.helpers = helpers;\n    this.requiresClient = requiresClient;\n    this.emitter = emitter;\n    this.pendingChangesStart = new Map();\n    this.pendingChangesEnd = new Map();\n\n    if (Array.isArray(serializedIntervals)) {\n      this.savedSerializedIntervals = serializedIntervals;\n    } else {\n      this.savedSerializedIntervals = serializedIntervals.intervals.map(i => decompressInterval(i, serializedIntervals.label));\n    }\n  }\n\n  get attached() {\n    return !!this.localCollection;\n  }\n\n  attachGraph(client, label) {\n    if (this.attached) {\n      throw new LoggingError(\"Only supports one Sequence attach\");\n    }\n\n    if (client === undefined && this.requiresClient) {\n      throw new LoggingError(\"Client required for this collection\");\n    } // Instantiate the local interval collection based on the saved intervals\n\n\n    this.client = client;\n    this.localCollection = new LocalIntervalCollection(client, label, this.helpers, interval => this.emit(\"changeInterval\", interval, true, undefined));\n\n    if (this.savedSerializedIntervals) {\n      for (const serializedInterval of this.savedSerializedIntervals) {\n        this.localCollection.ensureSerializedId(serializedInterval);\n        this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties);\n      }\n    }\n\n    this.savedSerializedIntervals = undefined;\n  }\n  /**\n   * Gets the next local sequence number, modifying this client's collab window in doing so.\n   */\n\n\n  getNextLocalSeq() {\n    return ++this.client.getCollabWindow().localSeq;\n  }\n\n  getIntervalById(id) {\n    if (!this.attached) {\n      throw new LoggingError(\"attach must be called before accessing intervals\");\n    }\n\n    return this.localCollection.getIntervalById(id);\n  }\n  /**\n   * Create a new interval and add it to the collection\n   * @param start - interval start position\n   * @param end - interval end position\n   * @param intervalType - type of the interval. All intervals are SlideOnRemove. Intervals may not be Transient.\n   * @param props - properties of the interval\n   * @returns - the created interval\n   */\n\n\n  add(start, end, intervalType, props) {\n    var _a, _b;\n\n    if (!this.attached) {\n      throw new LoggingError(\"attach must be called prior to adding intervals\");\n    }\n\n    if (intervalType & IntervalType.Transient) {\n      throw new LoggingError(\"Can not add transient intervals\");\n    }\n\n    const interval = this.localCollection.addInterval(start, end, intervalType, props);\n\n    if (interval) {\n      const serializedInterval = {\n        end,\n        intervalType,\n        properties: interval.properties,\n        sequenceNumber: (_b = (_a = this.client) === null || _a === void 0 ? void 0 : _a.getCurrentSeq()) !== null && _b !== void 0 ? _b : 0,\n        start\n      }; // Local ops get submitted to the server. Remote ops have the deserializer run.\n\n      this.emitter.emit(\"add\", undefined, serializedInterval, {\n        localSeq: this.getNextLocalSeq()\n      });\n    }\n\n    this.emit(\"addInterval\", interval, true, undefined);\n    return interval;\n  }\n\n  deleteExistingInterval(interval, local, op) {\n    // The given interval is known to exist in the collection.\n    this.localCollection.removeExistingInterval(interval);\n\n    if (interval) {\n      // Local ops get submitted to the server. Remote ops have the deserializer run.\n      if (local) {\n        this.emitter.emit(\"delete\", undefined, interval.serialize(this.client), {\n          localSeq: this.getNextLocalSeq()\n        });\n      } else {\n        if (this.onDeserialize) {\n          this.onDeserialize(interval);\n        }\n      }\n    }\n\n    this.emit(\"deleteInterval\", interval, local, op);\n  }\n\n  removeIntervalById(id) {\n    const interval = this.localCollection.getIntervalById(id);\n\n    if (interval) {\n      this.deleteExistingInterval(interval, true, undefined);\n    }\n\n    return interval;\n  }\n\n  changeProperties(id, props) {\n    if (!this.attached) {\n      throw new LoggingError(\"Attach must be called before accessing intervals\");\n    }\n\n    if (typeof id !== \"string\") {\n      throw new LoggingError(\"Change API requires an ID that is a string\");\n    }\n\n    if (!props) {\n      throw new LoggingError(\"changeProperties should be called with a property set\");\n    }\n\n    const interval = this.getIntervalById(id);\n\n    if (interval) {\n      // Pass Unassigned as the sequence number to indicate that this is a local op that is waiting for an ack.\n      const deltaProps = interval.addProperties(props, true, UnassignedSequenceNumber);\n      const serializedInterval = interval.serialize(this.client); // Emit a change op that will only change properties. Add the ID to\n      // the property bag provided by the caller.\n\n      serializedInterval.start = undefined;\n      serializedInterval.end = undefined;\n      serializedInterval.properties = props;\n      serializedInterval.properties[reservedIntervalIdKey] = interval.getIntervalId();\n      this.emitter.emit(\"change\", undefined, serializedInterval, {\n        localSeq: this.getNextLocalSeq()\n      });\n      this.emit(\"propertyChanged\", interval, deltaProps);\n    }\n\n    this.emit(\"changeInterval\", interval, true, undefined);\n  }\n\n  change(id, start, end) {\n    if (!this.attached) {\n      throw new LoggingError(\"Attach must be called before accessing intervals\");\n    } // Force id to be a string.\n\n\n    if (typeof id !== \"string\") {\n      throw new LoggingError(\"Change API requires an ID that is a string\");\n    }\n\n    const interval = this.getIntervalById(id);\n\n    if (interval) {\n      const newInterval = this.localCollection.changeInterval(interval, start, end);\n      const serializedInterval = interval.serialize(this.client);\n      serializedInterval.start = start;\n      serializedInterval.end = end; // Emit a property bag containing only the ID, as we don't intend for this op to change any properties.\n\n      serializedInterval.properties = {\n        [reservedIntervalIdKey]: interval.getIntervalId()\n      };\n      this.emitter.emit(\"change\", undefined, serializedInterval, {\n        localSeq: this.getNextLocalSeq()\n      });\n      this.addPendingChange(id, serializedInterval);\n      this.emit(\"changeInterval\", newInterval, true, undefined);\n      return newInterval;\n    } // No interval to change\n\n\n    return undefined;\n  }\n\n  addPendingChange(id, serializedInterval) {\n    if (serializedInterval.start !== undefined) {\n      this.addPendingChangeHelper(id, this.pendingChangesStart, serializedInterval);\n    }\n\n    if (serializedInterval.end !== undefined) {\n      this.addPendingChangeHelper(id, this.pendingChangesEnd, serializedInterval);\n    }\n  }\n\n  addPendingChangeHelper(id, pendingChanges, serializedInterval) {\n    let entries = pendingChanges.get(id);\n\n    if (!entries) {\n      entries = [];\n      pendingChanges.set(id, entries);\n    }\n\n    entries.push(serializedInterval);\n  }\n\n  removePendingChange(serializedInterval) {\n    var _a; // Change ops always have an ID.\n\n\n    const id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];\n\n    if (serializedInterval.start !== undefined) {\n      this.removePendingChangeHelper(id, this.pendingChangesStart, serializedInterval);\n    }\n\n    if (serializedInterval.end !== undefined) {\n      this.removePendingChangeHelper(id, this.pendingChangesEnd, serializedInterval);\n    }\n  }\n\n  removePendingChangeHelper(id, pendingChanges, serializedInterval) {\n    const entries = pendingChanges.get(id);\n\n    if (entries) {\n      const pendingChange = entries.shift();\n\n      if (entries.length === 0) {\n        pendingChanges.delete(id);\n      }\n\n      if ((pendingChange === null || pendingChange === void 0 ? void 0 : pendingChange.start) !== serializedInterval.start || (pendingChange === null || pendingChange === void 0 ? void 0 : pendingChange.end) !== serializedInterval.end) {\n        throw new LoggingError(\"Mismatch in pending changes\");\n      }\n    }\n  }\n\n  hasPendingChangeStart(id) {\n    const entries = this.pendingChangesStart.get(id);\n    return entries && entries.length !== 0;\n  }\n\n  hasPendingChangeEnd(id) {\n    const entries = this.pendingChangesEnd.get(id);\n    return entries && entries.length !== 0;\n  }\n  /** @deprecated - use ackChange */\n\n\n  changeInterval(serializedInterval, local, op) {\n    return this.ackChange(serializedInterval, local, op);\n  }\n  /** @internal */\n\n\n  ackChange(serializedInterval, local, op) {\n    var _a, _b, _c, _d;\n\n    if (!this.attached) {\n      throw new LoggingError(\"Attach must be called before accessing intervals\");\n    }\n\n    let interval;\n\n    if (local) {\n      // This is an ack from the server. Remove the pending change.\n      this.removePendingChange(serializedInterval);\n      const id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];\n      interval = this.getIntervalById(id);\n\n      if (interval) {\n        // Let the propertyManager prune its pending change-properties set.\n        (_b = interval.propertyManager) === null || _b === void 0 ? void 0 : _b.ackPendingProperties({\n          type: MergeTreeDeltaType.ANNOTATE,\n          props: (_c = serializedInterval.properties) !== null && _c !== void 0 ? _c : {}\n        });\n        this.ackInterval(interval, op);\n      }\n    } else {\n      // If there are pending changes with this ID, don't apply the remote start/end change, as the local ack\n      // should be the winning change.\n      // Note that the ID is in the property bag only to allow us to find the interval.\n      // This API cannot change the ID, and writing to the ID property will result in an exception. So we\n      // strip it out of the properties here.\n      const _e = serializedInterval.properties,\n            _f = reservedIntervalIdKey,\n            id = _e[_f],\n            newProps = __rest(_e, [typeof _f === \"symbol\" ? _f : _f + \"\"]);\n\n      interval = this.getIntervalById(id);\n\n      if (interval) {\n        let start;\n        let end; // Track pending start/end independently of one another.\n\n        if (!this.hasPendingChangeStart(id)) {\n          start = serializedInterval.start;\n        }\n\n        if (!this.hasPendingChangeEnd(id)) {\n          end = serializedInterval.end;\n        }\n\n        if (start !== undefined || end !== undefined) {\n          // If changeInterval gives us a new interval, work with that one. Otherwise keep working with\n          // the one we originally found in the tree.\n          interval = (_d = this.localCollection.changeInterval(interval, start, end, op)) !== null && _d !== void 0 ? _d : interval;\n        }\n\n        const deltaProps = interval.addProperties(newProps, true, op.sequenceNumber);\n\n        if (this.onDeserialize) {\n          this.onDeserialize(interval);\n        }\n\n        this.emit(\"propertyChanged\", interval, deltaProps);\n      }\n    }\n\n    if (interval) {\n      this.emit(\"changeInterval\", interval, local, op);\n    }\n  }\n\n  addConflictResolver(conflictResolver) {\n    if (!this.attached) {\n      throw new LoggingError(\"attachSequence must be called\");\n    }\n\n    this.localCollection.addConflictResolver(conflictResolver);\n  }\n\n  attachDeserializer(onDeserialize) {\n    // If no deserializer is specified can skip all processing work\n    if (!onDeserialize) {\n      return;\n    } // Start by storing the callbacks so that any subsequent modifications make use of them\n\n\n    this.onDeserialize = onDeserialize; // Trigger the async prepare work across all values in the collection\n\n    this.localCollection.map(interval => {\n      onDeserialize(interval);\n    });\n  }\n  /** @internal */\n\n\n  rebaseLocalInterval(opName, serializedInterval, localSeq) {\n    var _a, _b;\n\n    if (!this.attached) {\n      throw new LoggingError(\"attachSequence must be called\");\n    }\n\n    const {\n      start,\n      end,\n      intervalType,\n      properties,\n      sequenceNumber\n    } = serializedInterval;\n    const startRebased = start === undefined ? undefined : this.client.rebasePosition(start, sequenceNumber, localSeq);\n    const endRebased = end === undefined ? undefined : this.client.rebasePosition(end, sequenceNumber, localSeq);\n    const intervalId = properties === null || properties === void 0 ? void 0 : properties[reservedIntervalIdKey];\n    const rebased = {\n      start: startRebased,\n      end: endRebased,\n      intervalType,\n      sequenceNumber: (_b = (_a = this.client) === null || _a === void 0 ? void 0 : _a.getCurrentSeq()) !== null && _b !== void 0 ? _b : 0,\n      properties\n    };\n\n    if (opName === \"change\" && (this.hasPendingChangeStart(intervalId) || this.hasPendingChangeEnd(intervalId))) {\n      this.removePendingChange(serializedInterval);\n      this.addPendingChange(intervalId, rebased);\n    }\n\n    return rebased;\n  }\n\n  getSlideToSegment(lref) {\n    const segoff = {\n      segment: lref.segment,\n      offset: lref.offset\n    };\n    const newSegoff = this.client.getSlideToSegment(segoff);\n    const value = segoff.segment === newSegoff.segment && segoff.offset === newSegoff.offset ? undefined : newSegoff;\n    return value;\n  }\n\n  setSlideOnRemove(lref) {\n    let refType = lref.refType;\n    refType = refType & ~ReferenceType.StayOnRemove;\n    refType = refType | ReferenceType.SlideOnRemove;\n    lref.refType = refType;\n  }\n\n  ackInterval(interval, op) {\n    // in current usage, interval is always a SequenceInterval\n    if (!(interval instanceof SequenceInterval)) {\n      return;\n    }\n\n    if (!refTypeIncludesFlag(interval.start, ReferenceType.StayOnRemove) && !refTypeIncludesFlag(interval.end, ReferenceType.StayOnRemove)) {\n      return;\n    }\n\n    const newStart = this.getSlideToSegment(interval.start);\n    const newEnd = this.getSlideToSegment(interval.end);\n    const id = interval.properties[reservedIntervalIdKey];\n    const hasPendingStartChange = this.hasPendingChangeStart(id);\n    const hasPendingEndChange = this.hasPendingChangeEnd(id);\n\n    if (!hasPendingStartChange) {\n      this.setSlideOnRemove(interval.start);\n    }\n\n    if (!hasPendingEndChange) {\n      this.setSlideOnRemove(interval.end);\n    }\n\n    const needsStartUpdate = newStart !== undefined && !hasPendingStartChange;\n    const needsEndUpdate = newEnd !== undefined && !hasPendingEndChange;\n\n    if (needsStartUpdate || needsEndUpdate) {\n      // In this case, where we change the start or end of an interval,\n      // it is necessary to remove and re-add the interval listeners.\n      // This ensures that the correct listeners are added to the ReferencePosition.\n      this.localCollection.removeExistingInterval(interval);\n\n      if (needsStartUpdate) {\n        const props = interval.start.properties;\n        this.client.removeLocalReferencePosition(interval.start);\n        interval.start = createPositionReferenceFromSegoff(this.client, newStart, interval.start.refType, op);\n\n        if (props) {\n          interval.start.addProperties(props);\n        }\n      }\n\n      if (needsEndUpdate) {\n        const props = interval.end.properties;\n        this.client.removeLocalReferencePosition(interval.end);\n        interval.end = createPositionReferenceFromSegoff(this.client, newEnd, interval.end.refType, op);\n\n        if (props) {\n          interval.end.addProperties(props);\n        }\n      }\n\n      this.localCollection.add(interval);\n    }\n  }\n  /** @deprecated - use ackAdd */\n\n\n  addInternal(serializedInterval, local, op) {\n    return this.ackAdd(serializedInterval, local, op);\n  }\n  /** @internal */\n\n\n  ackAdd(serializedInterval, local, op) {\n    var _a;\n\n    if (local) {\n      const id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];\n      const localInterval = this.getIntervalById(id);\n\n      if (localInterval) {\n        this.ackInterval(localInterval, op);\n      }\n\n      return;\n    }\n\n    if (!this.attached) {\n      throw new LoggingError(\"attachSequence must be called\");\n    }\n\n    this.localCollection.ensureSerializedId(serializedInterval);\n    const interval = this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties, op);\n\n    if (interval) {\n      if (this.onDeserialize) {\n        this.onDeserialize(interval);\n      }\n    }\n\n    this.emit(\"addInterval\", interval, local, op);\n    return interval;\n  }\n  /** @deprecated - use ackDelete */\n\n\n  deleteInterval(serializedInterval, local, op) {\n    return this.ackDelete(serializedInterval, local, op);\n  }\n  /** @internal */\n\n\n  ackDelete(serializedInterval, local, op) {\n    if (local) {\n      // Local ops were applied when the message was created and there's no \"pending delete\"\n      // state to bookkeep: remote operation application takes into account possibility of\n      // locally deleted interval whenever a lookup happens.\n      return;\n    }\n\n    if (!this.attached) {\n      throw new LoggingError(\"attach must be called prior to deleting intervals\");\n    }\n\n    const id = this.localCollection.ensureSerializedId(serializedInterval);\n    const interval = this.localCollection.getIntervalById(id);\n\n    if (interval) {\n      this.deleteExistingInterval(interval, local, op);\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  serializeInternal() {\n    if (!this.attached) {\n      throw new LoggingError(\"attachSequence must be called\");\n    }\n\n    return this.localCollection.serialize();\n  }\n\n  [Symbol.iterator]() {\n    const iterator = new IntervalCollectionIterator(this);\n    return iterator;\n  }\n\n  CreateForwardIteratorWithStartPosition(startPosition) {\n    const iterator = new IntervalCollectionIterator(this, true, startPosition);\n    return iterator;\n  }\n\n  CreateBackwardIteratorWithStartPosition(startPosition) {\n    const iterator = new IntervalCollectionIterator(this, false, startPosition);\n    return iterator;\n  }\n\n  CreateForwardIteratorWithEndPosition(endPosition) {\n    const iterator = new IntervalCollectionIterator(this, true, undefined, endPosition);\n    return iterator;\n  }\n\n  CreateBackwardIteratorWithEndPosition(endPosition) {\n    const iterator = new IntervalCollectionIterator(this, false, undefined, endPosition);\n    return iterator;\n  }\n\n  gatherIterationResults(results, iteratesForward, start, end) {\n    if (!this.attached) {\n      return;\n    }\n\n    this.localCollection.gatherIterationResults(results, iteratesForward, start, end);\n  }\n\n  findOverlappingIntervals(startPosition, endPosition) {\n    if (!this.attached) {\n      throw new LoggingError(\"attachSequence must be called\");\n    }\n\n    return this.localCollection.findOverlappingIntervals(startPosition, endPosition);\n  }\n\n  map(fn) {\n    if (!this.attached) {\n      throw new LoggingError(\"attachSequence must be called\");\n    }\n\n    this.localCollection.map(fn);\n  }\n\n  previousInterval(pos) {\n    if (!this.attached) {\n      throw new LoggingError(\"attachSequence must be called\");\n    }\n\n    return this.localCollection.previousInterval(pos);\n  }\n\n  nextInterval(pos) {\n    if (!this.attached) {\n      throw new LoggingError(\"attachSequence must be called\");\n    }\n\n    return this.localCollection.nextInterval(pos);\n  }\n\n} //# sourceMappingURL=intervalCollection.js.map","map":null,"metadata":{},"sourceType":"module"}