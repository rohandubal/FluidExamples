{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { stringToBuffer, Uint8ArrayToString } from \"@fluidframework/common-utils\";\nimport { buildHierarchy } from \"@fluidframework/protocol-base\";\nimport { SummaryTreeUploadManager } from \"@fluidframework/server-services-client\";\nimport { PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { InMemoryCache } from \"./cache\";\nimport { RetriableGitManager } from \"./retriableGitManager\";\nconst isNode = typeof window === \"undefined\";\n/**\n * Document access to underlying storage for routerlicious driver.\n * Uploads summaries piece-by-piece traversing the tree recursively.\n * Downloads summaries piece-by-piece on-demand, or up-front when prefetch is enabled.\n */\n\nexport class ShreddedSummaryDocumentStorageService {\n  constructor(id, manager, logger, policies = {}, driverPolicies, blobCache, snapshotTreeCache, getStorageManager = /*#__PURE__*/_asyncToGenerator(function* () {\n    return _this.manager;\n  })) {\n    var _this = this;\n\n    this.id = id;\n    this.manager = manager;\n    this.logger = logger;\n    this.policies = policies;\n    this.getStorageManager = getStorageManager; // The values of this cache is useless. We only need the keys. So we are always putting\n    // empty strings as values.\n\n    this.blobsShaCache = new Map();\n\n    if ((driverPolicies === null || driverPolicies === void 0 ? void 0 : driverPolicies.enableRestLess) === true || isNode) {\n      this.blobCache = blobCache !== null && blobCache !== void 0 ? blobCache : new InMemoryCache();\n      this.snapshotTreeCache = snapshotTreeCache !== null && snapshotTreeCache !== void 0 ? snapshotTreeCache : new InMemoryCache();\n    }\n  }\n\n  get repositoryUrl() {\n    return \"\";\n  }\n\n  getSummaryUploadManager() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const manager = yield _this2.getStorageManager();\n      return new SummaryTreeUploadManager(new RetriableGitManager(manager, _this2.logger), _this2.blobsShaCache, _this2.getPreviousFullSnapshot.bind(_this2));\n    })();\n  }\n\n  getVersions(versionId, count) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const id = versionId ? versionId : _this3.id;\n      const commits = yield PerformanceEvent.timedExecAsync(_this3.logger, {\n        eventName: \"getVersions\",\n        versionId: id,\n        count\n      }, /*#__PURE__*/_asyncToGenerator(function* () {\n        const manager = yield _this3.getStorageManager();\n        return manager.getCommits(id, count);\n      }));\n      return commits.map(commit => ({\n        date: commit.commit.author.date,\n        id: commit.sha,\n        treeId: commit.commit.tree.sha\n      }));\n    })();\n  }\n\n  getSnapshotTree(version) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      let requestVersion = version;\n\n      if (!requestVersion) {\n        const versions = yield _this4.getVersions(_this4.id, 1);\n\n        if (versions.length === 0) {\n          return null;\n        }\n\n        requestVersion = versions[0];\n      }\n\n      const cachedSnapshotTree = yield (_a = _this4.snapshotTreeCache) === null || _a === void 0 ? void 0 : _a.get(_this4.getCacheKey(requestVersion.treeId));\n\n      if (cachedSnapshotTree) {\n        return cachedSnapshotTree.snapshotTree;\n      }\n\n      const rawTree = yield PerformanceEvent.timedExecAsync(_this4.logger, {\n        eventName: \"getSnapshotTree\",\n        treeId: requestVersion.treeId\n      }, /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (event) {\n          const manager = yield _this4.getStorageManager();\n          const response = yield manager.getTree(requestVersion.treeId);\n          event.end({\n            size: response.tree.length\n          });\n          return response;\n        });\n\n        return function (_x) {\n          return _ref3.apply(this, arguments);\n        };\n      }());\n      const tree = buildHierarchy(rawTree, _this4.blobsShaCache, true);\n      yield (_b = _this4.snapshotTreeCache) === null || _b === void 0 ? void 0 : _b.put(_this4.getCacheKey(tree.id), {\n        id: requestVersion.id,\n        snapshotTree: tree\n      });\n      return tree;\n    })();\n  }\n\n  readBlob(blobId) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      const cachedBlob = yield (_a = _this5.blobCache) === null || _a === void 0 ? void 0 : _a.get(_this5.getCacheKey(blobId));\n\n      if (cachedBlob) {\n        return cachedBlob;\n      }\n\n      const value = yield PerformanceEvent.timedExecAsync(_this5.logger, {\n        eventName: \"readBlob\",\n        blobId\n      }, /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (event) {\n          const manager = yield _this5.getStorageManager();\n          const response = yield manager.getBlob(blobId);\n          event.end({\n            size: response.size\n          });\n          return response;\n        });\n\n        return function (_x2) {\n          return _ref4.apply(this, arguments);\n        };\n      }());\n\n      _this5.blobsShaCache.set(value.sha, \"\");\n\n      const bufferContent = stringToBuffer(value.content, value.encoding);\n      yield (_b = _this5.blobCache) === null || _b === void 0 ? void 0 : _b.put(_this5.getCacheKey(value.sha), bufferContent);\n      return bufferContent;\n    })();\n  }\n\n  uploadSummaryWithContext(summary, context) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const summaryHandle = yield PerformanceEvent.timedExecAsync(_this6.logger, {\n        eventName: \"uploadSummaryWithContext\"\n      }, /*#__PURE__*/_asyncToGenerator(function* () {\n        var _a;\n\n        const summaryUploadManager = yield _this6.getSummaryUploadManager();\n        return summaryUploadManager.writeSummaryTree(summary, (_a = context.ackHandle) !== null && _a !== void 0 ? _a : \"\", \"channel\");\n      }));\n      return summaryHandle;\n    })();\n  }\n\n  downloadSummary(handle) {\n    return _asyncToGenerator(function* () {\n      throw new Error(\"NOT IMPLEMENTED!\");\n    })();\n  }\n\n  createBlob(file) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const uint8ArrayFile = new Uint8Array(file);\n      return PerformanceEvent.timedExecAsync(_this7.logger, {\n        eventName: \"createBlob\",\n        size: uint8ArrayFile.length\n      }, /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator(function* (event) {\n          const manager = yield _this7.getStorageManager();\n          const response = yield manager.createBlob(Uint8ArrayToString(uint8ArrayFile, \"base64\"), \"base64\").then(r => ({\n            id: r.sha,\n            url: r.url\n          }));\n          event.end({\n            blobId: response.id\n          });\n          return response;\n        });\n\n        return function (_x3) {\n          return _ref6.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n  getPreviousFullSnapshot(parentHandle) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      return parentHandle ? _this8.getVersions(parentHandle, 1).then( /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator(function* (versions) {\n          // Clear the cache as the getSnapshotTree call will fill the cache.\n          _this8.blobsShaCache.clear();\n\n          return _this8.getSnapshotTree(versions[0]);\n        });\n\n        return function (_x4) {\n          return _ref7.apply(this, arguments);\n        };\n      }()) : undefined;\n    })();\n  }\n\n  getCacheKey(blobId) {\n    return `${this.id}:${blobId}`;\n  }\n\n} //# sourceMappingURL=shreddedSummaryDocumentStorageService.js.map","map":null,"metadata":{},"sourceType":"module"}