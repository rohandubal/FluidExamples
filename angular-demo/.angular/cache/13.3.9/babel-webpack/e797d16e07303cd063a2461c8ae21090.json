{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BaseTelemetryNullLogger, performance } from \"@fluidframework/common-utils\";\nimport { CachedConfigProvider, loggerIsMonitoringContext, mixinMonitoringContext } from \"./config\";\nimport { isILoggingError, extractLogSafeErrorProperties, generateStack } from \"./errorLogging\";\n/**\n * Broad classifications to be applied to individual properties as they're prepared to be logged to telemetry.\n * Please do not modify existing entries for backwards compatibility.\n */\n\nexport var TelemetryDataTag = /*#__PURE__*/(() => {\n  (function (TelemetryDataTag) {\n    /**\n     * Data containing terms from code packages that may have been dynamically loaded\n     * @deprecated 1.0, will be removed in next release (see issue #6603). Use `TelemetryDataTag.CodeArtifact` instead.\n     */\n    TelemetryDataTag[\"PackageData\"] = \"PackageData\";\n    /** Data containing terms or IDs from code packages that may have been dynamically loaded */\n\n    TelemetryDataTag[\"CodeArtifact\"] = \"CodeArtifact\";\n    /** Personal data of a variety of classifications that pertains to the user */\n\n    TelemetryDataTag[\"UserData\"] = \"UserData\";\n  })(TelemetryDataTag || (TelemetryDataTag = {}));\n\n  return TelemetryDataTag;\n})();\n\n/**\n * TelemetryLogger class contains various helper telemetry methods,\n * encoding in one place schemas for various types of Fluid telemetry events.\n * Creates sub-logger that appends properties to all events\n */\nexport let TelemetryLogger = /*#__PURE__*/(() => {\n  class TelemetryLogger {\n    constructor(namespace, properties) {\n      this.namespace = namespace;\n      this.properties = properties;\n    }\n\n    static formatTick(tick) {\n      return Math.floor(tick);\n    }\n    /**\n     * Attempts to parse number from string.\n     * If fails,returns original string.\n     * Used to make telemetry data typed (and support math operations, like comparison),\n     * in places where we do expect numbers (like contentsize/duration property in http header)\n     */\n\n\n    static numberFromString(str) {\n      if (str === undefined || str === null) {\n        return undefined;\n      }\n\n      const num = Number(str);\n      return Number.isNaN(num) ? str : num;\n    }\n\n    static sanitizePkgName(name) {\n      return name.replace(\"@\", \"\").replace(\"/\", \"-\");\n    }\n    /**\n     * Take an unknown error object and add the appropriate info from it to the event. Message and stack will be copied\n     * over from the error object, along with other telemetry properties if it's an ILoggingError.\n     * @param event - Event being logged\n     * @param error - Error to extract info from\n     * @param fetchStack - Whether to fetch the current callstack if error.stack is undefined\n     */\n\n\n    static prepareErrorObject(event, error, fetchStack) {\n      const {\n        message,\n        errorType,\n        stack\n      } = extractLogSafeErrorProperties(error, true\n      /* sanitizeStack */\n      ); // First, copy over error message, stack, and errorType directly (overwrite if present on event)\n\n      event.stack = stack;\n      event.error = message; // Note that the error message goes on the 'error' field\n\n      event.errorType = errorType;\n\n      if (isILoggingError(error)) {\n        // Add any other telemetry properties from the LoggingError\n        const telemetryProp = error.getTelemetryProperties();\n\n        for (const key of Object.keys(telemetryProp)) {\n          if (event[key] !== undefined) {\n            // Don't overwrite existing properties on the event\n            continue;\n          }\n\n          event[key] = telemetryProp[key];\n        }\n      } // Collect stack if we were not able to extract it from error\n\n\n      if (event.stack === undefined && fetchStack) {\n        event.stack = generateStack();\n      }\n    }\n    /**\n     * Send a telemetry event with the logger\n     *\n     * @param event - the event to send\n     * @param error - optional error object to log\n     */\n\n\n    sendTelemetryEvent(event, error) {\n      var _a;\n\n      this.sendTelemetryEventCore(Object.assign(Object.assign({}, event), {\n        category: (_a = event.category) !== null && _a !== void 0 ? _a : \"generic\"\n      }), error);\n    }\n    /**\n     * Send a telemetry event with the logger\n     *\n     * @param event - the event to send\n     * @param error - optional error object to log\n     */\n\n\n    sendTelemetryEventCore(event, error) {\n      const newEvent = Object.assign({}, event);\n\n      if (error !== undefined) {\n        TelemetryLogger.prepareErrorObject(newEvent, error, false);\n      } // Will include Nan & Infinity, but probably we do not care\n\n\n      if (typeof newEvent.duration === \"number\") {\n        newEvent.duration = TelemetryLogger.formatTick(newEvent.duration);\n      }\n\n      this.send(newEvent);\n    }\n    /**\n     * Send an error telemetry event with the logger\n     *\n     * @param event - the event to send\n     * @param error - optional error object to log\n     */\n\n\n    sendErrorEvent(event, error) {\n      this.sendTelemetryEventCore(Object.assign(Object.assign({\n        // ensure the error field has some value,\n        // this can and will be overridden by event, or error\n        error: event.eventName\n      }, event), {\n        category: \"error\"\n      }), error);\n    }\n    /**\n     * Send a performance telemetry event with the logger\n     *\n     * @param event - Event to send\n     * @param error - optional error object to log\n     */\n\n\n    sendPerformanceEvent(event, error) {\n      var _a;\n\n      const perfEvent = Object.assign(Object.assign({}, event), {\n        category: (_a = event.category) !== null && _a !== void 0 ? _a : \"performance\"\n      });\n      this.sendTelemetryEventCore(perfEvent, error);\n    }\n\n    prepareEvent(event) {\n      const includeErrorProps = event.category === \"error\" || event.error !== undefined;\n      const newEvent = Object.assign({}, event);\n\n      if (this.namespace !== undefined) {\n        newEvent.eventName = `${this.namespace}${TelemetryLogger.eventNamespaceSeparator}${newEvent.eventName}`;\n      }\n\n      if (this.properties) {\n        const properties = [];\n        properties.push(this.properties.all);\n\n        if (includeErrorProps) {\n          properties.push(this.properties.error);\n        }\n\n        for (const props of properties) {\n          if (props !== undefined) {\n            for (const key of Object.keys(props)) {\n              if (event[key] !== undefined) {\n                continue;\n              }\n\n              const getterOrValue = props[key]; // If this throws, hopefully it is handled elsewhere\n\n              const value = typeof getterOrValue === \"function\" ? getterOrValue() : getterOrValue;\n\n              if (value !== undefined) {\n                newEvent[key] = value;\n              }\n            }\n          }\n        }\n      }\n\n      return newEvent;\n    }\n\n  }\n\n  TelemetryLogger.eventNamespaceSeparator = \":\";\n  /**\n   * @deprecated 0.56, remove TaggedLoggerAdapter once its usage is removed from\n   * container-runtime. Issue: #8191\n   * TaggedLoggerAdapter class can add tag handling to your logger.\n   */\n\n  return TelemetryLogger;\n})();\nexport class TaggedLoggerAdapter {\n  constructor(logger) {\n    this.logger = logger;\n  }\n\n  send(eventWithTagsMaybe) {\n    const newEvent = {\n      category: eventWithTagsMaybe.category,\n      eventName: eventWithTagsMaybe.eventName\n    };\n\n    for (const key of Object.keys(eventWithTagsMaybe)) {\n      const taggableProp = eventWithTagsMaybe[key];\n      const {\n        value,\n        tag\n      } = typeof taggableProp === \"object\" ? taggableProp : {\n        value: taggableProp,\n        tag: undefined\n      };\n\n      switch (tag) {\n        case undefined:\n          // No tag means we can log plainly\n          newEvent[key] = value;\n          break;\n\n        case TelemetryDataTag.PackageData:\n          // For Microsoft applications, PackageData is safe for now\n          // (we don't load 3P code in 1P apps)\n          newEvent[key] = value;\n          break;\n\n        case TelemetryDataTag.UserData:\n          // Strip out anything tagged explicitly as PII.\n          // Alternate strategy would be to hash these props\n          newEvent[key] = \"REDACTED (UserData)\";\n          break;\n\n        default:\n          // If we encounter a tag we don't recognize\n          // then we must assume we should scrub.\n          newEvent[key] = \"REDACTED (unknown tag)\";\n          break;\n      }\n    }\n\n    this.logger.send(newEvent);\n  }\n\n}\n/**\n * ChildLogger class contains various helper telemetry methods,\n * encoding in one place schemas for various types of Fluid telemetry events.\n * Creates sub-logger that appends properties to all events\n */\n\nexport class ChildLogger extends TelemetryLogger {\n  constructor(baseLogger, namespace, properties) {\n    super(namespace, properties);\n    this.baseLogger = baseLogger; // propagate the monitoring context\n\n    if (loggerIsMonitoringContext(baseLogger)) {\n      mixinMonitoringContext(this, new CachedConfigProvider(baseLogger.config));\n    }\n  }\n  /**\n   * Create child logger\n   * @param baseLogger - Base logger to use to output events. If undefined, proper child logger\n   * is created, but it does not sends telemetry events anywhere.\n   * @param namespace - Telemetry event name prefix to add to all events\n   * @param properties - Base properties to add to all events\n   * @param propertyGetters - Getters to add additional properties to all events\n   */\n\n\n  static create(baseLogger, namespace, properties) {\n    // if we are creating a child of a child, rather than nest, which will increase\n    // the callstack overhead, just generate a new logger that includes everything from the previous\n    if (baseLogger instanceof ChildLogger) {\n      const combinedProperties = {};\n\n      for (const extendedProps of [baseLogger.properties, properties]) {\n        if (extendedProps !== undefined) {\n          if (extendedProps.all !== undefined) {\n            combinedProperties.all = Object.assign(Object.assign({}, combinedProperties.all), extendedProps.all);\n          }\n\n          if (extendedProps.error !== undefined) {\n            combinedProperties.error = Object.assign(Object.assign({}, combinedProperties.error), extendedProps.error);\n          }\n        }\n      }\n\n      const combinedNamespace = baseLogger.namespace === undefined ? namespace : namespace === undefined ? baseLogger.namespace : `${baseLogger.namespace}${TelemetryLogger.eventNamespaceSeparator}${namespace}`;\n      return new ChildLogger(baseLogger.baseLogger, combinedNamespace, combinedProperties);\n    }\n\n    return new ChildLogger(baseLogger ? baseLogger : new BaseTelemetryNullLogger(), namespace, properties);\n  }\n  /**\n   * Send an event with the logger\n   *\n   * @param event - the event to send\n   */\n\n\n  send(event) {\n    this.baseLogger.send(this.prepareEvent(event));\n  }\n\n}\n/**\n * Multi-sink logger\n * Takes multiple ITelemetryBaseLogger objects (sinks) and logs all events into each sink\n * Implements ITelemetryBaseLogger (through static create() method)\n */\n\nexport class MultiSinkLogger extends TelemetryLogger {\n  /**\n   * Create multiple sink logger (i.e. logger that sends events to multiple sinks)\n   * @param namespace - Telemetry event name prefix to add to all events\n   * @param properties - Base properties to add to all events\n   * @param propertyGetters - Getters to add additional properties to all events\n   */\n  constructor(namespace, properties) {\n    super(namespace, properties);\n    this.loggers = [];\n  }\n  /**\n   * Add logger to send all events to\n   * @param logger - Logger to add\n   */\n\n\n  addLogger(logger) {\n    if (logger !== undefined && logger !== null) {\n      this.loggers.push(logger);\n    }\n  }\n  /**\n   * Send an event to the loggers\n   *\n   * @param event - the event to send to all the registered logger\n   */\n\n\n  send(event) {\n    const newEvent = this.prepareEvent(event);\n    this.loggers.forEach(logger => {\n      logger.send(newEvent);\n    });\n  }\n\n}\n/**\n * Helper class to log performance events\n */\n\nexport class PerformanceEvent {\n  constructor(logger, event, markers = {\n    end: true,\n    cancel: \"generic\"\n  }) {\n    this.logger = logger;\n    this.markers = markers;\n    this.startTime = performance.now();\n    this.event = Object.assign({}, event);\n\n    if (this.markers.start) {\n      this.reportEvent(\"start\");\n    }\n\n    if (typeof window === \"object\" && window != null && window.performance) {\n      this.startMark = `${event.eventName}-start`;\n      window.performance.mark(this.startMark);\n    }\n  }\n\n  static start(logger, event, markers) {\n    return new PerformanceEvent(logger, event, markers);\n  }\n\n  static timedExec(logger, event, callback, markers) {\n    const perfEvent = PerformanceEvent.start(logger, event, markers);\n\n    try {\n      const ret = callback(perfEvent);\n      perfEvent.autoEnd();\n      return ret;\n    } catch (error) {\n      perfEvent.cancel(undefined, error);\n      throw error;\n    }\n  }\n\n  static timedExecAsync(logger, event, callback, markers) {\n    return _asyncToGenerator(function* () {\n      const perfEvent = PerformanceEvent.start(logger, event, markers);\n\n      try {\n        const ret = yield callback(perfEvent);\n        perfEvent.autoEnd();\n        return ret;\n      } catch (error) {\n        perfEvent.cancel(undefined, error);\n        throw error;\n      }\n    })();\n  }\n\n  get duration() {\n    return performance.now() - this.startTime;\n  }\n\n  reportProgress(props, eventNameSuffix = \"update\") {\n    this.reportEvent(eventNameSuffix, props);\n  }\n\n  autoEnd() {\n    // Event might have been cancelled or ended in the callback\n    if (this.event && this.markers.end) {\n      this.reportEvent(\"end\");\n    }\n\n    this.performanceEndMark();\n    this.event = undefined;\n  }\n\n  end(props) {\n    this.reportEvent(\"end\", props);\n    this.performanceEndMark();\n    this.event = undefined;\n  }\n\n  performanceEndMark() {\n    if (this.startMark && this.event) {\n      const endMark = `${this.event.eventName}-end`;\n      window.performance.mark(endMark);\n      window.performance.measure(`${this.event.eventName}`, this.startMark, endMark);\n      this.startMark = undefined;\n    }\n  }\n\n  cancel(props, error) {\n    if (this.markers.cancel !== undefined) {\n      this.reportEvent(\"cancel\", Object.assign({\n        category: this.markers.cancel\n      }, props), error);\n    }\n\n    this.event = undefined;\n  }\n  /**\n   * Report the event, if it hasn't already been reported.\n   */\n\n\n  reportEvent(eventNameSuffix, props, error) {\n    // There are strange sequences involving multiple Promise chains\n    // where the event can be cancelled and then later a callback is invoked\n    // and the caller attempts to end directly, e.g. issue #3936. Just return.\n    if (!this.event) {\n      return;\n    }\n\n    const event = Object.assign(Object.assign({}, this.event), props);\n    event.eventName = `${event.eventName}_${eventNameSuffix}`;\n\n    if (eventNameSuffix !== \"start\") {\n      event.duration = this.duration;\n    }\n\n    this.logger.sendPerformanceEvent(event, error);\n  }\n\n}\n/**\n * Logger that is useful for UT\n * It can be used in places where logger instance is required, but events should be not send over.\n */\n\nexport class TelemetryUTLogger {\n  send(event) {}\n\n  sendTelemetryEvent(event, error) {}\n\n  sendErrorEvent(event, error) {\n    this.reportError(\"errorEvent in UT logger!\", event, error);\n  }\n\n  sendPerformanceEvent(event, error) {}\n\n  logGenericError(eventName, error) {\n    this.reportError(`genericError in UT logger!`, {\n      eventName\n    }, error);\n  }\n\n  logException(event, exception) {\n    this.reportError(\"exception in UT logger!\", event, exception);\n  }\n\n  debugAssert(condition, event) {\n    this.reportError(\"debugAssert in UT logger!\");\n  }\n\n  shipAssert(condition, event) {\n    this.reportError(\"shipAssert in UT logger!\");\n  }\n\n  reportError(message, event, err) {\n    const error = new Error(message);\n    error.error = error;\n    error.event = event; // report to console as exception can be eaten\n\n    console.error(message);\n    console.error(error);\n    throw error;\n  }\n\n} //# sourceMappingURL=logger.js.map","map":null,"metadata":{},"sourceType":"module"}