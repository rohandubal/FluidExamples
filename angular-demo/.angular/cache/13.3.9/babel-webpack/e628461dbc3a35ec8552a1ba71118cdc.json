{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { SummaryType } from \"@fluidframework/protocol-definitions\";\nimport { channelsTreeName } from \"@fluidframework/runtime-definitions\";\nimport { SummaryTreeBuilder } from \"../summaryUtils\";\nconst baseSummaryTreeKey = \"_baseSummary\";\nconst outstandingOpsBlobKey = \"_outstandingOps\";\nconst maxDecodeDepth = 100;\n/** Path for nodes in a tree with escaped special characters */\n\nexport class EscapedPath {\n  constructor(path) {\n    this.path = path;\n  }\n\n  static create(path) {\n    return new EscapedPath(encodeURIComponent(path));\n  }\n\n  static createAndConcat(pathParts) {\n    var _a;\n\n    let ret = EscapedPath.create((_a = pathParts[0]) !== null && _a !== void 0 ? _a : \"\");\n\n    for (let i = 1; i < pathParts.length; i++) {\n      ret = ret.concat(EscapedPath.create(pathParts[i]));\n    }\n\n    return ret;\n  }\n\n  toString() {\n    return this.path;\n  }\n\n  concat(path) {\n    return new EscapedPath(`${this.path}/${path.path}`);\n  }\n\n}\n/** Information about a summary relevant to a specific node in the tree */\n\nexport class SummaryNode {\n  constructor(summary) {\n    this.summary = summary;\n  }\n  /** Creates an instance that is valid for the root with specific basePath and localPath */\n\n\n  static createForRoot(referenceSequenceNumber) {\n    return new SummaryNode({\n      referenceSequenceNumber,\n      basePath: undefined,\n      localPath: EscapedPath.create(\"\") // root hard-coded to \"\"\n\n    });\n  }\n  /** Summary reference sequence number, i.e. last sequence number seen when it was created */\n\n\n  get referenceSequenceNumber() {\n    return this.summary.referenceSequenceNumber;\n  }\n  /** Full path to parent node, or undefined if this is the root */\n\n\n  get basePath() {\n    return this.summary.basePath;\n  }\n  /** Relative path to this node from its parent node */\n\n\n  get localPath() {\n    return this.summary.localPath;\n  }\n  /** Relative path from this node to its node innermost base summary */\n\n\n  get additionalPath() {\n    return this.summary.additionalPath;\n  }\n\n  set additionalPath(additionalPath) {\n    this.summary.additionalPath = additionalPath;\n  }\n  /** Gets the full path to this node, to be used when sending a handle */\n\n\n  get fullPath() {\n    var _a, _b;\n\n    return (_b = (_a = this.basePath) === null || _a === void 0 ? void 0 : _a.concat(this.localPath)) !== null && _b !== void 0 ? _b : this.localPath;\n  }\n  /**\n   * Gets the full path to this node's innermost base summary.\n   * The children nodes can use this as their basePath to determine their path.\n   */\n\n\n  get fullPathForChildren() {\n    return this.additionalPath !== undefined ? this.fullPath.concat(this.additionalPath) : this.fullPath;\n  }\n  /**\n   * Creates a new node within the same summary for a child of this node.\n   * @param id - id of the child node\n   */\n\n\n  createForChild(id) {\n    return new SummaryNode({\n      referenceSequenceNumber: this.referenceSequenceNumber,\n      basePath: this.fullPathForChildren,\n      localPath: EscapedPath.create(id)\n    });\n  }\n\n}\n/**\n * Checks if the snapshot is created by referencing a previous successful\n * summary plus outstanding ops. If so, it will recursively \"decode\" it until\n * it gets to the last successful summary (the base summary) and returns that\n * as well as a function for fetching the outstanding ops. Also returns the\n * full path to the previous base summary for child summarizer nodes to use as\n * their base path when necessary.\n * @param snapshot - snapshot tree to decode\n */\n\nexport function decodeSummary(snapshot, logger) {\n  let baseSummary = snapshot;\n  const pathParts = [];\n  const opsBlobs = [];\n\n  for (let i = 0;; i++) {\n    if (i > maxDecodeDepth) {\n      logger.sendTelemetryEvent({\n        eventName: \"DecodeSummaryMaxDepth\",\n        maxDecodeDepth\n      });\n    }\n\n    const outstandingOpsBlob = baseSummary.blobs[outstandingOpsBlobKey];\n    const newBaseSummary = baseSummary.trees[baseSummaryTreeKey];\n\n    if (outstandingOpsBlob === undefined && newBaseSummary === undefined) {\n      return {\n        baseSummary,\n        pathParts,\n\n        getOutstandingOps(readAndParseBlob) {\n          return _asyncToGenerator(function* () {\n            let outstandingOps = [];\n\n            for (const opsBlob of opsBlobs) {\n              const newOutstandingOps = yield readAndParseBlob(opsBlob);\n\n              if (outstandingOps.length > 0 && newOutstandingOps.length > 0) {\n                const latestSeq = outstandingOps[outstandingOps.length - 1].sequenceNumber;\n                const newEarliestSeq = newOutstandingOps[0].sequenceNumber;\n\n                if (newEarliestSeq <= latestSeq) {\n                  logger.sendTelemetryEvent({\n                    eventName: \"DuplicateOutstandingOps\",\n                    // eslint-disable-next-line max-len\n                    message: `newEarliestSeq <= latestSeq in decodeSummary: ${newEarliestSeq} <= ${latestSeq}`\n                  });\n\n                  while (newOutstandingOps.length > 0 && newOutstandingOps[0].sequenceNumber <= latestSeq) {\n                    newOutstandingOps.shift();\n                  }\n                }\n              }\n\n              outstandingOps = outstandingOps.concat(newOutstandingOps);\n            }\n\n            return outstandingOps;\n          })();\n        }\n\n      };\n    }\n\n    assert(!!outstandingOpsBlob, 0x1af\n    /* \"Outstanding ops blob missing, but base summary tree exists\" */\n    );\n    assert(newBaseSummary !== undefined, 0x1b0\n    /* \"Base summary tree missing, but outstanding ops blob exists\" */\n    );\n    baseSummary = newBaseSummary;\n    pathParts.push(baseSummaryTreeKey);\n    opsBlobs.unshift(outstandingOpsBlob);\n  }\n}\n/**\n * Creates a summary tree which is a handle of the previous successfully acked summary\n * and a blob of the outstanding ops since that summary. If there is no acked summary yet,\n * it will create with the tree found in the initial attach op and the blob of outstanding ops.\n * @param summaryParam - information about last acked summary and paths to encode if from summary,\n * otherwise the initial summary from the attach op.\n * @param outstandingOps - outstanding ops since last acked summary\n */\n\nexport function encodeSummary(summaryParam, outstandingOps) {\n  let additionalPath = EscapedPath.create(baseSummaryTreeKey);\n  const builder = new SummaryTreeBuilder();\n  builder.addBlob(outstandingOpsBlobKey, JSON.stringify(outstandingOps));\n\n  if (summaryParam.fromSummary) {\n    // Create using handle of latest acked summary\n    const summaryNode = summaryParam.summaryNode;\n\n    if (summaryNode.additionalPath !== undefined) {\n      additionalPath = additionalPath.concat(summaryNode.additionalPath);\n    }\n\n    builder.addHandle(baseSummaryTreeKey, SummaryType.Tree, summaryNode.fullPath.path);\n  } else {\n    // Create using initial summary from attach op\n    builder.addWithStats(baseSummaryTreeKey, summaryParam.initialSummary);\n  }\n\n  const summary = builder.getSummaryTree();\n  return Object.assign(Object.assign({}, summary), {\n    additionalPath\n  });\n}\n/**\n * Checks if the summary contains .channels subtree where the children subtrees\n * would be located if exists.\n * @param baseSummary - summary to check\n */\n\nexport function parseSummaryForSubtrees(baseSummary) {\n  // New versions of snapshots have child nodes isolated in .channels subtree\n  const channelsSubtree = baseSummary.trees[channelsTreeName];\n\n  if (channelsSubtree !== undefined) {\n    return {\n      childrenTree: channelsSubtree,\n      childrenPathPart: channelsTreeName\n    };\n  }\n\n  return {\n    childrenTree: baseSummary,\n    childrenPathPart: undefined\n  };\n}\n/**\n * Checks if the summary contains .channels subtree where the children subtrees\n * would be located if exists.\n * @param baseSummary - summary to check\n */\n\nexport function parseSummaryTreeForSubtrees(summary) {\n  // New versions of snapshots have child nodes isolated in .channels subtree\n  const channelsSubtree = summary.tree[channelsTreeName];\n\n  if (channelsSubtree !== undefined) {\n    return {\n      childrenTree: channelsSubtree,\n      childrenPathPart: channelsTreeName\n    };\n  }\n\n  return {\n    childrenTree: summary,\n    childrenPathPart: undefined\n  };\n} //# sourceMappingURL=summarizerNodeUtils.js.map","map":null,"metadata":{},"sourceType":"module"}