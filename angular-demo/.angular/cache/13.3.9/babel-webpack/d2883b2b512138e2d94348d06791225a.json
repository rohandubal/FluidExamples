{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, Deferred } from \"@fluidframework/common-utils\";\n/**\n * Can be useful in testing as well as in places where caller does not use cancellation.\n * This object implements ISummaryCancellationToken interface but cancellation is never leveraged.\n */\n\nexport const neverCancelledSummaryToken = {\n  cancelled: false,\n  waitCancelled: new Promise(() => {})\n};\n/**\n * Helper class to coordinate something that needs to run only while connected.\n * This provides promises that resolve as it starts or stops.  Stopping happens\n * when disconnected or if stop() is called.\n */\n\nexport class RunWhileConnectedCoordinator {\n  constructor(runtime) {\n    this.runtime = runtime;\n    this._cancelled = false;\n    this.stopDeferred = new Deferred();\n  }\n\n  get cancelled() {\n    if (!this._cancelled) {\n      assert(this.runtime.deltaManager.active, 0x25d\n      /* \"We should never connect as 'read'\" */\n      ); // This check can't be enabled in current design due to lastSummary flow, where\n      // summarizer for closed container stays around and can produce one more summary.\n      // Currently we solve the problem of overlapping summarizer by doing wait in\n      // SummaryManager.createSummarizer()\n      // Better solution would involve these steps:\n      // 1. Summarizer selection logic should chose summarizing client (with clientType === \"summarizer\")\n      // if such client exists.\n      // 2. Summarizer should be updated about such changes (to update onBehalfOfClientId)\n      //\n      // assert(this.runtime.summarizerClientId === this.onBehalfOfClientId ||\n      //    this.runtime.summarizerClientId === this.runtime.clientId, \"onBehalfOfClientId\");\n    }\n\n    return this._cancelled;\n  }\n  /**\n   * Returns a promise that resolves once stopped either externally or by disconnect.\n   */\n\n\n  get waitCancelled() {\n    return this.stopDeferred.promise;\n  }\n\n  static create(runtime) {\n    return _asyncToGenerator(function* () {\n      const obj = new RunWhileConnectedCoordinator(runtime);\n      yield obj.waitStart();\n      return obj;\n    })();\n  }\n  /**\n   * Starts and waits for a promise which resolves when connected.\n   * The promise will also resolve if stopped either externally or by disconnect.\n   *\n   * We only listen on disconnected event for clientType === \"summarizer\" container!\n   * And only do it here - no other place should check it! That way we have only one place\n   * that controls policy and it's easy to change policy in the future if we want to!\n   * We do not listen for \"main\" (aka interactive) container disconnect here, as it's\n   * responsibility of SummaryManager to decide if that's material or not. There are cases\n   * like \"lastSummary\", or main client experiencing nacks / disconnects due to hitting limit\n   * of non-summarized ops, where can make determination to continue with summary even if main\n   * client is disconnected.\n   */\n\n\n  waitStart() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.runtime.disposed) {\n        _this.stop(\"summarizerClientDisconnected\");\n\n        return;\n      }\n\n      _this.runtime.once(\"dispose\", () => _this.stop(\"summarizerClientDisconnected\"));\n\n      if (!_this.runtime.connected) {\n        const waitConnected = new Promise(resolve => _this.runtime.once(\"connected\", resolve));\n        yield Promise.race([waitConnected, _this.waitCancelled]);\n      }\n\n      _this.runtime.once(\"disconnected\", () => _this.stop(\"summarizerClientDisconnected\"));\n    })();\n  }\n  /**\n   * Stops running.\n   */\n\n\n  stop(reason) {\n    if (!this._cancelled) {\n      this._cancelled = true;\n      this.stopDeferred.resolve(reason);\n    }\n  }\n\n} //# sourceMappingURL=runWhileConnectedCoordinator.js.map","map":null,"metadata":{},"sourceType":"module"}