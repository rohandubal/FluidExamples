{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, extractLogSafeErrorProperties } from \"@fluidframework/common-utils\";\nimport { createGenericNetworkError } from \"@fluidframework/driver-utils\";\nimport { ScopeType } from \"@fluidframework/protocol-definitions\";\nimport { ChildLogger, getCircularReplacer, loggerToMonitoringContext, EventEmitterWithErrorHandling } from \"@fluidframework/telemetry-utils\"; // For now, this package is versioned and released in unison with the specific drivers\n\nimport { pkgVersion as driverVersion } from \"./packageVersion\";\n/**\n * Represents a connection to a stream of delta updates\n */\n\nexport let DocumentDeltaConnection = /*#__PURE__*/(() => {\n  class DocumentDeltaConnection extends EventEmitterWithErrorHandling {\n    /**\n     * @param socket - websocket to be used\n     * @param documentId - ID of the document\n     * @param logger - for reporting telemetry events\n     * @param enableLongPollingDowngrades - allow connection to be downgraded to long-polling on websocket failure\n     */\n    constructor(socket, documentId, logger, enableLongPollingDowngrades = false) {\n      super((name, error) => {\n        logger.sendErrorEvent({\n          eventName: \"DeltaConnection:EventException\",\n          name\n        }, error);\n      });\n      this.socket = socket;\n      this.documentId = documentId;\n      this.enableLongPollingDowngrades = enableLongPollingDowngrades; // Listen for ops sent before we receive a response to connect_document\n\n      this.queuedMessages = [];\n      this.queuedSignals = [];\n      /**\n       * A flag to indicate whether we have our handler attached.  If it's attached, we're queueing incoming ops\n       * to later be retrieved via initialMessages.\n       */\n\n      this.earlyOpHandlerAttached = false; // Listeners only needed while the connection is in progress\n\n      this.connectionListeners = new Map(); // Listeners used throughout the lifetime of the DocumentDeltaConnection\n\n      this.trackedListeners = new Map();\n      /**\n       * Flag to indicate whether the DocumentDeltaConnection is expected to still be capable of sending messages.\n       * After disconnection, we flip this to prevent any stale messages from being emitted.\n       */\n\n      this._disposed = false;\n\n      this.earlyOpHandler = (documentId, msgs) => {\n        this.queuedMessages.push(...msgs);\n      };\n\n      this.earlySignalHandler = msg => {\n        this.queuedSignals.push(msg);\n      };\n\n      this.mc = loggerToMonitoringContext(ChildLogger.create(logger, \"DeltaConnection\"));\n      this.on(\"newListener\", (event, listener) => {\n        assert(!this.disposed, 0x20a\n        /* \"register for event on disposed object\" */\n        ); // Some events are already forwarded - see this.addTrackedListener() calls in initialize().\n\n        if (DocumentDeltaConnection.eventsAlwaysForwarded.includes(event)) {\n          assert(this.trackedListeners.has(event), 0x245\n          /* \"tracked listener\" */\n          );\n          return;\n        }\n\n        if (!DocumentDeltaConnection.eventsToForward.includes(event)) {\n          throw new Error(`DocumentDeltaConnection: Registering for unknown event: ${event}`);\n        } // Whenever listener is added, we should subscribe on same event on socket, so these two things\n        // should be in sync. This currently assumes that nobody unregisters and registers back listeners,\n        // and that there are no \"internal\" listeners installed (like \"error\" case we skip above)\n        // Better flow might be to always unconditionally register all handlers on successful connection,\n        // though some logic (naming assert in initialMessages getter) might need to be adjusted (it becomes noop)\n\n\n        assert(this.listeners(event).length !== 0 === this.trackedListeners.has(event), 0x20b\n        /* \"mismatch\" */\n        );\n\n        if (!this.trackedListeners.has(event)) {\n          this.addTrackedListener(event, (...args) => {\n            this.emit(event, ...args);\n          });\n        }\n      });\n    }\n\n    get hasDetails() {\n      return !!this._details;\n    }\n\n    get disposed() {\n      assert(this._disposed || this.socket.connected, 0x244\n      /* \"Socket is closed, but connection is not!\" */\n      );\n      return this._disposed;\n    }\n    /**\n     * @deprecated - Implementors should manage their own logger or monitoring context\n     */\n\n\n    get logger() {\n      return this.mc.logger;\n    }\n\n    get details() {\n      if (!this._details) {\n        throw new Error(\"Internal error: calling method before _details is initialized!\");\n      }\n\n      return this._details;\n    }\n    /**\n     * Get the ID of the client who is sending the message\n     *\n     * @returns the client ID\n     */\n\n\n    get clientId() {\n      return this.details.clientId;\n    }\n    /**\n     * Get the mode of the client\n     *\n     * @returns the client mode\n     */\n\n\n    get mode() {\n      return this.details.mode;\n    }\n    /**\n     * Get the claims of the client who is sending the message\n     *\n     * @returns client claims\n     */\n\n\n    get claims() {\n      return this.details.claims;\n    }\n    /**\n     * Get whether or not this is an existing document\n     *\n     * @returns true if the document exists\n     */\n\n\n    get existing() {\n      return this.details.existing;\n    }\n    /**\n     * Get the maximum size of a message before chunking is required\n     *\n     * @returns the maximum size of a message before chunking is required\n     */\n\n\n    get maxMessageSize() {\n      return this.details.serviceConfiguration.maxMessageSize;\n    }\n    /**\n     * Semver of protocol being used with the service\n     */\n\n\n    get version() {\n      return this.details.version;\n    }\n    /**\n     * Configuration details provided by the service\n     */\n\n\n    get serviceConfiguration() {\n      return this.details.serviceConfiguration;\n    }\n\n    checkNotClosed() {\n      assert(!this.disposed, 0x20c\n      /* \"connection disposed\" */\n      );\n    }\n    /**\n     * Get messages sent during the connection\n     *\n     * @returns messages sent during the connection\n     */\n\n\n    get initialMessages() {\n      this.checkNotClosed(); // If we call this when the earlyOpHandler is not attached, then the queuedMessages may not include the\n      // latest ops.  This could possibly indicate that initialMessages was called twice.\n\n      assert(this.earlyOpHandlerAttached, 0x08e\n      /* \"Potentially missed initial messages\" */\n      ); // We will lose ops and perf will tank as we need to go to storage to become current!\n\n      assert(this.listeners(\"op\").length !== 0, 0x08f\n      /* \"No op handler is setup!\" */\n      );\n      this.removeEarlyOpHandler();\n\n      if (this.queuedMessages.length > 0) {\n        // Some messages were queued.\n        // add them to the list of initialMessages to be processed\n        this.details.initialMessages.push(...this.queuedMessages);\n        this.details.initialMessages.sort((a, b) => a.sequenceNumber - b.sequenceNumber);\n        this.queuedMessages.length = 0;\n      }\n\n      return this.details.initialMessages;\n    }\n    /**\n     * Get signals sent during the connection\n     *\n     * @returns signals sent during the connection\n     */\n\n\n    get initialSignals() {\n      this.checkNotClosed();\n      assert(this.listeners(\"signal\").length !== 0, 0x090\n      /* \"No signal handler is setup!\" */\n      );\n      this.removeEarlySignalHandler();\n\n      if (this.queuedSignals.length > 0) {\n        // Some signals were queued.\n        // add them to the list of initialSignals to be processed\n        this.details.initialSignals.push(...this.queuedSignals);\n        this.queuedSignals.length = 0;\n      }\n\n      return this.details.initialSignals;\n    }\n    /**\n     * Get initial client list\n     *\n     * @returns initial client list sent during the connection\n     */\n\n\n    get initialClients() {\n      this.checkNotClosed();\n      return this.details.initialClients;\n    }\n\n    emitMessages(type, messages) {\n      // Although the implementation here disconnects the socket and does not reuse it, other subclasses\n      // (e.g. OdspDocumentDeltaConnection) may reuse the socket.  In these cases, we need to avoid emitting\n      // on the still-live socket.\n      if (!this.disposed) {\n        this.socket.emit(type, this.clientId, messages);\n      }\n    }\n\n    submitCore(type, messages) {\n      this.emitMessages(type, [messages]);\n    }\n    /**\n     * Submits a new delta operation to the server\n     *\n     * @param message - delta operation to submit\n     */\n\n\n    submit(messages) {\n      this.checkNotClosed();\n      this.submitCore(\"submitOp\", messages);\n    }\n    /**\n     * Submits a new signal to the server\n     *\n     * @param message - signal to submit\n     */\n\n\n    submitSignal(message) {\n      this.checkNotClosed();\n      this.submitCore(\"submitSignal\", [message]);\n    }\n    /**\n     * Disconnect from the websocket, and permanently disable this DocumentDeltaConnection.\n     */\n\n\n    dispose() {\n      this.disposeCore(false, // socketProtocolError\n      createGenericNetworkError( // pre-0.58 error message: clientClosingConnection\n      \"Client closing delta connection\", {\n        canRetry: true\n      }, {\n        driverVersion\n      }));\n    }\n\n    disposeCore(socketProtocolError, err) {\n      // Can't check this.disposed here, as we get here on socket closure,\n      // so _disposed & socket.connected might be not in sync while processing\n      // \"dispose\" event.\n      if (this._disposed) {\n        return;\n      } // We set the disposed flag as a part of the contract for overriding the disconnect method. This is used by\n      // DocumentDeltaConnection to determine if emitting messages (ops) on the socket is allowed, which is\n      // important since OdspDocumentDeltaConnection reuses the socket rather than truly disconnecting it. Note that\n      // OdspDocumentDeltaConnection may still send disconnect_document which is allowed; this is only intended\n      // to prevent normal messages from being emitted.\n\n\n      this._disposed = true;\n      this.removeTrackedListeners();\n      this.disconnect(socketProtocolError, err);\n    }\n    /**\n     * Disconnect from the websocket.\n     * @param socketProtocolError - true if error happened on socket / socket.io protocol level\n     *  (not on Fluid protocol level)\n     * @param reason - reason for disconnect\n     */\n\n\n    disconnect(socketProtocolError, reason) {\n      this.socket.disconnect();\n    }\n\n    initialize(connectMessage, timeout) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        _this.socket.on(\"op\", _this.earlyOpHandler);\n\n        _this.socket.on(\"signal\", _this.earlySignalHandler);\n\n        _this.earlyOpHandlerAttached = true; // Socket.io's reconnect_attempt event is unreliable, so we track connect_error count instead.\n\n        let internalSocketConnectionFailureCount = 0;\n\n        const isInternalSocketReconnectionEnabled = () => _this.socket.io.reconnection();\n\n        const getMaxInternalSocketReconnectionAttempts = () => isInternalSocketReconnectionEnabled() ? _this.socket.io.reconnectionAttempts() : 0;\n\n        const getMaxAllowedInternalSocketConnectionFailures = () => getMaxInternalSocketReconnectionAttempts() + 1;\n\n        _this._details = yield new Promise((resolve, reject) => {\n          const fail = (socketProtocolError, err) => {\n            _this.disposeCore(socketProtocolError, err);\n\n            reject(err);\n          }; // Listen for connection issues\n\n\n          _this.addConnectionListener(\"connect_error\", error => {\n            var _a;\n\n            internalSocketConnectionFailureCount++;\n            let isWebSocketTransportError = false;\n\n            try {\n              const description = error === null || error === void 0 ? void 0 : error.description;\n\n              if (description && typeof description === \"object\") {\n                if (error.type === \"TransportError\") {\n                  isWebSocketTransportError = true;\n                } // That's a WebSocket. Clear it as we can't log it.\n\n\n                description.target = undefined;\n              }\n            } catch (_e) {} // Handle socket transport downgrading when not offline.\n\n\n            if (isWebSocketTransportError && _this.enableLongPollingDowngrades && ((_a = _this.socket.io.opts.transports) === null || _a === void 0 ? void 0 : _a[0]) !== \"polling\") {\n              // Downgrade transports to polling upgrade mechanism.\n              _this.socket.io.opts.transports = [\"polling\", \"websocket\"]; // Don't alter reconnection behavior if already enabled.\n\n              if (!isInternalSocketReconnectionEnabled()) {\n                // Allow single reconnection attempt using polling upgrade mechanism.\n                _this.socket.io.reconnection(true);\n\n                _this.socket.io.reconnectionAttempts(1);\n              }\n            } // Allow built-in socket.io reconnection handling.\n\n\n            if (isInternalSocketReconnectionEnabled() && internalSocketConnectionFailureCount < getMaxAllowedInternalSocketConnectionFailures()) {\n              // Reconnection is enabled and maximum reconnect attempts have not been reached.\n              return;\n            }\n\n            fail(true, _this.createErrorObject(\"connect_error\", error));\n          }); // Listen for timeouts\n\n\n          _this.addConnectionListener(\"connect_timeout\", () => {\n            fail(true, _this.createErrorObject(\"connect_timeout\"));\n          });\n\n          _this.addConnectionListener(\"connect_document_success\", response => {\n            // If we sent a nonce and the server supports nonces, check that the nonces match\n            if (connectMessage.nonce !== undefined && response.nonce !== undefined && response.nonce !== connectMessage.nonce) {\n              return;\n            }\n\n            const requestedMode = connectMessage.mode;\n            const actualMode = response.mode;\n            const writingPermitted = response.claims.scopes.includes(ScopeType.DocWrite);\n\n            if (writingPermitted) {\n              // The only time we expect a mismatch in requested/actual is if we lack write permissions\n              // In this case we will get \"read\", even if we requested \"write\"\n              if (actualMode !== requestedMode) {\n                fail(false, _this.createErrorObject(\"connect_document_success\", \"Connected in a different mode than was requested\", false));\n                return;\n              }\n            } else {\n              if (actualMode === \"write\") {\n                fail(false, _this.createErrorObject(\"connect_document_success\", \"Connected in write mode without write permissions\", false));\n                return;\n              }\n            }\n\n            _this.checkpointSequenceNumber = response.checkpointSequenceNumber;\n\n            _this.removeConnectionListeners();\n\n            resolve(response);\n          }); // Socket can be disconnected while waiting for Fluid protocol messages\n          // (connect_document_error / connect_document_success), as well as before DeltaManager\n          // had a chance to register its handlers.\n\n\n          _this.addTrackedListener(\"disconnect\", reason => {\n            const err = _this.createErrorObject(\"disconnect\", reason);\n\n            _this.emit(\"disconnect\", err);\n\n            fail(true, err);\n          });\n\n          _this.addTrackedListener(\"error\", error => {\n            // First, raise an error event, to give clients a chance to observe error contents\n            // This includes \"Invalid namespace\" error, which we consider critical (reconnecting will not help)\n            const err = _this.createErrorObject(\"error\", error, error !== \"Invalid namespace\");\n\n            _this.emit(\"error\", err); // Disconnect socket - required if happened before initial handshake\n\n\n            fail(true, err);\n          });\n\n          _this.addConnectionListener(\"connect_document_error\", error => {\n            // If we sent a nonce and the server supports nonces, check that the nonces match\n            if (connectMessage.nonce !== undefined && error.nonce !== undefined && error.nonce !== connectMessage.nonce) {\n              return;\n            } // This is not an socket.io error - it's Fluid protocol error.\n            // In this case fail connection and indicate that we were unable to create connection\n\n\n            fail(false, _this.createErrorObject(\"connect_document_error\", error));\n          });\n\n          _this.socket.emit(\"connect_document\", connectMessage); // Give extra 2 seconds for handshake on top of socket connection timeout\n\n\n          _this.socketConnectionTimeout = setTimeout(() => {\n            fail(false, _this.createErrorObject(\"orderingServiceHandshakeTimeout\"));\n          }, timeout + 2000);\n        });\n        assert(!_this.disposed, 0x246\n        /* \"checking consistency of socket & _disposed flags\" */\n        );\n      })();\n    }\n\n    removeEarlyOpHandler() {\n      this.socket.removeListener(\"op\", this.earlyOpHandler);\n      this.earlyOpHandlerAttached = false;\n    }\n\n    removeEarlySignalHandler() {\n      this.socket.removeListener(\"signal\", this.earlySignalHandler);\n    }\n\n    addConnectionListener(event, listener) {\n      assert(!DocumentDeltaConnection.eventsAlwaysForwarded.includes(event), 0x247\n      /* \"Use addTrackedListener instead\" */\n      );\n      assert(!DocumentDeltaConnection.eventsToForward.includes(event), 0x248\n      /* \"should not subscribe to forwarded events\" */\n      );\n      this.socket.on(event, listener);\n      assert(!this.connectionListeners.has(event), 0x20d\n      /* \"double connection listener\" */\n      );\n      this.connectionListeners.set(event, listener);\n    }\n\n    addTrackedListener(event, listener) {\n      this.socket.on(event, listener);\n      assert(!this.trackedListeners.has(event), 0x20e\n      /* \"double tracked listener\" */\n      );\n      this.trackedListeners.set(event, listener);\n    }\n\n    removeTrackedListeners() {\n      for (const [event, listener] of this.trackedListeners.entries()) {\n        this.socket.off(event, listener);\n      } // removeTrackedListeners removes all listeners, including connection listeners\n\n\n      this.removeConnectionListeners();\n      this.removeEarlyOpHandler();\n      this.removeEarlySignalHandler();\n      this.trackedListeners.clear();\n    }\n\n    removeConnectionListeners() {\n      if (this.socketConnectionTimeout !== undefined) {\n        clearTimeout(this.socketConnectionTimeout);\n      }\n\n      for (const [event, listener] of this.connectionListeners.entries()) {\n        this.socket.off(event, listener);\n      }\n\n      this.connectionListeners.clear();\n    }\n    /**\n     * Error raising for socket.io issues\n     */\n\n\n    createErrorObject(handler, error, canRetry = true) {\n      // Note: we suspect the incoming error object is either:\n      // - a string: log it in the message (if not a string, it may contain PII but will print as [object Object])\n      // - an Error object thrown by socket.io engine. Be careful with not recording PII!\n      let message;\n\n      if ((error === null || error === void 0 ? void 0 : error.type) === \"TransportError\") {\n        // JSON.stringify drops Error.message\n        const messagePrefix = (error === null || error === void 0 ? void 0 : error.message) !== undefined ? `${error.message}: ` : \"\"; // Websocket errors reported by engine.io-client.\n        // They are Error objects with description containing WS error and description = \"TransportError\"\n        // Please see https://github.com/socketio/engine.io-client/blob/7245b80/lib/transport.ts#L44,\n\n        message = `${messagePrefix}${JSON.stringify(error, getCircularReplacer())}`;\n      } else {\n        message = extractLogSafeErrorProperties(error).message;\n      }\n\n      const errorObj = createGenericNetworkError(`socket.io (${handler}): ${message}`, {\n        canRetry\n      }, {\n        driverVersion\n      });\n      return errorObj;\n    }\n\n  }\n\n  DocumentDeltaConnection.eventsToForward = [\"nack\", \"op\", \"signal\", \"pong\"]; // WARNING: These are critical events that we can't miss, so registration for them has to be in place at all times!\n  // Including before handshake is over, and after that (but before DeltaManager had a chance to put its own handlers)\n\n  DocumentDeltaConnection.eventsAlwaysForwarded = [\"disconnect\", \"error\"]; //# sourceMappingURL=documentDeltaConnection.js.map\n\n  return DocumentDeltaConnection;\n})();","map":null,"metadata":{},"sourceType":"module"}