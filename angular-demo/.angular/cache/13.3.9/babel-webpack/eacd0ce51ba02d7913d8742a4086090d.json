{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar _a;\n\nimport { DriverErrorType } from \"@fluidframework/driver-definitions\";\nimport { LoggingError } from \"@fluidframework/telemetry-utils\";\nexport var OnlineStatus = /*#__PURE__*/(() => {\n  (function (OnlineStatus) {\n    OnlineStatus[OnlineStatus[\"Offline\"] = 0] = \"Offline\";\n    OnlineStatus[OnlineStatus[\"Online\"] = 1] = \"Online\";\n    OnlineStatus[OnlineStatus[\"Unknown\"] = 2] = \"Unknown\";\n  })(OnlineStatus || (OnlineStatus = {}));\n\n  return OnlineStatus;\n})();\n// It tells if we have local connection only - we might not have connection to web.\n// No solution for node.js (other than resolve dns names / ping specific sites)\n// Can also use window.addEventListener(\"online\" / \"offline\")\nexport function isOnline() {\n  if (typeof navigator === \"object\" && navigator !== null && typeof navigator.onLine === \"boolean\") {\n    return navigator.onLine ? OnlineStatus.Online : OnlineStatus.Offline;\n  }\n\n  return OnlineStatus.Unknown;\n}\n/**\n * Generic network error class.\n */\n\nexport class GenericNetworkError extends LoggingError {\n  constructor(message, canRetry, props) {\n    super(message, props);\n    this.canRetry = canRetry;\n    this.errorType = DriverErrorType.genericNetworkError;\n  }\n\n} // Todo GH #6214: Remove after next drive def bump. This is necessary as there is no\n// compatible way to augment an enum, as it can't be optional. So for now\n// we need to duplicate the value here. We likely need to rethink our\n// DriverErrorType strategy so that it supports extension with optional\n// value.\n\nconst deltaStreamConnectionForbiddenStr = \"deltaStreamConnectionForbidden\";\nexport class DeltaStreamConnectionForbiddenError extends LoggingError {\n  constructor(message, props) {\n    super(message, Object.assign(Object.assign({}, props), {\n      statusCode: 400\n    }));\n    this.errorType = DeltaStreamConnectionForbiddenError.errorType;\n    this.canRetry = false;\n  }\n\n}\nDeltaStreamConnectionForbiddenError.errorType = (_a = DriverErrorType[deltaStreamConnectionForbiddenStr]) !== null && _a !== void 0 ? _a : deltaStreamConnectionForbiddenStr;\nexport class AuthorizationError extends LoggingError {\n  constructor(message, claims, tenantId, props) {\n    // don't log claims or tenantId\n    super(message, props, new Set([\"claims\", \"tenantId\"]));\n    this.claims = claims;\n    this.tenantId = tenantId;\n    this.errorType = DriverErrorType.authorizationError;\n    this.canRetry = false;\n  }\n\n}\nexport class NetworkErrorBasic extends LoggingError {\n  constructor(message, errorType, canRetry, props) {\n    super(message, props);\n    this.errorType = errorType;\n    this.canRetry = canRetry;\n  }\n\n}\nexport class NonRetryableError extends NetworkErrorBasic {\n  constructor(message, errorType, props) {\n    super(message, errorType, false, props);\n    this.errorType = errorType;\n  }\n\n}\nexport class RetryableError extends NetworkErrorBasic {\n  constructor(message, errorType, props) {\n    super(message, errorType, true, props);\n    this.errorType = errorType;\n  }\n\n}\n/**\n * Throttling error class - used to communicate all throttling errors\n */\n\nexport class ThrottlingError extends LoggingError {\n  constructor(message, retryAfterSeconds, props) {\n    super(message, props);\n    this.retryAfterSeconds = retryAfterSeconds;\n    this.errorType = DriverErrorType.throttlingError;\n    this.canRetry = true;\n  }\n\n}\nexport const createWriteError = (message, props) => new NonRetryableError(message, DriverErrorType.writeError, props);\nexport function createGenericNetworkError(message, retryInfo, props) {\n  if (retryInfo.retryAfterMs !== undefined && retryInfo.canRetry) {\n    return new ThrottlingError(message, retryInfo.retryAfterMs / 1000, props);\n  }\n\n  return new GenericNetworkError(message, retryInfo.canRetry, props);\n}\n/**\n * Check if a connection error can be retried.  Unless explicitly allowed, retry is disallowed.\n * I.e. asserts or unexpected exceptions in our code result in container failure.\n * @param error - The error to inspect for ability to retry\n */\n\nexport const canRetryOnError = error => (error === null || error === void 0 ? void 0 : error.canRetry) === true;\n/** Check retryAfterSeconds property on error */\n\nexport const getRetryDelaySecondsFromError = error => error === null || error === void 0 ? void 0 : error.retryAfterSeconds;\n/** Check retryAfterSeconds property on error and convert to ms */\n\nexport const getRetryDelayFromError = error => (error === null || error === void 0 ? void 0 : error.retryAfterSeconds) !== undefined ? error.retryAfterSeconds * 1000 : undefined; //# sourceMappingURL=network.js.map","map":null,"metadata":{},"sourceType":"module"}