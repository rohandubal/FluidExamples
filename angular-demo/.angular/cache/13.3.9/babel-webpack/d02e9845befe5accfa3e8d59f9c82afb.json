{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { Deferred, bufferToString, assert } from \"@fluidframework/common-utils\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { Client, createAnnotateRangeOp, createGroupOp, createInsertOp, createRemoveRangeOp, LocalReference, matchProperties, MergeTreeDeltaType, ReferenceType } from \"@fluidframework/merge-tree\";\nimport { ObjectStoragePartition, SummaryTreeBuilder } from \"@fluidframework/runtime-utils\";\nimport { makeHandlesSerializable, parseHandles, SharedObject } from \"@fluidframework/shared-object-base\";\nimport { SequenceIntervalCollectionValueType } from \"./intervalCollection\";\nimport { DefaultMap } from \"./defaultMap\";\nimport { SequenceDeltaEvent, SequenceMaintenanceEvent } from \"./sequenceDeltaEvent\";\nconst snapshotFileName = \"header\";\nconst contentPath = \"content\";\nexport class SharedSegmentSequence extends SharedObject {\n  constructor(dataStoreRuntime, id, attributes, segmentFromSpec) {\n    super(id, dataStoreRuntime, attributes, \"fluid_sequence_\");\n    this.dataStoreRuntime = dataStoreRuntime;\n    this.id = id;\n    this.segmentFromSpec = segmentFromSpec; // Deferred that triggers once the object is loaded\n\n    this.loadedDeferred = new Deferred(); // cache out going ops created when partial loading\n\n    this.loadedDeferredOutgoingOps = []; // cache incoming ops that arrive when partial loading\n\n    this.deferIncomingOps = true;\n    this.loadedDeferredIncomingOps = [];\n    this.messagesSinceMSNChange = [];\n    this.loadedDeferred.promise.catch(error => {\n      this.logger.sendErrorEvent({\n        eventName: \"SequenceLoadFailed\"\n      }, error);\n    });\n    this.client = new Client(segmentFromSpec, ChildLogger.create(this.logger, \"SharedSegmentSequence.MergeTreeClient\"), dataStoreRuntime.options);\n    super.on(\"newListener\", event => {\n      switch (event) {\n        case \"sequenceDelta\":\n          if (!this.client.mergeTreeDeltaCallback) {\n            this.client.mergeTreeDeltaCallback = (opArgs, deltaArgs) => {\n              this.emit(\"sequenceDelta\", new SequenceDeltaEvent(opArgs, deltaArgs, this.client), this);\n            };\n          }\n\n          break;\n\n        case \"maintenance\":\n          if (!this.client.mergeTreeMaintenanceCallback) {\n            this.client.mergeTreeMaintenanceCallback = (args, opArgs) => {\n              this.emit(\"maintenance\", new SequenceMaintenanceEvent(opArgs, args, this.client), this);\n            };\n          }\n\n          break;\n\n        default:\n      }\n    });\n    super.on(\"removeListener\", event => {\n      switch (event) {\n        case \"sequenceDelta\":\n          if (super.listenerCount(event) === 0) {\n            this.client.mergeTreeDeltaCallback = undefined;\n          }\n\n          break;\n\n        case \"maintenance\":\n          if (super.listenerCount(event) === 0) {\n            this.client.mergeTreeMaintenanceCallback = undefined;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    });\n    this.intervalCollections = new DefaultMap(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), new SequenceIntervalCollectionValueType());\n  }\n\n  get loaded() {\n    return this.loadedDeferred.promise;\n  }\n\n  static createOpsFromDelta(event) {\n    var _a, _b;\n\n    const ops = [];\n\n    for (const r of event.ranges) {\n      switch (event.deltaOperation) {\n        case MergeTreeDeltaType.ANNOTATE:\n          {\n            const lastAnnotate = ops[ops.length - 1];\n            const props = {};\n\n            for (const key of Object.keys(r.propertyDeltas)) {\n              props[key] = (_b = (_a = r.segment.properties) === null || _a === void 0 ? void 0 : _a[key]) !== null && _b !== void 0 ? _b : null;\n            }\n\n            if (lastAnnotate && lastAnnotate.pos2 === r.position && matchProperties(lastAnnotate.props, props)) {\n              lastAnnotate.pos2 += r.segment.cachedLength;\n            } else {\n              ops.push(createAnnotateRangeOp(r.position, r.position + r.segment.cachedLength, props, undefined));\n            }\n\n            break;\n          }\n\n        case MergeTreeDeltaType.INSERT:\n          ops.push(createInsertOp(r.position, r.segment.clone().toJSONObject()));\n          break;\n\n        case MergeTreeDeltaType.REMOVE:\n          {\n            const lastRem = ops[ops.length - 1];\n\n            if ((lastRem === null || lastRem === void 0 ? void 0 : lastRem.pos1) === r.position) {\n              lastRem.pos2 += r.segment.cachedLength;\n            } else {\n              ops.push(createRemoveRangeOp(r.position, r.position + r.segment.cachedLength));\n            }\n\n            break;\n          }\n\n        default:\n      }\n    }\n\n    return ops;\n  }\n  /**\n   * @param start - The inclusive start of the range to remove\n   * @param end - The exclusive end of the range to remove\n   */\n\n\n  removeRange(start, end) {\n    const removeOp = this.client.removeRangeLocal(start, end);\n\n    if (removeOp) {\n      this.submitSequenceMessage(removeOp);\n    }\n\n    return removeOp;\n  }\n\n  groupOperation(groupOp) {\n    this.client.localTransaction(groupOp);\n    this.submitSequenceMessage(groupOp);\n  }\n\n  getContainingSegment(pos) {\n    return this.client.getContainingSegment(pos);\n  }\n  /**\n   * Returns the length of the current sequence for the client\n   */\n\n\n  getLength() {\n    return this.client.getLength();\n  }\n  /**\n   * Returns the current position of a segment, and -1 if the segment\n   * does not exist in this sequence\n   * @param segment - The segment to get the position of\n   */\n\n\n  getPosition(segment) {\n    return this.client.getPosition(segment);\n  }\n  /**\n   * Annotates the range with the provided properties\n   *\n   * @param start - The inclusive start position of the range to annotate\n   * @param end - The exclusive end position of the range to annotate\n   * @param props - The properties to annotate the range with\n   * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n   *\n   */\n\n\n  annotateRange(start, end, props, combiningOp) {\n    const annotateOp = this.client.annotateRangeLocal(start, end, props, combiningOp);\n\n    if (annotateOp) {\n      this.submitSequenceMessage(annotateOp);\n    }\n  }\n\n  getPropertiesAtPosition(pos) {\n    return this.client.getPropertiesAtPosition(pos);\n  }\n\n  getRangeExtentsOfPosition(pos) {\n    return this.client.getRangeExtentsOfPosition(pos);\n  }\n  /**\n   * @deprecated - use createLocalReferencePosition\n   */\n\n\n  createPositionReference(segment, offset, refType) {\n    const lref = new LocalReference(this.client, segment, offset, refType);\n\n    if (refType !== ReferenceType.Transient) {\n      this.addLocalReference(lref);\n    }\n\n    return lref;\n  }\n\n  createLocalReferencePosition(segment, offset, refType, properties) {\n    return this.client.createLocalReferencePosition(segment, offset, refType, properties);\n  }\n  /**\n   * @deprecated - use localReferencePositionToPosition\n   */\n\n\n  localRefToPos(localRef) {\n    return this.client.localReferencePositionToPosition(localRef);\n  }\n\n  localReferencePositionToPosition(lref) {\n    return this.client.localReferencePositionToPosition(lref);\n  }\n  /**\n   * Resolves a remote client's position against the local sequence\n   * and returns the remote client's position relative to the local\n   * sequence. The client ref seq must be above the minimum sequence number\n   * or the return value will be undefined.\n   * Generally this method is used in conjunction with signals which provide\n   * point in time values for the below parameters, and is useful for things\n   * like displaying user position. It should not be used with persisted values\n   * as persisted values will quickly become invalid as the remoteClientRefSeq\n   * moves below the minimum sequence number\n   * @param remoteClientPosition - The remote client's position to resolve\n   * @param remoteClientRefSeq - The reference sequence number of the remote client\n   * @param remoteClientId - The client id of the remote client\n   */\n\n\n  resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {\n    return this.client.resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId);\n  }\n\n  submitSequenceMessage(message) {\n    if (!this.isAttached()) {\n      return;\n    }\n\n    const translated = makeHandlesSerializable(message, this.serializer, this.handle);\n    const metadata = this.client.peekPendingSegmentGroups(message.type === MergeTreeDeltaType.GROUP ? message.ops.length : 1); // if loading isn't complete, we need to cache\n    // local ops until loading is complete, and then\n    // they will be resent\n\n    if (!this.loadedDeferred.isCompleted) {\n      this.loadedDeferredOutgoingOps.push([translated, metadata]);\n    } else {\n      this.submitLocalMessage(translated, metadata);\n    }\n  }\n  /**\n   * @deprecated - use createLocalReferencePosition\n   */\n\n\n  addLocalReference(lref) {\n    return this.client.addLocalReference(lref);\n  }\n  /**\n   * @deprecated - use removeLocalReferencePosition\n   */\n\n\n  removeLocalReference(lref) {\n    return this.client.removeLocalReferencePosition(lref);\n  }\n\n  removeLocalReferencePosition(lref) {\n    return this.client.removeLocalReferencePosition(lref);\n  }\n  /**\n   * Given a position specified relative to a marker id, lookup the marker\n   * and convert the position to a character position.\n   * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.\n   */\n\n\n  posFromRelativePos(relativePos) {\n    return this.client.posFromRelativePos(relativePos);\n  }\n  /**\n   * Walk the underlying segments of the sequence.\n   * The walked segments may extend beyond the range\n   * if the segments cross the ranges start or end boundaries.\n   * Set split range to true to ensure only segments within the\n   * range are walked.\n   *\n   * @param handler - The function to handle each segment\n   * @param start - Optional. The start of range walk.\n   * @param end - Optional. The end of range walk\n   * @param accum - Optional. An object that will be passed to the handler for accumulation\n   * @param splitRange - Optional. Splits boundary segments on the range boundaries\n   */\n\n\n  walkSegments(handler, start, end, accum, splitRange = false) {\n    return this.client.walkSegments(handler, start, end, accum, splitRange);\n  }\n\n  getStackContext(startPos, rangeLabels) {\n    return this.client.getStackContext(startPos, rangeLabels);\n  }\n\n  getCurrentSeq() {\n    return this.client.getCurrentSeq();\n  }\n\n  insertAtReferencePosition(pos, segment) {\n    const insertOp = this.client.insertAtReferencePositionLocal(pos, segment);\n\n    if (insertOp) {\n      this.submitSequenceMessage(insertOp);\n    }\n  }\n  /**\n   * @deprecated - IntervalCollections are created on a first-write wins basis, and concurrent creates\n   * are supported. Use `getIntervalCollection` instead.\n   */\n\n\n  waitIntervalCollection(label) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this.intervalCollections.get(label);\n    })();\n  }\n\n  getIntervalCollection(label) {\n    return this.intervalCollections.get(label);\n  }\n  /**\n   * @returns an iterable object that enumerates the IntervalCollection labels\n   * Usage:\n   * const iter = this.getIntervalCollectionKeys();\n   * for (key of iter)\n   *     const collection = this.getIntervalCollection(key);\n   *     ...\n  */\n\n\n  getIntervalCollectionLabels() {\n    return this.intervalCollections.keys();\n  }\n\n  summarizeCore(serializer, telemetryContext) {\n    const builder = new SummaryTreeBuilder(); // conditionally write the interval collection blob\n    // only if it has entries\n\n    if (this.intervalCollections.size > 0) {\n      builder.addBlob(snapshotFileName, this.intervalCollections.serialize(serializer));\n    }\n\n    builder.addWithStats(contentPath, this.summarizeMergeTree(serializer));\n    return builder.getSummaryTree();\n  }\n  /**\n   * Runs serializer over the GC data for this SharedMatrix.\n   * All the IFluidHandle's represent routes to other objects.\n   */\n\n\n  processGCDataCore(serializer) {\n    if (this.intervalCollections.size > 0) {\n      this.intervalCollections.serialize(serializer);\n    }\n\n    this.client.serializeGCData(this.handle, serializer);\n  }\n  /**\n   * Replace the range specified from start to end with the provided segment\n   * This is done by inserting the segment at the end of the range, followed\n   * by removing the contents of the range\n   * For a zero or reverse range (start \\>= end), insert at end do not remove anything\n   * @param start - The start of the range to replace\n   * @param end - The end of the range to replace\n   * @param segment - The segment that will replace the range\n   */\n\n\n  replaceRange(start, end, segment) {\n    // Insert at the max end of the range when start > end, but still remove the range later\n    const insertIndex = Math.max(start, end); // Insert first, so local references can slide to the inserted seg if any\n\n    const insert = this.client.insertSegmentLocal(insertIndex, segment);\n\n    if (insert) {\n      if (start < end) {\n        const remove = this.client.removeRangeLocal(start, end);\n        this.submitSequenceMessage(createGroupOp(insert, remove));\n      } else {\n        this.submitSequenceMessage(insert);\n      }\n    }\n  }\n\n  onConnect() {\n    // Update merge tree collaboration information with new client ID and then resend pending ops\n    this.client.startOrUpdateCollaboration(this.runtime.clientId);\n  }\n\n  onDisconnect() {}\n\n  reSubmitCore(content, localOpMetadata) {\n    if (!this.intervalCollections.tryResubmitMessage(content, localOpMetadata)) {\n      this.submitSequenceMessage(this.client.regeneratePendingOp(content, localOpMetadata));\n    }\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n   */\n\n\n  loadCore(storage) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      if (yield storage.contains(snapshotFileName)) {\n        const blob = yield storage.readBlob(snapshotFileName);\n        const header = bufferToString(blob, \"utf8\");\n\n        _this2.intervalCollections.populate(header);\n      }\n\n      try {\n        // this will load the header, and return a promise\n        // that will resolve when the body is loaded\n        // and the catchup ops are available.\n        const {\n          catchupOpsP\n        } = yield _this2.client.load(_this2.runtime, new ObjectStoragePartition(storage, contentPath), _this2.serializer); // setup a promise to process the\n        // catch up ops, and finishing the loading process\n\n        const loadCatchUpOps = catchupOpsP.then(msgs => {\n          msgs.forEach(m => {\n            const collabWindow = _this2.client.getCollabWindow();\n\n            if (m.minimumSequenceNumber < collabWindow.minSeq || m.referenceSequenceNumber < collabWindow.minSeq || m.sequenceNumber <= collabWindow.minSeq || m.sequenceNumber <= collabWindow.currentSeq) {\n              throw new Error(`Invalid catchup operations in snapshot: ${JSON.stringify({\n                op: {\n                  seq: m.sequenceNumber,\n                  minSeq: m.minimumSequenceNumber,\n                  refSeq: m.referenceSequenceNumber\n                },\n                collabWindow: {\n                  seq: collabWindow.currentSeq,\n                  minSeq: collabWindow.minSeq\n                }\n              })}`);\n            }\n\n            _this2.processMergeTreeMsg(m);\n          });\n\n          _this2.loadFinished();\n        }).catch(error => {\n          _this2.loadFinished(error);\n        });\n\n        if (((_a = _this2.dataStoreRuntime.options) === null || _a === void 0 ? void 0 : _a.sequenceInitializeFromHeaderOnly) !== true) {\n          // if we not doing partial load, await the catch up ops,\n          // and the finalization of the load\n          yield loadCatchUpOps;\n        }\n      } catch (error) {\n        _this2.loadFinished(error);\n      }\n    })();\n  }\n\n  processCore(message, local, localOpMetadata) {\n    // if loading isn't complete, we need to cache all\n    // incoming ops to be applied after loading is complete\n    if (this.deferIncomingOps) {\n      assert(!local, 0x072\n      /* \"Unexpected local op when loading not finished\" */\n      );\n      this.loadedDeferredIncomingOps.push(message);\n    } else {\n      assert(message.type === MessageType.Operation, 0x073\n      /* \"Sequence message not operation\" */\n      );\n      const handled = this.intervalCollections.tryProcessMessage(message.contents, local, message, localOpMetadata);\n\n      if (!handled) {\n        this.processMergeTreeMsg(message, local);\n      }\n    }\n  }\n\n  didAttach() {\n    var _a; // If we are not local, and we've attached we need to start generating and sending ops\n    // so start collaboration and provide a default client id incase we are not connected\n\n\n    if (this.isAttached()) {\n      this.client.startOrUpdateCollaboration((_a = this.runtime.clientId) !== null && _a !== void 0 ? _a : \"attached\");\n    }\n  }\n\n  initializeLocalCore() {\n    super.initializeLocalCore();\n    this.loadFinished();\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObjectCore.applyStashedOp}\n   */\n\n\n  applyStashedOp(content) {\n    return this.client.applyStashedOp(content);\n  }\n\n  summarizeMergeTree(serializer) {\n    // Are we fully loaded? If not, things will go south\n    assert(this.loadedDeferred.isCompleted, 0x074\n    /* \"Snapshot called when not fully loaded\" */\n    );\n    const minSeq = this.runtime.deltaManager.minimumSequenceNumber;\n    this.processMinSequenceNumberChanged(minSeq);\n    this.messagesSinceMSNChange.forEach(m => {\n      m.minimumSequenceNumber = minSeq;\n    });\n    return this.client.summarize(this.runtime, this.handle, serializer, this.messagesSinceMSNChange);\n  }\n\n  processMergeTreeMsg(rawMessage, local) {\n    var _a, _b;\n\n    const message = parseHandles(rawMessage, this.serializer);\n    const ops = [];\n\n    function transformOps(event) {\n      ops.push(...SharedSegmentSequence.createOpsFromDelta(event));\n    }\n\n    const needsTransformation = message.referenceSequenceNumber !== message.sequenceNumber - 1;\n    let stashMessage = message;\n\n    if (((_a = this.runtime.options) === null || _a === void 0 ? void 0 : _a.newMergeTreeSnapshotFormat) !== true) {\n      if (needsTransformation) {\n        this.on(\"sequenceDelta\", transformOps);\n      }\n    }\n\n    this.client.applyMsg(message, local);\n\n    if (((_b = this.runtime.options) === null || _b === void 0 ? void 0 : _b.newMergeTreeSnapshotFormat) !== true) {\n      if (needsTransformation) {\n        this.removeListener(\"sequenceDelta\", transformOps); // shallow clone the message as we only overwrite top level properties,\n        // like referenceSequenceNumber and content only\n\n        stashMessage = Object.assign(Object.assign({}, message), {\n          referenceSequenceNumber: stashMessage.sequenceNumber - 1,\n          contents: ops.length !== 1 ? createGroupOp(...ops) : ops[0]\n        });\n      }\n\n      this.messagesSinceMSNChange.push(stashMessage); // Do GC every once in a while...\n\n      if (this.messagesSinceMSNChange.length > 20 && this.messagesSinceMSNChange[20].sequenceNumber < message.minimumSequenceNumber) {\n        this.processMinSequenceNumberChanged(message.minimumSequenceNumber);\n      }\n    }\n  }\n\n  processMinSequenceNumberChanged(minSeq) {\n    let index = 0;\n\n    for (; index < this.messagesSinceMSNChange.length; index++) {\n      if (this.messagesSinceMSNChange[index].sequenceNumber > minSeq) {\n        break;\n      }\n    }\n\n    if (index !== 0) {\n      this.messagesSinceMSNChange = this.messagesSinceMSNChange.slice(index);\n    }\n  }\n\n  loadFinished(error) {\n    if (!this.loadedDeferred.isCompleted) {\n      // Initialize the interval collections\n      this.initializeIntervalCollections();\n\n      if (error) {\n        this.loadedDeferred.reject(error);\n        throw error;\n      } else {\n        // it is important this series remains synchronous\n        // first we stop deferring incoming ops, and apply then all\n        this.deferIncomingOps = false;\n\n        for (const message of this.loadedDeferredIncomingOps) {\n          this.processCore(message, false, undefined);\n        }\n\n        this.loadedDeferredIncomingOps.length = 0; // then resolve the loaded promise\n        // and resubmit all the outstanding ops, as the snapshot\n        // is fully loaded, and all outstanding ops are applied\n\n        this.loadedDeferred.resolve();\n\n        for (const [messageContent, opMetadata] of this.loadedDeferredOutgoingOps) {\n          this.reSubmitCore(messageContent, opMetadata);\n        }\n\n        this.loadedDeferredOutgoingOps.length = 0;\n      }\n    }\n  }\n\n  initializeIntervalCollections() {\n    // Listen and initialize new SharedIntervalCollections\n    this.intervalCollections.eventEmitter.on(\"create\", ({\n      key,\n      previousValue\n    }, local) => {\n      const intervalCollection = this.intervalCollections.get(key);\n\n      if (!intervalCollection.attached) {\n        intervalCollection.attachGraph(this.client, key);\n      }\n\n      assert(previousValue === undefined, 0x2c1\n      /* \"Creating an interval collection that already exists?\" */\n      );\n      this.emit(\"createIntervalCollection\", key, local, this);\n    }); // Initialize existing SharedIntervalCollections\n\n    for (const key of this.intervalCollections.keys()) {\n      const intervalCollection = this.intervalCollections.get(key);\n      intervalCollection.attachGraph(this.client, key);\n    }\n  }\n\n} //# sourceMappingURL=sequence.js.map","map":null,"metadata":{},"sourceType":"module"}