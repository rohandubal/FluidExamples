{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BaseSegment, createGroupOp, LocalReferenceCollection } from \"@fluidframework/merge-tree\";\nimport { pkgVersion } from \"./packageVersion\";\nimport { SharedSegmentSequence, SubSequence } from \"./\";\n/**\n * An empty segment that occupies 'cachedLength' positions.  SparseMatrix uses PaddingSegment\n * to \"pad\" a run of unoccupied cells.\n *\n * @deprecated PaddingSegment is part of an abandoned prototype.  Use SharedMatrix instead.\n */\n\nexport let PaddingSegment = /*#__PURE__*/(() => {\n  class PaddingSegment extends BaseSegment {\n    constructor(size) {\n      super();\n      this.type = PaddingSegment.typeString;\n      this.cachedLength = size;\n    }\n\n    static is(segment) {\n      return segment.type === PaddingSegment.typeString;\n    }\n\n    static fromJSONObject(spec) {\n      if (spec && typeof spec === \"object\" && \"pad\" in spec) {\n        const segment = new PaddingSegment(spec.pad);\n\n        if (spec.props) {\n          segment.addProperties(spec.props);\n        }\n\n        return segment;\n      }\n\n      return undefined;\n    }\n\n    toJSONObject() {\n      return {\n        pad: this.cachedLength,\n        props: this.properties\n      };\n    }\n\n    clone(start = 0, end) {\n      const b = new PaddingSegment(this.cachedLength);\n      this.cloneInto(b);\n      return b;\n    }\n\n    canAppend(segment) {\n      return PaddingSegment.is(segment);\n    }\n\n    toString() {\n      return `[padding: ${this.cachedLength}]`;\n    }\n\n    append(segment) {\n      if (!PaddingSegment.is(segment)) {\n        throw new Error(\"can only append padding segment\");\n      } // Note: Must call 'appendLocalRefs' before modifying this segment's length as\n      //       'this.cachedLength' is used to adjust the offsets of the local refs.\n\n\n      LocalReferenceCollection.append(this, segment);\n      this.cachedLength += segment.cachedLength;\n    } // Returns true if entire run removed\n\n\n    removeRange(start, end) {\n      this.cachedLength -= end - start;\n      return this.cachedLength === 0;\n    }\n\n    createSplitSegmentAt(pos) {\n      const leftLength = pos;\n      const rightLength = this.cachedLength - pos;\n      this.cachedLength = leftLength;\n      return new PaddingSegment(rightLength);\n    }\n\n  }\n\n  PaddingSegment.typeString = \"PaddingSegment\";\n  /**\n   * @deprecated RunSegment is part of an abandoned prototype.  Use SharedMatrix instead.\n   */\n\n  return PaddingSegment;\n})();\nexport let RunSegment = /*#__PURE__*/(() => {\n  class RunSegment extends SubSequence {\n    constructor(items) {\n      super(items);\n      this.items = items;\n      this.type = RunSegment.typeString;\n      this.tags = new Array(items.length).fill(undefined);\n    }\n\n    static is(segment) {\n      return segment.type === RunSegment.typeString;\n    }\n\n    static fromJSONObject(spec) {\n      if (spec && typeof spec === \"object\" && \"items\" in spec) {\n        const segment = new RunSegment(spec.items);\n\n        if (spec.props) {\n          segment.addProperties(spec.props);\n        }\n\n        return segment;\n      }\n\n      return undefined;\n    }\n\n    clone(start = 0, end) {\n      const b = new RunSegment(this.items.slice(start, end));\n\n      if (this.tags) {\n        b.tags = this.tags.slice(start, end);\n      }\n\n      this.cloneInto(b);\n      return b;\n    }\n\n    append(segment) {\n      super.append(segment);\n      const asRun = segment;\n\n      if (asRun.tags) {\n        if (this.tags) {\n          this.tags.splice(this.items.length, 0, ...asRun.tags);\n        }\n      }\n\n      return this;\n    } // TODO: retain removed items for undo\n    // returns true if entire run removed\n\n\n    removeRange(start, end) {\n      this.tags.splice(start, end - start);\n      return super.removeRange(start, end);\n    }\n\n    getTag(pos) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return this.tags[pos];\n    }\n\n    setTag(pos, tag) {\n      this.tags[pos] = tag;\n    }\n\n    createSplitSegmentAt(pos) {\n      if (pos > 0) {\n        const remainingItems = this.items.slice(pos);\n        this.items = this.items.slice(0, pos);\n        this.cachedLength = this.items.length;\n        const leafSegment = new RunSegment(remainingItems);\n        leafSegment.tags = this.tags.slice(pos);\n        this.tags.length = pos;\n        return leafSegment;\n      }\n    }\n\n  }\n\n  RunSegment.typeString = \"RunSegment\";\n  /**\n   * @deprecated maxCol is part of an abandoned prototype.  Use SharedMatrix instead.\n   */\n\n  return RunSegment;\n})();\nexport const maxCol = 0x200000; // X128 Excel maximum of 16,384 columns\n\n/**\n * @deprecated maxCols is part of an abandoned prototype.  Use SharedMatrix instead.\n */\n\nexport const maxCols = maxCol + 1;\n/**\n * @deprecated maxRow is part of an abandoned prototype.  Use SharedMatrix instead.\n */\n\nexport const maxRow = 0xFFFFFFFF; // X4096 Excel maximum of 1,048,576 rows\n\n/**\n * @deprecated maxRows is part of an abandoned prototype.  Use SharedMatrix instead.\n */\n\nexport const maxRows = maxRow + 1;\n/**\n * @deprecated maxCellPosition is part of an abandoned prototype.  Use SharedMatrix instead.\n */\n\nexport const maxCellPosition = maxCol * maxRow;\n/**\n * @deprecated positionToRowCol is part of an abandoned prototype.  Use SharedMatrix instead.\n */\n\nexport const rowColToPosition = (row, col) => row * maxCols + col;\n/**\n * @deprecated positionToRowCol is part of an abandoned prototype.  Use SharedMatrix instead.\n */\n\nexport function positionToRowCol(position) {\n  const row = Math.floor(position / maxCols);\n  const col = position - row * maxCols;\n  return {\n    row,\n    col\n  };\n}\n/**\n * @deprecated SparseMatrix is an abandoned prototype.  Use SharedMatrix instead.\n */\n\nexport class SparseMatrix extends SharedSegmentSequence {\n  constructor(document, id, attributes) {\n    super(document, id, attributes, SparseMatrixFactory.segmentFromSpec);\n    this.id = id;\n  }\n  /**\n   * Create a new sparse matrix\n   *\n   * @param runtime - data store runtime the new sparse matrix belongs to\n   * @param id - optional name of the sparse matrix\n   * @returns newly create sparse matrix (but not attached yet)\n   */\n\n\n  static create(runtime, id) {\n    return runtime.createChannel(id, SparseMatrixFactory.Type);\n  }\n  /**\n   * Get a factory for SharedMap to register with the data store.\n   *\n   * @returns a factory that creates and load SharedMap\n   */\n\n\n  static getFactory() {\n    return new SparseMatrixFactory();\n  }\n\n  get numRows() {\n    return positionToRowCol(this.getLength()).row;\n  }\n\n  setItems(row, col, values, props) {\n    const start = rowColToPosition(row, col);\n    const end = start + values.length;\n    const segment = new RunSegment(values);\n\n    if (props) {\n      segment.addProperties(props);\n    }\n\n    this.replaceRange(start, end, segment);\n  }\n\n  getItem(row, col) {\n    const pos = rowColToPosition(row, col);\n    const {\n      segment,\n      offset\n    } = this.getContainingSegment(pos);\n\n    if (segment && RunSegment.is(segment)) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return segment.items[offset];\n    } else if (segment && PaddingSegment.is(segment)) {\n      return undefined;\n    }\n\n    throw new Error(`Unrecognized Segment type`);\n  }\n\n  getTag(row, col) {\n    const {\n      segment,\n      offset\n    } = this.getSegment(row, col);\n\n    if (RunSegment.is(segment)) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return segment.getTag(offset);\n    }\n\n    return undefined;\n  }\n\n  setTag(row, col, tag) {\n    const {\n      segment,\n      offset\n    } = this.getSegment(row, col);\n\n    if (RunSegment.is(segment)) {\n      segment.setTag(offset, tag);\n    } else if (tag !== undefined) {\n      throw new Error(`Must not attempt to set tags on '${segment.constructor.name}'.`);\n    }\n  }\n\n  insertRows(row, numRows) {\n    const pos = rowColToPosition(row, 0);\n    const size = maxCols * numRows;\n    const segment = new PaddingSegment(size);\n    const insertOp = this.client.insertSegmentLocal(pos, segment);\n\n    if (insertOp) {\n      this.submitSequenceMessage(insertOp);\n    }\n  }\n\n  removeRows(row, numRows) {\n    const pos = rowColToPosition(row, 0);\n    const size = maxCols * numRows;\n    this.removeRange(pos, pos + size);\n  }\n\n  insertCols(col, numCols) {\n    this.moveAsPadding(maxCol - numCols, col, numCols);\n  }\n\n  removeCols(col, numCols) {\n    this.moveAsPadding(col, maxCol - numCols, numCols);\n  }\n\n  annotatePosition(row, col, props) {\n    const pos = rowColToPosition(row, col);\n    this.annotateRange(pos, pos + 1, props);\n  }\n\n  getPositionProperties(row, col) {\n    const pos = rowColToPosition(row, col);\n    return this.getPropertiesAtPosition(pos);\n  } // For each row, moves 'numCols' items starting from 'srcCol' and inserts 'numCols' padding\n  // at 'destCol'.  Used by insertCols and removeCols.\n\n\n  moveAsPadding(srcCol, destCol, numCols) {\n    const removeColStart = srcCol;\n    const removeColEnd = srcCol + numCols;\n    const ops = [];\n\n    for (let r = 0, rowStart = 0; r < this.numRows; r++, rowStart += maxCols) {\n      ops.push(this.client.removeRangeLocal(rowStart + removeColStart, rowStart + removeColEnd));\n      const insertPos = rowStart + destCol;\n      const segment = new PaddingSegment(numCols);\n      ops.push(this.client.insertSegmentLocal(insertPos, segment));\n    }\n\n    this.submitSequenceMessage(createGroupOp(...ops));\n  }\n\n  getSegment(row, col) {\n    const pos = rowColToPosition(row, col);\n    return this.getContainingSegment(pos);\n  }\n\n}\n/**\n * @deprecated SparseMatrixFactory is an abandoned prototype.  Use SharedMatrixFactory instead.\n */\n\nexport class SparseMatrixFactory {\n  static segmentFromSpec(spec) {\n    const maybePadding = PaddingSegment.fromJSONObject(spec);\n\n    if (maybePadding) {\n      return maybePadding;\n    }\n\n    const maybeRun = RunSegment.fromJSONObject(spec);\n\n    if (maybeRun) {\n      return maybeRun;\n    }\n\n    throw new Error(`Unrecognized IJSONObject: '${JSON.stringify(spec)}'`);\n  }\n\n  get type() {\n    return SparseMatrixFactory.Type;\n  }\n\n  get attributes() {\n    return SparseMatrixFactory.Attributes;\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n   */\n\n\n  load(runtime, id, services, attributes) {\n    return _asyncToGenerator(function* () {\n      const sharedObject = new SparseMatrix(runtime, id, attributes);\n      yield sharedObject.load(services);\n      return sharedObject;\n    })();\n  }\n\n  create(document, id) {\n    const sharedObject = new SparseMatrix(document, id, this.attributes);\n    sharedObject.initializeLocal();\n    return sharedObject;\n  }\n\n}\nSparseMatrixFactory.Type = \"https://graph.microsoft.com/types/mergeTree/sparse-matrix\";\nSparseMatrixFactory.Attributes = {\n  type: SparseMatrixFactory.Type,\n  snapshotFormatVersion: \"0.1\",\n  packageVersion: pkgVersion\n}; //# sourceMappingURL=sparsematrix.js.map","map":null,"metadata":{},"sourceType":"module"}