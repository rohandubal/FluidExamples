{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BaseSegment } from \"./mergeTree\";\nimport { LocalReferenceCollection } from \"./localReference\"; // Maximum length of text segment to be considered to be merged with other segment.\n// Maximum segment length is at least 2x of it (not taking into account initial segment creation).\n// The bigger it is, the more expensive it is to break segment into sub-segments (on edits)\n// The smaller it is, the more segments we have in snapshots (and in memory) - it's more expensive to load snapshots.\n// Small number also makes ReplayTool produce false positives (\"same\" snapshots have slightly different binary\n// representations).  More measurements needs to be done, but it's very likely the right spot is somewhere between\n// 1K-2K mark.  That said, we also break segments on newline and there are very few segments that are longer than 256\n// because of it.  Must be an even number\n\nconst TextSegmentGranularity = 256;\nexport let TextSegment = /*#__PURE__*/(() => {\n  class TextSegment extends BaseSegment {\n    constructor(text) {\n      super();\n      this.text = text;\n      this.type = TextSegment.type;\n      this.cachedLength = text.length;\n    }\n\n    static is(segment) {\n      return segment.type === TextSegment.type;\n    }\n\n    static make(text, props) {\n      const seg = new TextSegment(text);\n\n      if (props) {\n        seg.addProperties(props);\n      }\n\n      return seg;\n    }\n\n    static fromJSONObject(spec) {\n      if (typeof spec === \"string\") {\n        return new TextSegment(spec);\n      } else if (spec && typeof spec === \"object\" && \"text\" in spec) {\n        const textSpec = spec;\n        return TextSegment.make(textSpec.text, textSpec.props);\n      }\n\n      return undefined;\n    }\n\n    toJSONObject() {\n      // To reduce snapshot/ops size, we serialize a TextSegment as a plain 'string' if it is\n      // not annotated.\n      return this.properties ? {\n        text: this.text,\n        props: this.properties\n      } : this.text;\n    }\n\n    clone(start = 0, end) {\n      const text = this.text.substring(start, end);\n      const b = TextSegment.make(text, this.properties);\n      this.cloneInto(b);\n      return b;\n    }\n\n    canAppend(segment) {\n      return !this.text.endsWith(\"\\n\") && TextSegment.is(segment) && (this.cachedLength <= TextSegmentGranularity || segment.cachedLength <= TextSegmentGranularity);\n    }\n\n    toString() {\n      return this.text;\n    }\n\n    append(segment) {\n      if (TextSegment.is(segment)) {\n        // Note: Must call 'appendLocalRefs' before modifying this segment's length as\n        // 'this.cachedLength' is used to adjust the offsets of the local refs.\n        LocalReferenceCollection.append(this, segment);\n        this.text += segment.text;\n        this.cachedLength = this.text.length;\n      } else {\n        throw new Error(\"can only append text segment\");\n      }\n    } // TODO: retain removed text for undo\n    // returns true if entire string removed\n\n\n    removeRange(start, end) {\n      let remnantString = \"\";\n      const len = this.text.length;\n\n      if (start > 0) {\n        remnantString += this.text.substring(0, start);\n      }\n\n      if (end < len) {\n        remnantString += this.text.substring(end);\n      }\n\n      this.text = remnantString;\n      this.cachedLength = remnantString.length;\n      return remnantString.length === 0;\n    }\n\n    createSplitSegmentAt(pos) {\n      if (pos > 0) {\n        const remainingText = this.text.substring(pos);\n        this.text = this.text.substring(0, pos);\n        this.cachedLength = this.text.length;\n        const leafSegment = new TextSegment(remainingText);\n        return leafSegment;\n      }\n    }\n\n  }\n\n  TextSegment.type = \"TextSegment\";\n  return TextSegment;\n})();\n\nfunction isTextAndMarkerAccumulator(accum) {\n  return accum.parallelArrays === true;\n}\n\nexport class MergeTreeTextHelper {\n  constructor(mergeTree) {\n    this.mergeTree = mergeTree;\n\n    this.gatherText = (segment, pos, refSeq, clientId, start, end, accumText) => {\n      var _a, _b;\n\n      let _start = start;\n\n      if (TextSegment.is(segment)) {\n        let beginTags = \"\";\n        let endTags = \"\";\n\n        if (isTextAndMarkerAccumulator(accumText)) {\n          // TODO: let clients pass in function to get tag\n          const tags = [];\n          const initTags = [];\n\n          if ((_a = segment.properties) === null || _a === void 0 ? void 0 : _a[\"font-weight\"]) {\n            tags.push(\"b\");\n          }\n\n          if ((_b = segment.properties) === null || _b === void 0 ? void 0 : _b[\"text-decoration\"]) {\n            tags.push(\"u\");\n          }\n\n          const remTags = [];\n\n          if (tags.length > 0) {\n            for (const tag of tags) {\n              if (!accumText.tagsInProgress.includes(tag)) {\n                beginTags += `<${tag}>`;\n                initTags.push(tag);\n              }\n            }\n\n            for (const accumTag of accumText.tagsInProgress) {\n              if (!tags.includes(accumTag)) {\n                endTags += `</${accumTag}>`;\n                remTags.push(accumTag);\n              }\n            }\n\n            for (const initTag of initTags.reverse()) {\n              accumText.tagsInProgress.push(initTag);\n            }\n          } else {\n            for (const accumTag of accumText.tagsInProgress) {\n              endTags += `</${accumTag}>`;\n              remTags.push(accumTag);\n            }\n          }\n\n          for (const remTag of remTags) {\n            const remdex = accumText.tagsInProgress.indexOf(remTag);\n\n            if (remdex >= 0) {\n              accumText.tagsInProgress.splice(remdex, 1);\n            }\n          }\n        }\n\n        accumText.textSegment.text += endTags;\n        accumText.textSegment.text += beginTags;\n\n        if (_start <= 0 && end >= segment.text.length) {\n          accumText.textSegment.text += segment.text;\n        } else {\n          if (_start < 0) {\n            _start = 0;\n          }\n\n          if (end >= segment.text.length) {\n            accumText.textSegment.text += segment.text.substring(_start);\n          } else {\n            accumText.textSegment.text += segment.text.substring(_start, end);\n          }\n        }\n      } else {\n        if (accumText.placeholder && accumText.placeholder.length > 0) {\n          if (accumText.placeholder === \"*\") {\n            const marker = segment;\n            accumText.textSegment.text += `\\n${marker.toString()}`;\n          } else {\n            for (let i = 0; i < segment.cachedLength; i++) {\n              accumText.textSegment.text += accumText.placeholder;\n            }\n          }\n        } else if (isTextAndMarkerAccumulator(accumText)) {\n          const marker = segment;\n\n          if (marker.hasTileLabel(accumText.parallelMarkerLabel)) {\n            accumText.parallelMarkers.push(marker);\n            accumText.parallelText.push(accumText.textSegment.text);\n            accumText.textSegment.text = \"\";\n          }\n        }\n      }\n\n      return true;\n    };\n  }\n\n  getTextAndMarkers(refSeq, clientId, label, start, end) {\n    const range = this.getValidRange(start, end, refSeq, clientId);\n    const accum = {\n      parallelArrays: true,\n      parallelMarkerLabel: label,\n      parallelMarkers: [],\n      parallelText: [],\n      tagsInProgress: [],\n      textSegment: new TextSegment(\"\")\n    };\n    this.mergeTree.mapRange({\n      leaf: this.gatherText\n    }, refSeq, clientId, accum, range.start, range.end);\n    return {\n      parallelText: accum.parallelText,\n      parallelMarkers: accum.parallelMarkers\n    };\n  }\n\n  getText(refSeq, clientId, placeholder = \"\", start, end) {\n    const range = this.getValidRange(start, end, refSeq, clientId);\n    const accum = {\n      textSegment: new TextSegment(\"\"),\n      placeholder\n    };\n    this.mergeTree.mapRange({\n      leaf: this.gatherText\n    }, refSeq, clientId, accum, range.start, range.end);\n    return accum.textSegment.text;\n  }\n\n  getValidRange(start, end, refSeq, clientId) {\n    const range = {\n      end: end !== null && end !== void 0 ? end : this.mergeTree.getLength(refSeq, clientId),\n      start: start !== null && start !== void 0 ? start : 0\n    };\n    return range;\n  }\n\n} //# sourceMappingURL=textSegment.js.map","map":null,"metadata":{},"sourceType":"module"}