{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { v4 as uuid } from \"uuid\";\nimport { assert } from \"@fluidframework/common-utils\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { blobCountPropertyName, totalBlobSizePropertyName } from \"@fluidframework/runtime-definitions\";\nimport { ChildLogger, EventEmitterWithErrorHandling, loggerToMonitoringContext, SampledTelemetryHelper, TelemetryDataTag } from \"@fluidframework/telemetry-utils\";\nimport { DataProcessingError } from \"@fluidframework/container-utils\";\nimport { FluidSerializer } from \"./serializer\";\nimport { SharedObjectHandle } from \"./handle\";\nimport { SummarySerializer } from \"./summarySerializer\";\n/**\n *  Base class from which all shared objects derive\n */\n\nexport class SharedObjectCore extends EventEmitterWithErrorHandling {\n  /**\n   * @param id - The id of the shared object\n   * @param runtime - The IFluidDataStoreRuntime which contains the shared object\n   * @param attributes - Attributes of the shared object\n   */\n  constructor(id, runtime, attributes) {\n    super((event, e) => this.eventListenerErrorHandler(event, e));\n    this.id = id;\n    this.runtime = runtime;\n    this.attributes = attributes;\n    /**\n     * Connection state\n     */\n\n    this._connected = false;\n    /**\n     * True if the dds is bound to its parent.\n     */\n\n    this._isBoundToContext = false;\n    assert(!id.includes(\"/\"), 0x304\n    /* Id cannot contain slashes */\n    );\n    this.handle = new SharedObjectHandle(this, id, runtime.IFluidHandleContext);\n    this.logger = ChildLogger.create(runtime.logger, undefined, {\n      all: {\n        sharedObjectId: uuid(),\n        ddsType: {\n          value: this.attributes.type,\n          tag: TelemetryDataTag.CodeArtifact\n        }\n      }\n    });\n    this.mc = loggerToMonitoringContext(this.logger);\n    [this.opProcessingHelper, this.callbacksHelper] = this.setUpSampledTelemetryHelpers();\n    this.attachListeners();\n  }\n\n  get IFluidLoadable() {\n    return this;\n  }\n  /**\n   * Gets the connection state\n   * @returns The state of the connection\n   */\n\n\n  get connected() {\n    return this._connected;\n  }\n  /**\n   * This function is only supposed to be called from SharedObjectCore's constructor and\n   * depends on a few things being set already. assert() calls make sure of it.\n   * @returns The telemetry sampling helpers, so the constructor can be the one to assign them\n   * to variables to avoid complaints from TypeScript.\n   */\n\n\n  setUpSampledTelemetryHelpers() {\n    var _a, _b;\n\n    assert(this.mc !== undefined && this.logger !== undefined, \"this.mc and/or this.logger has not been set\");\n    const opProcessingHelper = new SampledTelemetryHelper({\n      eventName: \"ddsOpProcessing\",\n      category: \"performance\"\n    }, this.logger, (_a = this.mc.config.getNumber(\"Fluid.SharedObject.OpProcessingTelemetrySampling\")) !== null && _a !== void 0 ? _a : 100, true, new Map([[\"local\", {\n      localOp: true\n    }], [\"remote\", {\n      localOp: false\n    }]]));\n    const callbacksHelper = new SampledTelemetryHelper({\n      eventName: \"ddsEventCallbacks\",\n      category: \"performance\"\n    }, this.logger, (_b = this.mc.config.getNumber(\"Fluid.SharedObject.DdsCallbacksTelemetrySampling\")) !== null && _b !== void 0 ? _b : 100, true);\n    this.runtime.once(\"dispose\", () => {\n      this.callbacksHelper.dispose();\n      this.opProcessingHelper.dispose();\n    });\n    return [opProcessingHelper, callbacksHelper];\n  }\n  /**\n   * Marks this objects as closed. Any attempt to change it (local changes or processing remote ops)\n   * would result in same error thrown. If called multiple times, only first error is remembered.\n   * @param error - error object that is thrown whenever an attempt is made to modify this object\n   */\n\n\n  closeWithError(error) {\n    if (this.closeError === undefined) {\n      this.closeError = error;\n    }\n  }\n  /**\n   * Verifies that this object is not closed via closeWithError(). If it is, throws an error used to close it.\n   */\n\n\n  verifyNotClosed() {\n    if (this.closeError !== undefined) {\n      throw this.closeError;\n    }\n  }\n  /**\n   * Event listener handler helper that can be used to react to exceptions thrown from event listeners\n   * It wraps error with DataProcessingError, closes this object and throws resulting error.\n   * See closeWithError() for more details\n   * Ideally such situation never happens, as consumers of DDS should never throw exceptions\n   * in event listeners (i.e. catch any of the issues and make determination on how to handle it).\n   * When such exceptions propagate through, most likely data model is no longer consistent, i.e.\n   * DDS state does not match what user sees. Because of it DDS moves to \"corrupted state\" and does not\n   * allow processing of ops or local changes, which very quickly results in container closure.\n   */\n\n\n  eventListenerErrorHandler(event, e) {\n    const error = DataProcessingError.wrapIfUnrecognized(e, \"SharedObjectEventListenerException\");\n    error.addTelemetryProperties({\n      emittedEventName: String(event)\n    });\n    this.closeWithError(error);\n    throw error;\n  }\n\n  attachListeners() {\n    // Only listen to these events if not attached.\n    if (!this.isAttached()) {\n      this.runtime.once(\"attaching\", () => {\n        // Calling this will let the dds to do any custom processing based on attached\n        // like starting generating ops.\n        this.didAttach();\n      });\n    }\n  }\n  /**\n   * A shared object, after construction, can either be loaded in the case that it is already part of\n   * a shared document. Or later attached if it is being newly added.\n   * @param services - Services used by the shared object\n   */\n\n\n  load(services) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.runtime.attachState !== AttachState.Detached) {\n        _this.services = services;\n      }\n\n      yield _this.loadCore(services.objectStorage);\n\n      if (_this.runtime.attachState !== AttachState.Detached) {\n        _this.attachDeltaHandler();\n      }\n    })();\n  }\n  /**\n   * Initializes the object as a local, non-shared object. This object can become shared after\n   * it is attached to the document.\n   */\n\n\n  initializeLocal() {\n    this.initializeLocalCore();\n  }\n  /**\n   * {@inheritDoc (ISharedObject:interface).bindToContext}\n   */\n\n\n  bindToContext() {\n    if (this._isBoundToContext) {\n      return;\n    }\n\n    this._isBoundToContext = true;\n    this.runtime.bindChannel(this);\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).connect}\n   */\n\n\n  connect(services) {\n    this.services = services;\n    this.attachDeltaHandler();\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).isAttached}\n   */\n\n\n  isAttached() {\n    return this.services !== undefined && this.runtime.attachState !== AttachState.Detached;\n  }\n  /**\n   * Called when a handle is decoded by this object. A handle in the object's data represents an outbound reference\n   * to another object in the container.\n   * @param decodedHandle - The handle of the Fluid object that is decoded.\n   */\n\n\n  handleDecoded(decodedHandle) {\n    var _a, _b, _c;\n\n    if (this.isAttached()) {\n      // This represents an outbound reference from this object to the node represented by decodedHandle.\n      (_c = (_a = this.services) === null || _a === void 0 ? void 0 : (_b = _a.deltaConnection).addedGCOutboundReference) === null || _c === void 0 ? void 0 : _c.call(_b, this.handle, decodedHandle);\n    }\n  }\n  /**\n   * Allows the distributed data type to perform custom local loading.\n   */\n\n\n  initializeLocalCore() {\n    return;\n  }\n  /**\n   * Allows the distributive data type the ability to perform custom processing once an attach has happened.\n   * Also called after non-local data type get loaded.\n   */\n\n\n  didAttach() {\n    return;\n  }\n  /**\n   * Submits a message by the local client to the runtime.\n   * @param content - Content of the message\n   * @param localOpMetadata - The local metadata associated with the message. This is kept locally by the runtime\n   * and not sent to the server. This will be sent back when this message is received back from the server. This is\n   * also sent if we are asked to resubmit the message.\n   */\n\n\n  submitLocalMessage(content, localOpMetadata = undefined) {\n    this.verifyNotClosed();\n\n    if (this.isAttached()) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.services.deltaConnection.submit(content, localOpMetadata);\n    }\n  }\n  /**\n   * Marks this object as dirty so that it is part of the next summary. It is called by a SharedSummaryBlock\n   * that want to be part of summary but does not generate ops.\n   */\n\n\n  dirty() {\n    if (!this.isAttached()) {\n      return;\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    this.services.deltaConnection.dirty();\n  }\n  /**\n   * Called when the object has fully connected to the delta stream\n   * Default implementation for DDS, override if different behavior is required.\n   */\n\n\n  onConnect() {}\n  /**\n   * Called when a message has to be resubmitted. This typically happens after a reconnection for unacked messages.\n   * The default implementation here is to resubmit the same message. The client can override if different behavior\n   * is required. It can choose to resubmit the same message, submit different / multiple messages or not submit\n   * anything at all.\n   * @param content - The content of the original message.\n   * @param localOpMetadata - The local metadata associated with the original message.\n   */\n\n\n  reSubmitCore(content, localOpMetadata) {\n    this.submitLocalMessage(content, localOpMetadata);\n  }\n  /**\n   * Promises that are waiting for an ack from the server before resolving should use this instead of new Promise.\n   * It ensures that if something changes that will interrupt that ack (e.g. the FluidDataStoreRuntime disposes),\n   * the Promise will reject.\n   * If runtime is disposed when this call is made, executor is not run and promise is rejected right away.\n   */\n\n\n  newAckBasedPromise(executor) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let rejectBecauseDispose;\n      return new Promise((resolve, reject) => {\n        rejectBecauseDispose = () => reject(new Error(\"FluidDataStoreRuntime disposed while this ack-based Promise was pending\"));\n\n        if (_this2.runtime.disposed) {\n          rejectBecauseDispose();\n          return;\n        }\n\n        _this2.runtime.on(\"dispose\", rejectBecauseDispose);\n\n        executor(resolve, reject);\n      }).finally(() => {\n        // Note: rejectBecauseDispose will never be undefined here\n        _this2.runtime.off(\"dispose\", rejectBecauseDispose);\n      });\n    })();\n  }\n\n  attachDeltaHandler() {\n    // Services should already be there in case we are attaching delta handler.\n    assert(this.services !== undefined, 0x07a\n    /* \"Services should be there to attach delta handler\" */\n    );\n    this._isBoundToContext = true; // Allows objects to do any custom processing if it is attached.\n\n    this.didAttach(); // attachDeltaHandler is only called after services is assigned\n\n    this.services.deltaConnection.attach({\n      process: (message, local, localOpMetadata) => {\n        this.process(message, local, localOpMetadata);\n      },\n      setConnectionState: connected => {\n        this.setConnectionState(connected);\n      },\n      reSubmit: (content, localOpMetadata) => {\n        this.reSubmit(content, localOpMetadata);\n      },\n      applyStashedOp: content => {\n        return this.applyStashedOp(content);\n      },\n      rollback: (content, localOpMetadata) => {\n        this.rollback(content, localOpMetadata);\n      }\n    }); // Trigger initial state\n    // attachDeltaHandler is only called after services is assigned\n\n    this.setConnectionState(this.services.deltaConnection.connected);\n  }\n  /**\n   * Set the state of connection to services.\n   * @param connected - true if connected, false otherwise.\n   */\n\n\n  setConnectionState(connected) {\n    if (this._connected === connected) {\n      // Not changing state, nothing the same.\n      return;\n    } // Should I change the state at the end? So that we *can't* send new stuff before we send old?\n\n\n    this._connected = connected;\n\n    if (!connected) {\n      // Things that are true now...\n      // - if we had a connection we can no longer send messages over it\n      // - if we had outbound messages some may or may not be ACK'd. Won't know until next message\n      //\n      // - nack could get a new msn - but might as well do it in the join?\n      this.onDisconnect();\n    } else {\n      // Call this for now so that DDSes like ConsensusOrderedCollection that maintain their own pending\n      // messages will work.\n      this.onConnect();\n    }\n  }\n  /**\n   * Handles a message being received from the remote delta server.\n   * @param message - The message to process\n   * @param local - Whether the message originated from the local client\n   * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.\n   * For messages from a remote client, this will be undefined.\n   */\n\n\n  process(message, local, localOpMetadata) {\n    this.verifyNotClosed(); // This will result in container closure.\n\n    this.emitInternal(\"pre-op\", message, local, this);\n    this.opProcessingHelper.measure(() => {\n      this.processCore(message, local, localOpMetadata);\n    }, local ? \"local\" : \"remote\");\n    this.emitInternal(\"op\", message, local, this);\n  }\n  /**\n   * Called when a message has to be resubmitted. This typically happens for unacked messages after a\n   * reconnection.\n   * @param content - The content of the original message.\n   * @param localOpMetadata - The local metadata associated with the original message.\n   */\n\n\n  reSubmit(content, localOpMetadata) {\n    this.reSubmitCore(content, localOpMetadata);\n  }\n  /**\n   * Revert an op\n   */\n\n\n  rollback(content, localOpMetadata) {\n    throw new Error(\"rollback not supported\");\n  }\n  /**\n   * Emit an event. This function is only intended for use by DDS classes that extend SharedObject/SharedObjectCore,\n   * specifically to emit events that are part of the public interface of the DDS (i.e. those that can have listeners\n   * attached to them by the consumers of the DDS). It should not be called from outside the class or to emit events\n   * which are only internal to the DDS. Support for calling it from outside the DDS instance might be removed in the\n   * future.\n   *\n   * @internal\n   *\n   * @param event - The event to emit.\n   * @param args - Arguments to pass to the event listeners.\n   * @returns `true` if the event had listeners, `false` otherwise.\n   */\n\n\n  emit(event, ...args) {\n    return this.callbacksHelper.measure(() => super.emit(event, ...args));\n  }\n  /**\n   * Use to emit events inside {@link SharedObjectCore}, with no telemetry measurement\n   * done on the duration of the callbacks. Simply calls `super.emit()`.\n   * @param event - Event to emit\n   * @param args - Arguments for the event\n   * @returns Whatever `super.emit()` returns.\n   */\n\n\n  emitInternal(event, ...args) {\n    return super.emit(event, ...args);\n  }\n\n}\n/**\n * SharedObject with simplified, synchronous summarization and GC.\n * DDS implementations with async and incremental summarization should extend SharedObjectCore directly instead.\n */\n\nexport class SharedObject extends SharedObjectCore {\n  /**\n   * @param id - The id of the shared object\n   * @param runtime - The IFluidDataStoreRuntime which contains the shared object\n   * @param attributes - Attributes of the shared object\n   */\n  constructor(id, runtime, attributes, telemetryContextPrefix) {\n    super(id, runtime, attributes);\n    this.telemetryContextPrefix = telemetryContextPrefix;\n    /**\n     * True while we are garbage collecting this object's data.\n     */\n\n    this._isGCing = false;\n    this._serializer = new FluidSerializer(this.runtime.channelsRoutingContext, handle => this.handleDecoded(handle));\n  }\n\n  get serializer() {\n    /**\n     * During garbage collection, the SummarySerializer keeps track of IFluidHandles that are serialized. These\n     * handles represent references to other Fluid objects.\n     *\n     * This is fine for now. However, if we implement delay loading in DDss, they may load and de-serialize content\n     * in summarize. When that happens, they may incorrectly hit this assert and we will have to change this.\n     */\n    assert(!this._isGCing, 0x075\n    /* \"SummarySerializer should be used for serializing data during summary.\" */\n    );\n    return this._serializer;\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).getAttachSummary}\n   */\n\n\n  getAttachSummary(fullTree = false, trackState = false, telemetryContext) {\n    const result = this.summarizeCore(this.serializer, telemetryContext);\n    this.incrementTelemetryMetric(blobCountPropertyName, result.stats.blobNodeCount, telemetryContext);\n    this.incrementTelemetryMetric(totalBlobSizePropertyName, result.stats.totalBlobSize, telemetryContext);\n    return result;\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).summarize}\n   */\n\n\n  summarize(fullTree = false, trackState = false, telemetryContext) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const result = _this3.summarizeCore(_this3.serializer, telemetryContext);\n\n      _this3.incrementTelemetryMetric(blobCountPropertyName, result.stats.blobNodeCount, telemetryContext);\n\n      _this3.incrementTelemetryMetric(totalBlobSizePropertyName, result.stats.totalBlobSize, telemetryContext);\n\n      return result;\n    })();\n  }\n  /**\n   * {@inheritDoc (ISharedObject:interface).getGCData}\n   */\n\n\n  getGCData(fullGC = false) {\n    // Set _isGCing to true. This flag is used to ensure that we only use SummarySerializer to serialize handles\n    // in this object's data.\n    assert(!this._isGCing, 0x078\n    /* \"Possible re-entrancy! Summary should not already be in progress.\" */\n    );\n    this._isGCing = true;\n    let gcData;\n\n    try {\n      const serializer = new SummarySerializer(this.runtime.channelsRoutingContext, handle => this.handleDecoded(handle));\n      this.processGCDataCore(serializer); // The GC data for this shared object contains a single GC node. The outbound routes of this node are the\n      // routes of handles serialized during summarization.\n\n      gcData = {\n        gcNodes: {\n          \"/\": serializer.getSerializedRoutes()\n        }\n      };\n      assert(this._isGCing, 0x079\n      /* \"Possible re-entrancy! Summary should have been in progress.\" */\n      );\n    } finally {\n      this._isGCing = false;\n    }\n\n    return gcData;\n  }\n  /**\n   * Calls the serializer over all data in this object that reference other GC nodes.\n   * Derived classes must override this to provide custom list of references to other GC nodes.\n   */\n\n\n  processGCDataCore(serializer) {\n    // We run the full summarize logic to get the list of outbound routes from this object. This is a little\n    // expensive but its okay for now. It will be updated to not use full summarize and make it more efficient.\n    // See: https://github.com/microsoft/FluidFramework/issues/4547\n    this.summarizeCore(serializer);\n  }\n\n  incrementTelemetryMetric(propertyName, incrementBy, telemetryContext) {\n    var _a;\n\n    const prevTotal = (_a = telemetryContext === null || telemetryContext === void 0 ? void 0 : telemetryContext.get(this.telemetryContextPrefix, propertyName)) !== null && _a !== void 0 ? _a : 0;\n    telemetryContext === null || telemetryContext === void 0 ? void 0 : telemetryContext.set(this.telemetryContextPrefix, propertyName, prevTotal + incrementBy);\n  }\n\n} //# sourceMappingURL=sharedObject.js.map","map":null,"metadata":{},"sourceType":"module"}