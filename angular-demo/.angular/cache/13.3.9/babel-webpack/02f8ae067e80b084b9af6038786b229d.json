{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { LoaderCachingPolicy } from \"@fluidframework/driver-definitions\";\nimport { DocumentStorageServiceProxy } from \"./documentStorageServiceProxy\";\nimport { canRetryOnError } from \"./network\";\nexport class PrefetchDocumentStorageService extends DocumentStorageServiceProxy {\n  constructor() {\n    super(...arguments); // BlobId -> blob prefetchCache cache\n\n    this.prefetchCache = new Map();\n    this.prefetchEnabled = true;\n  }\n\n  get policies() {\n    const policies = this.internalStorageService.policies;\n\n    if (policies) {\n      return Object.assign(Object.assign({}, policies), {\n        caching: LoaderCachingPolicy.NoCaching\n      });\n    }\n  }\n\n  getSnapshotTree(version) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const p = _this.internalStorageService.getSnapshotTree(version);\n\n      if (_this.prefetchEnabled) {\n        // We don't care if the prefetch succeeds\n        void p.then(tree => {\n          if (tree === null || tree === undefined) {\n            return;\n          }\n\n          _this.prefetchTree(tree);\n        });\n      }\n\n      return p;\n    })();\n  }\n\n  readBlob(blobId) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2.cachedRead(blobId);\n    })();\n  }\n\n  stopPrefetch() {\n    this.prefetchEnabled = false;\n    this.prefetchCache.clear();\n  }\n\n  cachedRead(blobId) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this3.prefetchEnabled) {\n        const prefetchedBlobP = _this3.prefetchCache.get(blobId);\n\n        if (prefetchedBlobP !== undefined) {\n          return prefetchedBlobP;\n        }\n\n        const prefetchedBlobPFromStorage = _this3.internalStorageService.readBlob(blobId);\n\n        _this3.prefetchCache.set(blobId, prefetchedBlobPFromStorage.catch(error => {\n          if (canRetryOnError(error)) {\n            _this3.prefetchCache.delete(blobId);\n          }\n\n          throw error;\n        }));\n\n        return prefetchedBlobPFromStorage;\n      }\n\n      return _this3.internalStorageService.readBlob(blobId);\n    })();\n  }\n\n  prefetchTree(tree) {\n    const secondary = [];\n    this.prefetchTreeCore(tree, secondary);\n\n    for (const blob of secondary) {\n      // We don't care if the prefetch succeeds\n      void this.cachedRead(blob);\n    }\n  }\n\n  prefetchTreeCore(tree, secondary) {\n    for (const blobKey of Object.keys(tree.blobs)) {\n      const blob = tree.blobs[blobKey];\n\n      if (blobKey.startsWith(\".\") || blobKey === \"header\" || blobKey.startsWith(\"quorum\")) {\n        if (blob !== null) {\n          // We don't care if the prefetch succeeds\n          void this.cachedRead(blob);\n        }\n      } else if (!blobKey.startsWith(\"deltas\")) {\n        if (blob !== null) {\n          secondary.push(blob);\n        }\n      }\n    }\n\n    for (const subTree of Object.keys(tree.trees)) {\n      this.prefetchTreeCore(tree.trees[subTree], secondary);\n    }\n  }\n\n} //# sourceMappingURL=prefetchDocumentStorageService.js.map","map":null,"metadata":{},"sourceType":"module"}