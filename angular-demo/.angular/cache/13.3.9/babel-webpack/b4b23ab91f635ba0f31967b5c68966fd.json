{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar _a;\n\nimport { bufferToString } from \"@fluidframework/common-utils\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { createSingleBlobSummary, SharedObject } from \"@fluidframework/shared-object-base\";\nimport { IntervalCollectionValueType } from \"./intervalCollection\";\nimport { DefaultMap } from \"./defaultMap\";\nimport { pkgVersion } from \"./packageVersion\";\nconst snapshotFileName = \"header\";\n/**\n * The factory that defines the SharedIntervalCollection\n * @deprecated - SharedIntervalCollection is not maintained and is planned to be removed.\n */\n\nexport class SharedIntervalCollectionFactory {\n  get type() {\n    return SharedIntervalCollectionFactory.Type;\n  }\n\n  get attributes() {\n    return SharedIntervalCollectionFactory.Attributes;\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n   */\n\n\n  load(runtime, id, services, attributes) {\n    return _asyncToGenerator(function* () {\n      const map = new SharedIntervalCollection(id, runtime, attributes);\n      yield map.load(services);\n      return map;\n    })();\n  }\n\n  create(runtime, id) {\n    const map = new SharedIntervalCollection(id, runtime, this.attributes);\n    map.initializeLocal();\n    return map;\n  }\n\n}\nSharedIntervalCollectionFactory.Type = \"https://graph.microsoft.com/types/sharedIntervalCollection\";\nSharedIntervalCollectionFactory.Attributes = {\n  type: SharedIntervalCollectionFactory.Type,\n  snapshotFormatVersion: \"0.1\",\n  packageVersion: pkgVersion\n};\n/**\n * @deprecated - SharedIntervalCollection is not maintained and is planned to be removed.\n */\n\nexport class SharedIntervalCollection extends SharedObject {\n  /**\n   * Constructs a new shared SharedIntervalCollection. If the object is non-local an id and service interfaces will\n   * be provided\n   */\n  constructor(id, runtime, attributes) {\n    super(id, runtime, attributes, \"fluid_sharedIntervalCollection_\");\n    this[_a] = \"SharedIntervalCollection\";\n    this.intervalCollections = new DefaultMap(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), new IntervalCollectionValueType());\n  }\n  /**\n   * Create a SharedIntervalCollection\n   *\n   * @param runtime - data store runtime the new shared map belongs to\n   * @param id - optional name of the shared map\n   * @returns newly create shared map (but not attached yet)\n   */\n\n\n  static create(runtime, id) {\n    return runtime.createChannel(id, SharedIntervalCollectionFactory.Type);\n  }\n  /**\n   * Get a factory for SharedIntervalCollection to register with the data store.\n   *\n   * @returns a factory that creates and load SharedIntervalCollection\n   */\n\n\n  static getFactory() {\n    return new SharedIntervalCollectionFactory();\n  }\n  /**\n   * @deprecated - IntervalCollections are created on a first-write wins basis, and concurrent creates\n   * are supported. Use `getIntervalCollection` instead.\n   */\n\n\n  waitIntervalCollection(label) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this.intervalCollections.get(_this.getIntervalCollectionPath(label));\n    })();\n  }\n\n  getIntervalCollection(label) {\n    const realLabel = this.getIntervalCollectionPath(label);\n    const sharedCollection = this.intervalCollections.get(realLabel);\n    return sharedCollection;\n  }\n\n  summarizeCore(serializer) {\n    return createSingleBlobSummary(snapshotFileName, this.intervalCollections.serialize(serializer));\n  }\n\n  reSubmitCore(content, localOpMetadata) {\n    this.intervalCollections.tryResubmitMessage(content, localOpMetadata);\n  }\n\n  onDisconnect() {}\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n   */\n\n\n  loadCore(storage) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const blob = yield storage.readBlob(snapshotFileName);\n      const header = bufferToString(blob, \"utf8\");\n\n      _this2.intervalCollections.populate(header);\n    })();\n  }\n\n  processCore(message, local, localOpMetadata) {\n    if (message.type === MessageType.Operation) {\n      this.intervalCollections.tryProcessMessage(message.contents, local, message, localOpMetadata);\n    }\n  }\n  /**\n   * Creates the full path of the intervalCollection label\n   * @param label - the incoming label\n   */\n\n\n  getIntervalCollectionPath(label) {\n    return label;\n  }\n\n  applyStashedOp() {\n    throw new Error(\"not implemented\");\n  }\n\n}\n_a = Symbol.toStringTag; //# sourceMappingURL=sharedIntervalCollection.js.map","map":null,"metadata":{},"sourceType":"module"}