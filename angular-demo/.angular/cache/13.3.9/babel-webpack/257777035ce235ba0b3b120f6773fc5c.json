{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, stringToBuffer } from \"@fluidframework/common-utils\";\nimport { FileMode, TreeEntry } from \"@fluidframework/protocol-definitions\";\nimport { buildHierarchy } from \"@fluidframework/protocol-base\";\nimport { v4 as uuid } from \"uuid\";\n\nfunction flattenCore(path, treeEntries, blobMap) {\n  const entries = [];\n\n  for (const treeEntry of treeEntries) {\n    const subPath = `${path}${treeEntry.path}`;\n\n    if (treeEntry.type === TreeEntry.Blob) {\n      const blob = treeEntry.value;\n      const buffer = stringToBuffer(blob.contents, blob.encoding);\n      const id = uuid();\n      blobMap.set(id, buffer);\n      const entry = {\n        mode: FileMode[treeEntry.mode],\n        path: subPath,\n        sha: id,\n        size: 0,\n        type: \"blob\",\n        url: \"\"\n      };\n      entries.push(entry);\n    } else if (treeEntry.type === TreeEntry.Tree) {\n      assert(treeEntry.type === TreeEntry.Tree, 0x101\n      /* \"Unexpected tree entry type on flatten!\" */\n      );\n      const t = treeEntry.value;\n      const entry = {\n        mode: FileMode[treeEntry.mode],\n        path: subPath,\n        sha: \"\",\n        size: -1,\n        type: \"tree\",\n        url: \"\"\n      };\n      entries.push(entry);\n      const subTreeEntries = flattenCore(`${subPath}/`, t.entries, blobMap);\n      entries.push(...subTreeEntries);\n    }\n  }\n\n  return entries;\n}\n/**\n * Create a flatten view of an array of ITreeEntry\n *\n * @param tree - an array of ITreeEntry to flatten\n * @param blobMap - a map of blob's sha1 to content\n * @returns A flatten with of the ITreeEntry\n */\n\n\nfunction flatten(tree, blobMap) {\n  const entries = flattenCore(\"\", tree, blobMap);\n  return {\n    sha: \"\",\n    tree: entries,\n    url: \"\"\n  };\n}\n/**\n * Build a tree hierarchy base on an array of ITreeEntry\n *\n * @param entries - an array of ITreeEntry to flatten\n * @param blobMap - a map of blob's sha1 to content that gets filled with content from entries\n * NOTE: blobMap's validity is contingent on the returned promise's resolution\n * @returns the hierarchical tree\n */\n\n\nexport function buildSnapshotTree(entries, blobMap) {\n  const flattened = flatten(entries, blobMap);\n  return buildHierarchy(flattened);\n} //# sourceMappingURL=buildSnapshotTree.js.map","map":null,"metadata":{},"sourceType":"module"}