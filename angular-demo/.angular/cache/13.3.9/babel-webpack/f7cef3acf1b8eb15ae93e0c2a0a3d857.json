{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { create404Response, createResponseError } from \"@fluidframework/runtime-utils\"; // TODO: should this just be \"s\"?\n\nexport const serviceRoutePathRoot = \"_services\";\n/**\n * This class is a simple starter class for building a Container Service. It simply provides routing\n */\n\nexport class BaseContainerService {\n  constructor(runtime) {\n    this.runtime = runtime;\n  }\n\n  get IFluidRouter() {\n    return this;\n  }\n\n  request(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return {\n        status: 200,\n        mimeType: \"fluid/object\",\n        value: _this\n      };\n    })();\n  }\n\n}\n/**\n * ContainerService Factory that will only create one instance of the service for the Container.\n */\n\nclass SingletonContainerServiceFactory {\n  constructor(serviceFn) {\n    this.serviceFn = serviceFn;\n  }\n\n  getService(runtime) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this2.service) {\n        _this2.service = _this2.serviceFn(runtime);\n      }\n\n      return _this2.service;\n    })();\n  }\n\n}\n/**\n * Given a collection of IContainerServices will produce a RequestHandler for them all\n * @param serviceRegistry - Collection of Container Services\n */\n\n\nexport const generateContainerServicesRequestHandler = serviceRegistry => {\n  const factories = new Map();\n  new Map(serviceRegistry).forEach((fn, id) => {\n    factories.set(id, new SingletonContainerServiceFactory(fn));\n  });\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (request, runtime) {\n      if (request.pathParts[0] !== serviceRoutePathRoot) {\n        // If the request is not for a service we return undefined so the next handler can use it\n        return undefined;\n      }\n\n      if (request.pathParts.length < 2) {\n        // If there is not service to route to then return a failure\n        return createResponseError(400, \"request did not specify a service to route to\", request);\n      }\n\n      const factory = factories.get(request.pathParts[1]);\n\n      if (!factory) {\n        // If we can't find a registry entry then return\n        return create404Response(request);\n      }\n\n      const service = yield factory.getService(runtime);\n      const router = service.IFluidRouter;\n      const subRequest = request.createSubRequest(2);\n\n      if (router) {\n        return router.request(subRequest);\n      }\n\n      if (!request.isLeaf(2)) {\n        // If there is not terminating route but a sub-route was requested then we will fail.\n        return createResponseError(400, \"request sub-url for service that doesn't support routing\", request);\n      } // Otherwise we will just return the service\n\n\n      return {\n        status: 200,\n        mimeType: \"fluid/object\",\n        value: service\n      };\n    });\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}; //# sourceMappingURL=containerServices.js.map","map":null,"metadata":{},"sourceType":"module"}