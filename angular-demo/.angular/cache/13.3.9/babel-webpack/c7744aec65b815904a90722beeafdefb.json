{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Handles garbage collection of expiring cache entries.\n * Not exported.\n */\nclass GarbageCollector {\n  constructor(expiry, cleanup) {\n    this.expiry = expiry;\n    this.cleanup = cleanup;\n    this.gcTimeouts = new Map();\n  }\n  /**\n   * Schedule GC for the given key, as applicable\n   */\n\n\n  schedule(key) {\n    if (this.expiry.policy !== \"indefinite\") {\n      this.gcTimeouts.set(key, setTimeout(() => {\n        this.cleanup(key);\n        this.cancel(key);\n      }, this.expiry.durationMs));\n    }\n  }\n  /**\n   * Cancel any pending GC for the given key\n   */\n\n\n  cancel(key) {\n    const timeout = this.gcTimeouts.get(key);\n\n    if (timeout !== undefined) {\n      clearTimeout(timeout);\n      this.gcTimeouts.delete(key);\n    }\n  }\n  /**\n   * Update any pending GC for the given key, as applicable\n   */\n\n\n  update(key) {\n    // Cancel/reschedule new GC if the policy is sliding\n    if (this.expiry.policy === \"sliding\") {\n      this.cancel(key);\n      this.schedule(key);\n    }\n  }\n\n}\n/**\n* A specialized cache for async work, allowing you to safely cache the promised result of some async work\n* without fear of running it multiple times or losing track of errors.\n*/\n\n\nexport class PromiseCache {\n  /**\n   * Create the PromiseCache with the given options, with the following defaults:\n   *\n   * expiry: indefinite, removeOnError: true for all errors\n   */\n  constructor({\n    expiry = {\n      policy: \"indefinite\"\n    },\n    removeOnError = () => true\n  } = {}) {\n    this.cache = new Map();\n    this.removeOnError = removeOnError;\n    this.gc = new GarbageCollector(expiry, key => this.remove(key));\n  }\n  /**\n   * Check if there's anything cached at the given key\n   */\n\n\n  has(key) {\n    return this.cache.has(key);\n  }\n  /**\n   * Get the Promise for the given key, or undefined if it's not found.\n   * Extend expiry if applicable.\n   */\n\n\n  get(key) {\n    if (this.has(key)) {\n      this.gc.update(key);\n    }\n\n    return this.cache.get(key);\n  }\n  /**\n   * Remove the Promise for the given key, returning true if it was found and removed\n   */\n\n\n  remove(key) {\n    this.gc.cancel(key);\n    return this.cache.delete(key);\n  }\n  /**\n   * Try to add the result of the given asyncFn, without overwriting an existing cache entry at that key.\n   * Returns a Promise for the added or existing async work being done at that key.\n   * @param key - key name where to store the async work\n   * @param asyncFn - the async work to do and store, if not already in progress under the given key\n   */\n\n\n  addOrGet(key, asyncFn) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // NOTE: Do not await the Promise returned by asyncFn!\n      // Let the caller do so once we return or after a subsequent call to get\n      let promise = _this.get(key);\n\n      if (promise === undefined) {\n        // Wrap in an async lambda in case asyncFn disabled @typescript-eslint/promise-function-async\n        const safeAsyncFn = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* () {\n            return asyncFn();\n          });\n\n          return function safeAsyncFn() {\n            return _ref.apply(this, arguments);\n          };\n        }(); // Start the async work and put the Promise in the cache\n\n\n        promise = safeAsyncFn();\n\n        _this.cache.set(key, promise); // If asyncFn throws, we may remove the Promise from the cache\n\n\n        promise.catch(error => {\n          if (_this.removeOnError(error)) {\n            _this.remove(key);\n          }\n        });\n\n        _this.gc.schedule(key);\n      }\n\n      return promise;\n    })();\n  }\n  /**\n   * Try to add the result of the given asyncFn, without overwriting an existing cache entry at that key.\n   * Returns false if the cache already contained an entry at that key, and true otherwise.\n   * @param key - key name where to store the async work\n   * @param asyncFn - the async work to do and store, if not already in progress under the given key\n   */\n\n\n  add(key, asyncFn) {\n    const alreadyPresent = this.has(key); // We are blindly adding the Promise to the cache here, which introduces a Promise in this scope.\n    // Swallow Promise rejections here, since whoever gets this out of the cache to use it will await/catch.\n\n    this.addOrGet(key, asyncFn).catch(() => {});\n    return !alreadyPresent;\n  }\n  /**\n   * Try to add the given value, without overwriting an existing cache entry at that key.\n   * Returns a Promise for the added or existing async work being done at that key.\n   * @param key - key name where to store the async work\n   * @param value - value to store\n   */\n\n\n  addValueOrGet(key, value) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2.addOrGet(key, /*#__PURE__*/_asyncToGenerator(function* () {\n        return value;\n      }));\n    })();\n  }\n  /**\n   * Try to add the given value, without overwriting an existing cache entry at that key.\n   * Returns false if the cache already contained an entry at that key, and true otherwise.\n   * @param key - key name where to store the value\n   * @param value - value to store\n   */\n\n\n  addValue(key, value) {\n    return this.add(key, /*#__PURE__*/_asyncToGenerator(function* () {\n      return value;\n    }));\n  }\n\n} //# sourceMappingURL=promiseCache.js.map","map":null,"metadata":{},"sourceType":"module"}