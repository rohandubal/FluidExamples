{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Stores a unique and sorted set of segments, or objects with segments\n *\n * This differs from a normal sorted set in that the keys are not fixed.\n * The segments are sorted via their ordinals which can change as the merge tree is modified.\n * Even though the values of the ordinals can change their ordering and uniqueness cannot, so the order of a set of\n * segments ordered by their ordinals will always have the same order even if the ordinal values on\n * the segments changes. This invariant allows ensure the segments stay ordered and unique, and that new segments\n * can be inserted into that order.\n */\nexport class SortedSegmentSet {\n  constructor() {\n    this.ordinalSortedItems = [];\n  }\n\n  get size() {\n    return this.ordinalSortedItems.length;\n  }\n\n  get items() {\n    return this.ordinalSortedItems;\n  }\n\n  addOrUpdate(newItem, update) {\n    const position = this.findOrdinalPosition(this.getOrdinal(newItem));\n\n    if (position.exists) {\n      if (update) {\n        update(this.ordinalSortedItems[position.index], newItem);\n      }\n    } else {\n      this.ordinalSortedItems.splice(position.index, 0, newItem);\n    }\n  }\n\n  remove(item) {\n    const position = this.findOrdinalPosition(this.getOrdinal(item));\n\n    if (position.exists) {\n      this.ordinalSortedItems.splice(position.index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  has(item) {\n    const position = this.findOrdinalPosition(this.getOrdinal(item));\n    return position.exists;\n  }\n\n  getOrdinal(item) {\n    const maybeObject = item;\n\n    if (maybeObject === null || maybeObject === void 0 ? void 0 : maybeObject.segment) {\n      return maybeObject.segment.ordinal;\n    }\n\n    const maybeSegment = item;\n    return maybeSegment.ordinal;\n  }\n\n  findOrdinalPosition(ordinal, start, end) {\n    if (this.ordinalSortedItems.length === 0) {\n      return {\n        exists: false,\n        index: 0\n      };\n    }\n\n    if (start === undefined || end === undefined) {\n      return this.findOrdinalPosition(ordinal, 0, this.ordinalSortedItems.length - 1);\n    }\n\n    const index = start + Math.floor((end - start) / 2);\n\n    if (this.getOrdinal(this.ordinalSortedItems[index]) > ordinal) {\n      if (start === index) {\n        return {\n          exists: false,\n          index\n        };\n      }\n\n      return this.findOrdinalPosition(ordinal, start, index - 1);\n    } else if (this.getOrdinal(this.ordinalSortedItems[index]) < ordinal) {\n      if (index === end) {\n        return {\n          exists: false,\n          index: index + 1\n        };\n      }\n\n      return this.findOrdinalPosition(ordinal, index + 1, end);\n    }\n\n    return {\n      exists: true,\n      index\n    };\n  }\n\n} //# sourceMappingURL=sortedSegmentSet.js.map","map":null,"metadata":{},"sourceType":"module"}