{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { Loader } from \"@fluidframework/container-loader\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { RouterliciousDocumentServiceFactory } from \"@fluidframework/routerlicious-driver\";\nimport { createTinyliciousCreateNewRequest, InsecureTinyliciousTokenProvider, InsecureTinyliciousUrlResolver } from \"@fluidframework/tinylicious-driver\";\nimport { requestFluidObject } from \"@fluidframework/runtime-utils\";\nimport { ensureFluidResolvedUrl } from \"@fluidframework/driver-utils\";\nimport { DOProviderContainerRuntimeFactory, FluidContainer } from \"@fluidframework/fluid-static\";\nimport { TinyliciousAudience } from \"./TinyliciousAudience\";\n/**\n * Provides the ability to have a Fluid object backed by a Tinylicious service.\n *\n * See {@link https://fluidframework.com/docs/testing/tinylicious/}\n */\n\nexport class TinyliciousClient {\n  /**\n   * Creates a new client instance using configuration parameters.\n   * @param props - Optional. Properties for initializing a new TinyliciousClient instance\n   */\n  constructor(props) {\n    var _a, _b, _c, _d;\n\n    this.props = props;\n    const tokenProvider = new InsecureTinyliciousTokenProvider();\n    this.urlResolver = new InsecureTinyliciousUrlResolver((_b = (_a = this.props) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.port, (_d = (_c = this.props) === null || _c === void 0 ? void 0 : _c.connection) === null || _d === void 0 ? void 0 : _d.domain);\n    this.documentServiceFactory = new RouterliciousDocumentServiceFactory(tokenProvider);\n  }\n  /**\n   * Creates a new detached container instance in Tinylicious server.\n   * @param containerSchema - Container schema for the new container.\n   * @returns New detached container instance along with associated services.\n   */\n\n\n  createContainer(containerSchema) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const loader = _this.createLoader(containerSchema); // We're not actually using the code proposal (our code loader always loads the same module\n      // regardless of the proposal), but the Container will only give us a NullRuntime if there's\n      // no proposal.  So we'll use a fake proposal.\n\n\n      const container = yield loader.createDetachedContainer({\n        package: \"no-dynamic-package\",\n        config: {}\n      });\n      const rootDataObject = yield requestFluidObject(container, \"/\");\n      const fluidContainer = new class extends FluidContainer {\n        attach() {\n          var _this2 = this;\n\n          return _asyncToGenerator(function* () {\n            if (_this2.attachState !== AttachState.Detached) {\n              throw new Error(\"Cannot attach container. Container is not in detached state\");\n            }\n\n            const request = createTinyliciousCreateNewRequest();\n            yield container.attach(request);\n            const resolved = container.resolvedUrl;\n            ensureFluidResolvedUrl(resolved);\n            return resolved.id;\n          })();\n        }\n\n      }(container, rootDataObject);\n\n      const services = _this.getContainerServices(container);\n\n      return {\n        container: fluidContainer,\n        services\n      };\n    })();\n  }\n  /**\n   * Accesses the existing container given its unique ID in the tinylicious server.\n   * @param id - Unique ID of the container.\n   * @param containerSchema - Container schema used to access data objects in the container.\n   * @returns Existing container instance along with associated services.\n   */\n\n\n  getContainer(id, containerSchema) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const loader = _this3.createLoader(containerSchema);\n\n      const container = yield loader.resolve({\n        url: id\n      });\n      const rootDataObject = yield requestFluidObject(container, \"/\");\n      const fluidContainer = new FluidContainer(container, rootDataObject);\n\n      const services = _this3.getContainerServices(container);\n\n      return {\n        container: fluidContainer,\n        services\n      };\n    })();\n  } // #region private\n\n\n  getContainerServices(container) {\n    return {\n      audience: new TinyliciousAudience(container)\n    };\n  }\n\n  createLoader(containerSchema) {\n    var _a;\n\n    const containerRuntimeFactory = new DOProviderContainerRuntimeFactory(containerSchema);\n\n    const load = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* () {\n        return {\n          module: {\n            fluidExport: containerRuntimeFactory\n          },\n          details: {\n            package: \"no-dynamic-package\",\n            config: {}\n          }\n        };\n      });\n\n      return function load() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    const codeLoader = {\n      load\n    };\n    const loader = new Loader({\n      urlResolver: this.urlResolver,\n      documentServiceFactory: this.documentServiceFactory,\n      codeLoader,\n      logger: (_a = this.props) === null || _a === void 0 ? void 0 : _a.logger\n    });\n    return loader;\n  }\n\n} //# sourceMappingURL=TinyliciousClient.js.map","map":null,"metadata":{},"sourceType":"module"}