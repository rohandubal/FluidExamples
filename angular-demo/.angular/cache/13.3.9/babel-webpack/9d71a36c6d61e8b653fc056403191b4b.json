{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { UsageError } from \"@fluidframework/container-utils\";\nimport { ListMakeHead, ListRemoveEntry } from \"./collections\";\nimport { ReferenceType } from \"./ops\";\nimport { addProperties } from \"./properties\";\nimport { minReferencePosition, maxReferencePosition, compareReferencePositions, refHasTileLabels, refHasRangeLabels, refGetRangeLabels, refGetTileLabels, refHasRangeLabel, refHasTileLabel, refTypeIncludesFlag } from \"./referencePositions\";\n/**\n * @internal\n */\n\nexport function _validateReferenceType(refType) {\n  let exclusiveCount = 0;\n\n  if (refTypeIncludesFlag(refType, ReferenceType.Transient)) {\n    ++exclusiveCount;\n  }\n\n  if (refTypeIncludesFlag(refType, ReferenceType.SlideOnRemove)) {\n    ++exclusiveCount;\n  }\n\n  if (refTypeIncludesFlag(refType, ReferenceType.StayOnRemove)) {\n    ++exclusiveCount;\n  }\n\n  if (exclusiveCount > 1) {\n    throw new UsageError(\"Reference types can only be one of Transient, SlideOnRemove, and StayOnRemove\");\n  }\n}\n/**\n * @deprecated - Use LocalReferencePosition\n */\n\nexport let LocalReference = /*#__PURE__*/(() => {\n  class LocalReference {\n    /**\n     * @deprecated - use createReferencePosition\n     */\n    constructor(client, initSegment,\n    /**\n     * @deprecated - use getOffset\n     */\n    offset = 0, refType = ReferenceType.Simple, properties) {\n      this.client = client;\n      this.offset = offset;\n      this.refType = refType;\n\n      _validateReferenceType(refType);\n\n      this.segment = initSegment;\n      this.properties = properties;\n    }\n    /**\n     * @deprecated - use minReferencePosition\n     */\n\n\n    min(b) {\n      return minReferencePosition(this, b);\n    }\n    /**\n     * @deprecated - use maxReferencePosition\n     */\n\n\n    max(b) {\n      return maxReferencePosition(this, b);\n    }\n    /**\n     * @deprecated - use compareReferencePositions\n     */\n\n\n    compare(b) {\n      return compareReferencePositions(this, b);\n    }\n    /**\n     * @deprecated - use getLocalReferencePosition\n     */\n\n\n    toPosition() {\n      return this.getClient().localReferencePositionToPosition(this);\n    }\n    /**\n     * @deprecated - use refHasTileLabels\n     */\n\n\n    hasTileLabels() {\n      return refHasTileLabels(this);\n    }\n    /**\n     * @deprecated - use refHasRangeLabels\n     */\n\n\n    hasRangeLabels() {\n      return refHasRangeLabels(this);\n    }\n    /**\n     * @deprecated - use refHasTileLabel\n     */\n\n\n    hasTileLabel(label) {\n      return refHasTileLabel(this, label);\n    }\n    /**\n     * @deprecated - use refHasRangeLabel\n     */\n\n\n    hasRangeLabel(label) {\n      return refHasRangeLabel(this, label);\n    }\n    /**\n     * @deprecated - use refGetTileLabels\n     */\n\n\n    getTileLabels() {\n      return refGetTileLabels(this);\n    }\n    /**\n     * @deprecated - use refGetRangeLabels\n     */\n\n\n    getRangeLabels() {\n      return refGetRangeLabels(this);\n    }\n\n    isLeaf() {\n      return false;\n    }\n\n    addProperties(newProps, op) {\n      this.properties = addProperties(this.properties, newProps, op);\n    }\n    /**\n     * @deprecated - no longer supported\n     */\n\n\n    getClient() {\n      return this.client;\n    }\n\n    getSegment() {\n      return this.segment;\n    }\n\n    getOffset() {\n      return this.offset;\n    }\n\n    getProperties() {\n      return this.properties;\n    }\n\n  }\n\n  /**\n   * @deprecated - use DetachedReferencePosition\n   */\n  LocalReference.DetachedPosition = -1;\n  return LocalReference;\n})();\n\nfunction assertLocalReferences(lref) {\n  assert(lref instanceof LocalReference, 0x2e0\n  /* \"lref not a Local Reference\" */\n  );\n}\n/**\n * Represents a collection of {@link ReferencePosition}s associated with one segment in a merge-tree.\n */\n\n\nexport class LocalReferenceCollection {\n  /**\n   *\n   * @internal - this method should only be called by mergeTree\n   */\n  constructor(\n  /** Segment this `LocalReferenceCollection` is associated to. */\n  segment, initialRefsByfOffset = new Array(segment.cachedLength)) {\n    this.segment = segment;\n    /**\n     *\n     * @internal - this method should only be called by mergeTree\n     */\n\n    this.hierRefCount = 0;\n    this.refCount = 0; // Since javascript arrays are sparse the above won't populate any of the\n    // indices, but it will ensure the length property of the array matches\n    // the length of the segment.\n\n    this.refsByOffset = initialRefsByfOffset;\n  }\n\n  static append(seg1, seg2) {\n    if (seg2.localRefs && !seg2.localRefs.empty) {\n      if (!seg1.localRefs) {\n        seg1.localRefs = new LocalReferenceCollection(seg1);\n      }\n\n      assert(seg1.localRefs.refsByOffset.length === seg1.cachedLength, 0x2be\n      /* \"LocalReferences array contains a gap\" */\n      );\n      seg1.localRefs.append(seg2.localRefs);\n    } else if (seg1.localRefs) {\n      // Since creating the LocalReferenceCollection, we may have appended\n      // segments that had no local references. Account for them now by padding the array.\n      seg1.localRefs.refsByOffset.length += seg2.cachedLength;\n    }\n  }\n  /**\n   *\n   * @internal - this method should only be called by mergeTree\n   */\n\n\n  [Symbol.iterator]() {\n    const subiterators = [];\n\n    for (const refs of this.refsByOffset) {\n      if (refs) {\n        if (refs.before) {\n          subiterators.push(refs.before[Symbol.iterator]());\n        }\n\n        if (refs.at) {\n          subiterators.push(refs.at[Symbol.iterator]());\n        }\n\n        if (refs.after) {\n          subiterators.push(refs.after[Symbol.iterator]());\n        }\n      }\n    }\n\n    const iterator = {\n      next() {\n        while (subiterators.length > 0) {\n          const next = subiterators[0].next();\n\n          if (next.done === true) {\n            subiterators.shift();\n          } else {\n            return next;\n          }\n        }\n\n        return {\n          value: undefined,\n          done: true\n        };\n      },\n\n      [Symbol.iterator]() {\n        return this;\n      }\n\n    };\n    return iterator;\n  }\n  /**\n   *\n   * @internal - this method should only be called by mergeTree\n   */\n\n\n  clear() {\n    this.refCount = 0;\n    this.hierRefCount = 0;\n\n    const detachSegments = refs => {\n      if (refs) {\n        for (const r of refs) {\n          if (r.segment === this.segment) {\n            r.segment = undefined;\n          }\n        }\n      }\n    };\n\n    for (let i = 0; i < this.refsByOffset.length; i++) {\n      const refsAtOffset = this.refsByOffset[i];\n\n      if (refsAtOffset) {\n        detachSegments(refsAtOffset.before);\n        detachSegments(refsAtOffset.at);\n        detachSegments(refsAtOffset.before);\n        this.refsByOffset[i] = undefined;\n      }\n    }\n  }\n  /**\n   *\n   * @internal - this method should only be called by mergeTree\n   */\n\n\n  get empty() {\n    return this.refCount === 0;\n  }\n  /**\n   *\n   * @internal - this method should only be called by mergeTree\n   */\n\n\n  createLocalRef(offset, refType, properties, client) {\n    const ref = new LocalReference(client, this.segment, offset, refType, properties);\n\n    if (!refTypeIncludesFlag(ref, ReferenceType.Transient)) {\n      this.addLocalRef(ref);\n    }\n\n    return ref;\n  }\n  /**\n   *\n   * @internal - this method should only be called by mergeTree\n   */\n\n\n  addLocalRef(lref) {\n    var _a, _b;\n\n    assert(!refTypeIncludesFlag(lref, ReferenceType.Transient), 0x2df\n    /* \"transient references cannot be bound to segments\" */\n    );\n    assertLocalReferences(lref);\n    const refsAtOffset = this.refsByOffset[lref.offset] = (_a = this.refsByOffset[lref.offset]) !== null && _a !== void 0 ? _a : {\n      at: ListMakeHead()\n    };\n    const atRefs = refsAtOffset.at = (_b = refsAtOffset.at) !== null && _b !== void 0 ? _b : ListMakeHead();\n    atRefs.enqueue(lref);\n\n    if (refHasRangeLabels(lref) || refHasTileLabels(lref)) {\n      this.hierRefCount++;\n    }\n\n    this.refCount++;\n  }\n  /**\n   *\n   * @internal - this method should only be called by mergeTree\n   */\n\n\n  removeLocalRef(lref) {\n    assertLocalReferences(lref);\n\n    const tryRemoveRef = refs => {\n      if (refs) {\n        let node = refs;\n\n        do {\n          node = node.next;\n\n          if (node.data === lref) {\n            ListRemoveEntry(node);\n\n            if (refHasRangeLabels(lref) || refHasTileLabels(lref)) {\n              this.hierRefCount--;\n            }\n\n            this.refCount--;\n            return lref;\n          }\n        } while (!node.isHead);\n      }\n    };\n\n    const refAtOffset = this.refsByOffset[lref.offset];\n\n    if (refAtOffset !== undefined) {\n      let ref = tryRemoveRef(refAtOffset.before);\n\n      if (ref) {\n        return ref;\n      }\n\n      ref = tryRemoveRef(refAtOffset.at);\n\n      if (ref) {\n        return ref;\n      }\n\n      ref = tryRemoveRef(refAtOffset.after);\n\n      if (ref) {\n        return ref;\n      }\n    }\n  }\n  /**\n   * @internal - this method should only be called by mergeTree\n   *\n   * Called by 'append()' implementations to append local refs from the given 'other' segment to the\n   * end of 'this' segment.\n   *\n   * Note: This method should be invoked after the caller has ensured that segments can be merged,\n   *       but before 'this' segment's cachedLength has changed, or the adjustment to the local refs\n   *       will be incorrect.\n   */\n\n\n  append(other) {\n    if (!other || other.empty) {\n      return;\n    }\n\n    this.hierRefCount += other.hierRefCount;\n    this.refCount += other.refCount;\n    other.hierRefCount = 0;\n\n    for (const lref of other) {\n      lref.segment = this.segment;\n      lref.offset += this.refsByOffset.length;\n    }\n\n    this.refsByOffset.push(...other.refsByOffset);\n  }\n  /**\n   * @internal - this method should only be called by mergeTree\n   *\n   * Splits this `LocalReferenceCollection` into the intervals [0, offset) and [offset, originalLength).\n   * Local references in the former half of this split will remain associated with the segment used on construction.\n   * Local references in the latter half of this split will be transferred to `splitSeg`,\n   * and its `localRefs` field will be set.\n   * @param offset - Offset into the original segment at which the collection should be split\n   * @param splitSeg - Split segment which originally corresponded to the indices [offset, originalLength)\n   * before splitting.\n   */\n\n\n  split(offset, splitSeg) {\n    if (!this.empty) {\n      const localRefs = new LocalReferenceCollection(splitSeg, this.refsByOffset.splice(offset, this.refsByOffset.length - offset));\n      splitSeg.localRefs = localRefs;\n\n      for (const lref of localRefs) {\n        lref.segment = splitSeg;\n        lref.offset -= offset;\n\n        if (refHasRangeLabels(lref) || refHasTileLabels(lref)) {\n          this.hierRefCount--;\n          localRefs.hierRefCount++;\n        }\n\n        this.refCount--;\n        localRefs.refCount++;\n      }\n    } else {\n      // shrink the offset array when empty and splitting\n      this.refsByOffset.length = offset;\n    }\n  }\n\n  addBeforeTombstones(...refs) {\n    var _a, _b, _c, _d, _e;\n\n    const beforeRefs = (_b = (_a = this.refsByOffset[0]) === null || _a === void 0 ? void 0 : _a.before) !== null && _b !== void 0 ? _b : ListMakeHead();\n\n    for (const iterable of refs) {\n      for (const lref of iterable) {\n        assertLocalReferences(lref);\n\n        if (refTypeIncludesFlag(lref, ReferenceType.SlideOnRemove)) {\n          beforeRefs.push(lref);\n          lref.segment = this.segment;\n          lref.offset = 0;\n\n          if (refHasRangeLabels(lref) || refHasTileLabels(lref)) {\n            this.hierRefCount++;\n          }\n\n          this.refCount++;\n        } else {\n          lref.segment = undefined;\n        }\n      }\n    }\n\n    if (!beforeRefs.empty() && ((_c = this.refsByOffset[0]) === null || _c === void 0 ? void 0 : _c.before) === undefined) {\n      const refsAtOffset = this.refsByOffset[0] = (_d = this.refsByOffset[0]) !== null && _d !== void 0 ? _d : {\n        before: beforeRefs\n      };\n      refsAtOffset.before = (_e = refsAtOffset.before) !== null && _e !== void 0 ? _e : beforeRefs;\n    }\n  }\n\n  addAfterTombstones(...refs) {\n    var _a, _b, _c, _d, _e;\n\n    const lastOffset = this.refsByOffset.length - 1;\n    const afterRefs = (_b = (_a = this.refsByOffset[lastOffset]) === null || _a === void 0 ? void 0 : _a.after) !== null && _b !== void 0 ? _b : ListMakeHead();\n\n    for (const iterable of refs) {\n      for (const lref of iterable) {\n        assertLocalReferences(lref);\n\n        if (refTypeIncludesFlag(lref, ReferenceType.SlideOnRemove)) {\n          afterRefs.push(lref);\n          lref.segment = this.segment;\n          lref.offset = this.segment.cachedLength - 1;\n\n          if (refHasRangeLabels(lref) || refHasTileLabels(lref)) {\n            this.hierRefCount++;\n          }\n\n          this.refCount++;\n        } else {\n          lref.segment = undefined;\n        }\n      }\n    }\n\n    if (!afterRefs.empty() && ((_c = this.refsByOffset[lastOffset]) === null || _c === void 0 ? void 0 : _c.after) === undefined) {\n      const refsAtOffset = this.refsByOffset[lastOffset] = (_d = this.refsByOffset[lastOffset]) !== null && _d !== void 0 ? _d : {\n        after: afterRefs\n      };\n      refsAtOffset.after = (_e = refsAtOffset.after) !== null && _e !== void 0 ? _e : afterRefs;\n    }\n  }\n\n} //# sourceMappingURL=localReference.js.map","map":null,"metadata":{},"sourceType":"module"}