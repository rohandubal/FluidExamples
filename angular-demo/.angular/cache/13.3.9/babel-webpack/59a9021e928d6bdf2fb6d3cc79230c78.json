{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { ContainerErrorType } from \"@fluidframework/container-definitions\";\nimport { LoggingError, normalizeError, wrapError, wrapErrorAndLog, isExternalError } from \"@fluidframework/telemetry-utils\";\n/**\n * Generic wrapper for an unrecognized/uncategorized error object\n */\n\nexport class GenericError extends LoggingError {\n  /**\n   * Create a new GenericError\n   * @param message - Error message\n   * @param error - inner error object\n   * @param props - Telemetry props to include when the error is logged\n   */\n  constructor(message, error, props) {\n    // Don't try to log the inner error\n    super(message, props, new Set([\"error\"]));\n    this.error = error;\n    this.errorType = ContainerErrorType.genericError;\n  }\n\n}\n/**\n * Warning emitted when requests to storage are being throttled.\n */\n\nexport class ThrottlingWarning extends LoggingError {\n  constructor(message, retryAfterSeconds, props) {\n    super(message, props);\n    this.retryAfterSeconds = retryAfterSeconds;\n    this.errorType = ContainerErrorType.throttlingError;\n  }\n  /**\n   * Wrap the given error as a ThrottlingWarning\n   * Only preserves the error message, and applies the given retry after to the new warning object\n   */\n\n\n  static wrap(error, retryAfterSeconds, logger) {\n    const newErrorFn = errMsg => new ThrottlingWarning(errMsg, retryAfterSeconds);\n\n    return wrapErrorAndLog(error, newErrorFn, logger);\n  }\n\n}\n/** Error indicating an API is being used improperly resulting in an invalid operation. */\n\nexport class UsageError extends LoggingError {\n  constructor(message) {\n    super(message, {\n      usageError: true\n    }); // TODO: implement IUsageError once available\n\n    this.errorType = \"usageError\";\n  }\n\n}\n/** Error indicating that a client's session has reached its time limit and is closed. */\n\nexport class ClientSessionExpiredError extends LoggingError {\n  constructor(message, expiryMs) {\n    super(message, {\n      timeoutMs: expiryMs\n    });\n    this.expiryMs = expiryMs;\n    this.errorType = ContainerErrorType.clientSessionExpiredError;\n  }\n\n}\n/**\n * DataCorruptionError indicates that we encountered definitive evidence that the data at rest\n * backing this container is corrupted, and this container would never be expected to load properly again\n */\n\nexport class DataCorruptionError extends LoggingError {\n  constructor(message, props) {\n    super(message, Object.assign(Object.assign({}, props), {\n      dataProcessingError: 1\n    }));\n    this.errorType = ContainerErrorType.dataCorruptionError;\n    this.canRetry = false;\n  }\n\n}\n/**\n * DataProcessingError indicates we hit a fatal error while processing incoming data from the Fluid Service.\n * The error will often originate in the dataStore or DDS implementation that is responding to incoming changes.\n * This differs from DataCorruptionError in that this may be a transient error that will not repro in another\n * client or session.\n */\n\nexport class DataProcessingError extends LoggingError {\n  constructor(errorMessage) {\n    super(errorMessage);\n    this.errorType = ContainerErrorType.dataProcessingError;\n    this.canRetry = false;\n  }\n  /** Create a new DataProcessingError detected and raised with the FF code */\n\n\n  static create(errorMessage, dataProcessingCodepath, sequencedMessage, props = {}) {\n    const dataProcessingError = DataProcessingError.wrapIfUnrecognized(errorMessage, dataProcessingCodepath, sequencedMessage);\n    dataProcessingError.addTelemetryProperties(props);\n    return dataProcessingError;\n  }\n  /**\n   * Wrap the given error in a DataProcessingError, unless the error is already of a known type.\n   * In either case, the error will have some relevant properties added for telemetry\n   * We wrap conditionally since known error types represent well-understood failure modes, and ideally\n   * one day we will move away from throwing these errors but rather we'll return them.\n   * But an unrecognized error needs to be classified as DataProcessingError.\n   * @param originalError - error to be converted\n   * @param dataProcessingCodepath - which codepath failed while processing data\n   * @param sequencedMessage - Sequenced message to include info about via telemetry props\n   * @returns Either a new DataProcessingError, or (if wrapping is deemed unnecessary) the given error\n   */\n\n\n  static wrapIfUnrecognized(originalError, dataProcessingCodepath, sequencedMessage) {\n    const props = Object.assign({\n      dataProcessingError: 1,\n      dataProcessingCodepath\n    }, sequencedMessage === undefined ? undefined : extractSafePropertiesFromMessage(sequencedMessage));\n    const normalizedError = normalizeError(originalError, {\n      props\n    });\n\n    if (!isExternalError(normalizedError)) {\n      return normalizedError;\n    } // Create a new DataProcessingError to wrap this external error\n\n\n    const dataProcessingError = wrapError(normalizedError, message => new DataProcessingError(message)); // Copy over the props above and any others added to this error since first being normalized\n\n    dataProcessingError.addTelemetryProperties(normalizedError.getTelemetryProperties());\n    return dataProcessingError;\n  }\n\n}\nexport const extractSafePropertiesFromMessage = message => ({\n  messageClientId: message.clientId,\n  messageSequenceNumber: message.sequenceNumber,\n  messageClientSequenceNumber: message.clientSequenceNumber,\n  messageReferenceSequenceNumber: message.referenceSequenceNumber,\n  messageMinimumSequenceNumber: message.minimumSequenceNumber,\n  messageTimestamp: message.timestamp\n}); //# sourceMappingURL=error.js.map","map":null,"metadata":{},"sourceType":"module"}