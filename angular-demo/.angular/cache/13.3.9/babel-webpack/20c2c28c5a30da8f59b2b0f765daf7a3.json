{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { RuntimeHeaders } from \"@fluidframework/container-runtime\";\nimport { create404Response, exceptionToResponse, responseToException } from \"@fluidframework/runtime-utils\";\n/**\n * This handle is used to dynamically load a Fluid object on a remote client and is created on parsing a serialized\n * FluidObjectHandle.\n * This class is used to generate an IFluidHandle when de-serializing any all handles (including handles to DDSes,\n * custom objects) that are stored in SharedObjects. The Data Store or SharedObject corresponding to the\n * IFluidHandle can be retrieved by calling `get` on it.\n */\n\nexport class RemoteFluidObjectHandle {\n  /**\n   * Creates a new RemoteFluidObjectHandle when parsing an IFluidHandle.\n   * @param absolutePath - The absolute path to the handle from the container runtime.\n   * @param routeContext - The root IFluidHandleContext that has a route to this handle.\n   */\n  constructor(absolutePath, routeContext) {\n    this.absolutePath = absolutePath;\n    this.routeContext = routeContext;\n    this.isAttached = true;\n    assert(absolutePath.startsWith(\"/\"), 0x19d\n    /* \"Handles should always have absolute paths\" */\n    );\n  }\n\n  get IFluidRouter() {\n    return this;\n  }\n\n  get IFluidHandleContext() {\n    return this;\n  }\n\n  get IFluidHandle() {\n    return this;\n  }\n\n  get() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.objectP === undefined) {\n        // Add `viaHandle` header to distinguish from requests from non-handle paths.\n        const request = {\n          url: _this.absolutePath,\n          headers: {\n            [RuntimeHeaders.viaHandle]: true\n          }\n        };\n        _this.objectP = _this.routeContext.resolveHandle(request).then(response => {\n          if (response.mimeType === \"fluid/object\") {\n            const fluidObject = response.value;\n            return fluidObject;\n          }\n\n          throw responseToException(response, request);\n        });\n      }\n\n      return _this.objectP;\n    })();\n  }\n\n  attachGraph() {\n    return;\n  }\n\n  bind(handle) {\n    handle.attachGraph();\n  }\n\n  request(request) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const object = yield _this2.get();\n        const router = object.IFluidRouter;\n        return router !== undefined ? router.request(request) : create404Response(request);\n      } catch (error) {\n        return exceptionToResponse(error);\n      }\n    })();\n  }\n\n} //# sourceMappingURL=remoteObjectHandle.js.map","map":null,"metadata":{},"sourceType":"module"}