{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { generateHandleContextPath, SummaryTreeBuilder } from \"@fluidframework/runtime-utils\";\nimport { assert, Deferred } from \"@fluidframework/common-utils\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { PerformanceEvent } from \"@fluidframework/telemetry-utils\";\n/**\n * This class represents blob (long string)\n * This object is used only when creating (writing) new blob and serialization purposes.\n * De-serialization process goes through FluidObjectHandle and request flow:\n * DataObject.request() recognizes requests in the form of `/blobs/<id>`\n * and loads blob.\n */\n\nexport class BlobHandle {\n  constructor(path, routeContext, get) {\n    this.path = path;\n    this.routeContext = routeContext;\n    this.get = get;\n    this.attached = false;\n    this.absolutePath = generateHandleContextPath(path, this.routeContext);\n  }\n\n  get IFluidHandle() {\n    return this;\n  }\n\n  get isAttached() {\n    return this.attached;\n  }\n\n  attachGraph() {\n    this.attached = true;\n  }\n\n  bind(handle) {\n    throw new Error(\"Cannot bind to blob handle\");\n  }\n\n}\nexport let BlobManager = /*#__PURE__*/(() => {\n  class BlobManager {\n    constructor(routeContext, snapshot, getStorage, attachBlobCallback, // To be called when a blob node is requested. blobPath is the path of the blob's node in GC's graph. It's\n    // of the format `/<BlobManager.basePath>/<blobId>`.\n    gcNodeUpdated, runtime, logger) {\n      this.routeContext = routeContext;\n      this.getStorage = getStorage;\n      this.attachBlobCallback = attachBlobCallback;\n      this.gcNodeUpdated = gcNodeUpdated;\n      this.runtime = runtime;\n      this.logger = logger; // uploaded blob IDs\n\n      this.blobIds = new Set(); // blobs for which upload is pending. maps to a promise that will resolve once the blob has been uploaded and a\n      // BlobAttach op has round-tripped.\n\n      this.pendingBlobIds = new Map(); // blobs uploaded while detached; cleared upon attach\n\n      this.detachedBlobIds = new Set();\n      this.runtime.once(\"dispose\", () => {\n        for (const promise of this.pendingBlobIds.values()) {\n          promise.reject(new Error(\"runtime disposed while blobAttach op in flight\"));\n        }\n      });\n      this.load(snapshot);\n    }\n\n    hasBlob(id) {\n      return this.blobIds.has(id) || this.detachedBlobIds.has(id);\n    }\n    /**\n     * For a blobId, returns its path in GC's graph. The node path is of the format `/<BlobManager.basePath>/<blobId>`\n     * This path must match the path of the blob handle returned by the createBlob API because blobs are marked\n     * referenced by storing these handles in a referenced DDS.\n     */\n\n\n    getBlobGCNodePath(blobId) {\n      return `/${BlobManager.basePath}/${blobId}`;\n    }\n\n    getBlob(blobId) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        var _a, _b;\n\n        const storageId = (_b = (_a = _this.redirectTable) === null || _a === void 0 ? void 0 : _a.get(blobId)) !== null && _b !== void 0 ? _b : blobId;\n        assert(_this.hasBlob(storageId), 0x11f\n        /* \"requesting unknown blobs\" */\n        ); // When this blob is retrieved, let the container runtime know that the corresponding GC node got updated.\n\n        _this.gcNodeUpdated(_this.getBlobGCNodePath(blobId));\n\n        return new BlobHandle(`${BlobManager.basePath}/${storageId}`, _this.routeContext, /*#__PURE__*/_asyncToGenerator(function* () {\n          return PerformanceEvent.timedExecAsync(_this.logger, {\n            eventName: \"AttachmentReadBlob\",\n            id: storageId\n          }, /*#__PURE__*/_asyncToGenerator(function* () {\n            return _this.getStorage().readBlob(storageId);\n          }), {\n            end: true,\n            cancel: \"error\"\n          });\n        }));\n      })();\n    }\n\n    createBlob(blob) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        var _a, _b;\n\n        if (_this2.runtime.attachState === AttachState.Attaching) {\n          // blob upload is not supported in \"Attaching\" state\n          _this2.logger.sendTelemetryEvent({\n            eventName: \"CreateBlobWhileAttaching\"\n          });\n\n          yield new Promise(resolve => _this2.runtime.once(\"attached\", resolve));\n        }\n\n        if (!_this2.runtime.connected && _this2.runtime.attachState === AttachState.Attached) {\n          // see https://github.com/microsoft/FluidFramework/issues/8246\n          // Avoid getting storage if we are offline since it might be undefined. In the future we will return\n          // handles immediately while offline\n          yield new Promise(resolve => _this2.runtime.once(\"connected\", resolve));\n        }\n\n        const response = yield PerformanceEvent.timedExecAsync(_this2.logger, {\n          eventName: \"createBlob\"\n        }, /*#__PURE__*/_asyncToGenerator(function* () {\n          return _this2.getStorage().createBlob(blob);\n        }), {\n          end: true,\n          cancel: \"error\"\n        });\n        const handle = new BlobHandle(`${BlobManager.basePath}/${response.id}`, _this2.routeContext,\n        /*#__PURE__*/\n        // get() should go through BlobManager.getBlob() so handles created while detached can be redirected\n        // to the correct storage id after they are uploaded\n        _asyncToGenerator(function* () {\n          return _this2.getBlob(response.id).then( /*#__PURE__*/function () {\n            var _ref5 = _asyncToGenerator(function* (h) {\n              return h.get();\n            });\n\n            return function (_x) {\n              return _ref5.apply(this, arguments);\n            };\n          }());\n        }));\n\n        if (_this2.runtime.attachState === AttachState.Detached) {\n          _this2.detachedBlobIds.add(response.id);\n\n          return handle;\n        } // Note - server will de-dup blobs, so we might get existing blobId!\n\n\n        if (_this2.pendingBlobIds.has(response.id)) {\n          yield (_a = _this2.pendingBlobIds.get(response.id)) === null || _a === void 0 ? void 0 : _a.promise;\n        } else if (!_this2.blobIds.has(response.id)) {\n          _this2.pendingBlobIds.set(response.id, new Deferred()); // send blob attach op and wait until we see it to return the handle\n\n\n          _this2.attachBlobCallback(response.id);\n\n          yield (_b = _this2.pendingBlobIds.get(response.id)) === null || _b === void 0 ? void 0 : _b.promise;\n        }\n\n        return handle;\n      })();\n    }\n\n    processBlobAttachOp(blobId, local) {\n      if (local) {\n        const pendingBlobP = this.pendingBlobIds.get(blobId);\n        assert(pendingBlobP !== undefined, 0x1f8\n        /* \"local BlobAttach op with no pending blob\" */\n        );\n        pendingBlobP.resolve();\n        this.pendingBlobIds.delete(blobId);\n      }\n\n      this.blobIds.add(blobId);\n    }\n    /**\n     * Reads blobs needed to load BlobManager from storage.\n     */\n\n\n    static load(blobsTree, tryFetchBlob) {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!blobsTree) {\n          return {};\n        }\n\n        let redirectTable;\n        const tableId = blobsTree.blobs[_this3.redirectTableBlobName];\n\n        if (tableId) {\n          redirectTable = yield tryFetchBlob(tableId);\n        }\n\n        const ids = Object.entries(blobsTree.blobs).filter(([k, _]) => k !== _this3.redirectTableBlobName).map(([_, v]) => v);\n        return {\n          ids,\n          redirectTable\n        };\n      })();\n    }\n    /**\n     * Load a set of previously attached blob IDs from a previous snapshot. Note\n     * that BlobManager tracking and reporting attached blobs is a temporary\n     * solution since storage expects attached blobs to be reported and any that\n     * are not reported as attached may be GCed. In the future attached blob\n     * IDs will be collected at summarization time, and runtime will not care\n     * about the existence or specific formatting of this tree in returned\n     * snapshots.\n     *\n     * @param blobsTree - Tree containing IDs of previously attached blobs. This\n     * corresponds to snapshot() below. We look for the IDs in the blob entries\n     * of the tree since the both the r11s and SPO drivers replace the\n     * attachment types returned in snapshot() with blobs.\n     */\n\n\n    load(snapshot) {\n      var _a, _b, _c;\n\n      if (snapshot.ids) {\n        const detached = this.runtime.attachState === AttachState.Detached;\n        snapshot.ids.map(entry => detached ? this.detachedBlobIds.add(entry) : this.blobIds.add(entry));\n      }\n\n      if (snapshot.redirectTable) {\n        this.redirectTable = new Map(snapshot.redirectTable);\n      }\n\n      this.logger.sendTelemetryEvent({\n        eventName: \"AttachmentBlobsLoaded\",\n        count: (_b = (_a = snapshot.ids) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0,\n        redirectTable: (_c = snapshot.redirectTable) === null || _c === void 0 ? void 0 : _c.length\n      });\n    }\n    /**\n     * Generates data used for garbage collection. Each blob uploaded represents a node in the GC graph as it can be\n     * individually referenced by storing its handle in a referenced DDS. Returns the list of blob ids as GC nodes.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data. BlobManager doesn't care\n     * about this for now because the data is a simple list of blob ids.\n     */\n\n\n    getGCData(fullGC = false) {\n      const gcData = {\n        gcNodes: {}\n      };\n      this.blobIds.forEach(blobId => {\n        gcData.gcNodes[this.getBlobGCNodePath(blobId)] = [];\n      });\n      /**\n       * For all blobs in the redirect table, the handle returned on creation is based off of the localId. So, these\n       * nodes can be referenced by storing the localId handle. When that happens, the corresponding storageId node\n       * must also be marked referenced. So, we add a route from the localId node to the storageId node.\n       * Note that because of de-duping, there can be multiple localIds that all redirect to the same storageId or\n       * a blob may be referenced via its storageId handle.\n       */\n\n      if (this.redirectTable !== undefined) {\n        for (const [localId, storageId] of this.redirectTable) {\n          // Add node for the localId and add a route to the storageId node. The storageId node will have been\n          // added above when adding nodes for this.blobIds.\n          gcData.gcNodes[this.getBlobGCNodePath(localId)] = [this.getBlobGCNodePath(storageId)];\n        }\n      }\n\n      return gcData;\n    }\n    /**\n     * When running GC in test mode, this is called to delete blobs that are unused.\n     * @param unusedRoutes - These are the blob node ids that are unused and should be deleted.\n     */\n\n\n    deleteUnusedRoutes(unusedRoutes) {\n      var _a; // The routes or blob node paths are in the same format as returned in getGCData -\n      // `/<BlobManager.basePath>/<blobId>`.\n\n\n      for (const route of unusedRoutes) {\n        const pathParts = route.split(\"/\");\n        assert(pathParts.length === 3 && pathParts[1] === BlobManager.basePath, 0x2d5\n        /* \"Invalid blob node id in unused routes.\" */\n        );\n        const blobId = pathParts[2]; // The unused blobId could be a localId. If so, remove it from the redirect table and continue. The\n        // corresponding storageId may still be used either directly or via other localIds.\n\n        if ((_a = this.redirectTable) === null || _a === void 0 ? void 0 : _a.has(blobId)) {\n          this.redirectTable.delete(blobId);\n          continue;\n        }\n\n        this.blobIds.delete(blobId);\n      }\n    }\n\n    summarize(telemetryContext) {\n      // If we have a redirect table it means the container is about to transition to \"Attaching\" state, so we need\n      // to return an actual snapshot containing all the real storage IDs we know about.\n      const attachingOrAttached = !!this.redirectTable || this.runtime.attachState !== AttachState.Detached;\n      const blobIds = attachingOrAttached ? this.blobIds : this.detachedBlobIds;\n      const builder = new SummaryTreeBuilder();\n      blobIds.forEach(blobId => {\n        builder.addAttachment(blobId);\n      });\n\n      if (this.redirectTable && this.redirectTable.size > 0) {\n        builder.addBlob(BlobManager.redirectTableBlobName, JSON.stringify(Array.from(this.redirectTable.entries())));\n      }\n\n      return builder.getSummaryTree();\n    }\n\n    setRedirectTable(table) {\n      assert(this.runtime.attachState === AttachState.Detached, 0x252\n      /* \"redirect table can only be set in detached container\" */\n      );\n      assert(!this.redirectTable, 0x253\n      /* \"redirect table already exists\" */\n      );\n\n      for (const [localId, storageId] of table) {\n        assert(this.detachedBlobIds.delete(localId), 0x254\n        /* \"unrecognized id in redirect table\" */\n        );\n        this.blobIds.add(storageId);\n      }\n\n      assert(this.detachedBlobIds.size === 0, 0x255\n      /* \"detached blob id absent in redirect table\" */\n      );\n      this.redirectTable = table;\n    }\n\n  }\n\n  BlobManager.basePath = \"_blobs\";\n  BlobManager.redirectTableBlobName = \".redirectTable\"; //# sourceMappingURL=blobManager.js.map\n\n  return BlobManager;\n})();","map":null,"metadata":{},"sourceType":"module"}