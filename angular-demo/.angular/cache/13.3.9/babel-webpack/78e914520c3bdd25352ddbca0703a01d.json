{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"./assert\";\nimport { Deferred } from \"./promises\";\n/**\n * This class is a thin wrapper over setTimeout and clearTimeout which\n * makes it simpler to keep track of recurring timeouts with the same\n * or similar handlers and timeouts.\n */\n\nexport class Timer {\n  constructor(defaultTimeout, defaultHandler, getCurrentTick = () => Date.now()) {\n    this.defaultTimeout = defaultTimeout;\n    this.defaultHandler = defaultHandler;\n    this.getCurrentTick = getCurrentTick;\n  }\n  /**\n   * Returns true if the timer is running.\n   */\n\n\n  get hasTimer() {\n    return !!this.runningState;\n  }\n  /**\n   * Calls setTimeout and tracks the resulting timeout.\n   * @param ms - overrides default timeout in ms\n   * @param handler - overrides default handler\n   */\n\n\n  start(ms = this.defaultTimeout, handler = this.defaultHandler) {\n    this.startCore(ms, handler, ms);\n  }\n  /**\n   * Calls clearTimeout on the underlying timeout if running.\n   */\n\n\n  clear() {\n    if (!this.runningState) {\n      return;\n    }\n\n    clearTimeout(this.runningState.timeout);\n    this.runningState = undefined;\n  }\n  /**\n   * Restarts the timer with the new handler and duration.\n   * If a new handler is passed, the original handler may\n   * never execute.\n   * This is a potentially more efficient way to clear and start\n   * a new timer.\n   * @param ms - overrides previous or default timeout in ms\n   * @param handler - overrides previous or default handler\n   */\n\n\n  restart(ms, handler) {\n    var _a, _b;\n\n    if (!this.runningState) {\n      // If restart is called first, it behaves as a call to start\n      this.start(ms, handler);\n    } else {\n      const duration = ms !== null && ms !== void 0 ? ms : this.runningState.intendedDuration;\n      const handlerToUse = (_b = handler !== null && handler !== void 0 ? handler : (_a = this.runningState.restart) === null || _a === void 0 ? void 0 : _a.handler) !== null && _b !== void 0 ? _b : this.runningState.handler;\n      const remainingTime = this.calculateRemainingTime(this.runningState);\n\n      if (duration < remainingTime) {\n        // If remaining time exceeds restart duration, do a hard restart.\n        // The existing timeout time is too long.\n        this.start(duration, handlerToUse);\n      } else if (duration === remainingTime) {\n        // The existing timeout time is perfect, just update handler and data.\n        this.runningState.handler = handlerToUse;\n        this.runningState.restart = undefined;\n        this.runningState.intendedDuration = duration;\n      } else {\n        // If restart duration exceeds remaining time, set restart info.\n        // Existing timeout will start a new timeout for remaining time.\n        this.runningState.restart = {\n          startTick: this.getCurrentTick(),\n          duration,\n          handler: handlerToUse\n        };\n      }\n    }\n  }\n\n  startCore(duration, handler, intendedDuration) {\n    this.clear();\n    this.runningState = {\n      startTick: this.getCurrentTick(),\n      duration,\n      intendedDuration,\n      handler,\n      timeout: setTimeout(() => this.handler(), duration)\n    };\n  }\n\n  handler() {\n    assert(!!this.runningState, 0x00a\n    /* \"Running timer missing handler\" */\n    );\n    const restart = this.runningState.restart;\n\n    if (restart !== undefined) {\n      // Restart with remaining time\n      const remainingTime = this.calculateRemainingTime(restart);\n      this.startCore(remainingTime, () => restart.handler(), restart.duration);\n    } else {\n      // Run clear first, in case the handler decides to start again\n      const handler = this.runningState.handler;\n      this.clear();\n      handler();\n    }\n  }\n\n  calculateRemainingTime(runningTimeout) {\n    const elapsedTime = this.getCurrentTick() - runningTimeout.startTick;\n    return runningTimeout.duration - elapsedTime;\n  }\n\n}\n/**\n * This class is a wrapper over setTimeout and clearTimeout which\n * makes it simpler to keep track of recurring timeouts with the\n * same handlers and timeouts, while also providing a promise that\n * resolves when it times out.\n */\n\nexport class PromiseTimer {\n  constructor(defaultTimeout, defaultHandler) {\n    this.timer = new Timer(defaultTimeout, () => this.wrapHandler(defaultHandler));\n  }\n\n  get hasTimer() {\n    return this.timer.hasTimer;\n  }\n\n  start(ms, handler) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this.clear();\n\n      _this.deferred = new Deferred();\n\n      _this.timer.start(ms, handler ? () => _this.wrapHandler(handler) : undefined);\n\n      return _this.deferred.promise;\n    })();\n  }\n\n  clear() {\n    this.timer.clear();\n\n    if (this.deferred) {\n      this.deferred.resolve({\n        timerResult: \"cancel\"\n      });\n      this.deferred = undefined;\n    }\n  }\n\n  wrapHandler(handler) {\n    handler();\n    assert(!!this.deferred, 0x00b\n    /* \"Handler executed without deferred\" */\n    );\n    this.deferred.resolve({\n      timerResult: \"timeout\"\n    });\n    this.deferred = undefined;\n  }\n\n} //# sourceMappingURL=timer.js.map","map":null,"metadata":{},"sourceType":"module"}