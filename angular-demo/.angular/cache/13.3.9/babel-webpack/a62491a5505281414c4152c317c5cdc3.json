{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, stringToBuffer, Uint8ArrayToString, unreachableCase } from \"@fluidframework/common-utils\";\nimport { getGitType } from \"@fluidframework/protocol-base\";\nimport { SummaryType } from \"@fluidframework/protocol-definitions\";\n/**\n * Convert a list of nodes to a tree path.\n * If a node is empty (blank) it will be removed.\n * If a node's name begins and/or ends with a \"/\", it will be removed.\n * @param nodeNames - node names in path\n */\n\nexport const buildTreePath = (...nodeNames) => nodeNames.map(nodeName => nodeName.replace(/^\\//, \"\").replace(/\\/$/, \"\")).filter(nodeName => !!nodeName).join(\"/\");\n/**\n * Converts the summary tree to a whole summary tree to be uploaded. Always upload full whole summary tree.\n * @param parentHandle - Handle of the last uploaded summary or detach new summary.\n * @param tree - Summary Tree which will be converted to whole summary tree to be uploaded.\n * @param path - Current path of node which is getting evaluated.\n */\n\nexport function convertSummaryTreeToWholeSummaryTree(parentHandle, tree, path = \"\", rootNodeName = \"\") {\n  const wholeSummaryTree = {\n    type: \"tree\",\n    entries: []\n  };\n  const keys = Object.keys(tree.tree);\n\n  for (const key of keys) {\n    const summaryObject = tree.tree[key];\n    let id;\n    let value;\n    let unreferenced;\n    const currentPath = path === \"\" ? buildTreePath(rootNodeName, key) : buildTreePath(path, key);\n\n    switch (summaryObject.type) {\n      case SummaryType.Tree:\n        {\n          const result = convertSummaryTreeToWholeSummaryTree(parentHandle, summaryObject, currentPath, rootNodeName);\n          value = result;\n          unreferenced = summaryObject.unreferenced || undefined;\n          break;\n        }\n\n      case SummaryType.Blob:\n        {\n          if (typeof summaryObject.content === \"string\") {\n            value = {\n              type: \"blob\",\n              content: summaryObject.content,\n              encoding: \"utf-8\"\n            };\n          } else {\n            value = {\n              type: \"blob\",\n              content: Uint8ArrayToString(summaryObject.content, \"base64\"),\n              encoding: \"base64\"\n            };\n          }\n\n          break;\n        }\n\n      case SummaryType.Handle:\n        {\n          const handleValue = summaryObject;\n\n          if (handleValue.embedded) {\n            id = summaryObject.handle;\n          } else {\n            if (!parentHandle) {\n              throw Error(\"Parent summary does not exist to reference by handle.\");\n            }\n\n            id = buildTreePath(parentHandle, rootNodeName, summaryObject.handle);\n          }\n\n          break;\n        }\n\n      case SummaryType.Attachment:\n        {\n          id = summaryObject.id;\n          break;\n        }\n\n      default:\n        {\n          unreachableCase(summaryObject, `Unknown type: ${summaryObject.type}`);\n        }\n    }\n\n    const baseEntry = {\n      path: encodeURIComponent(key),\n      type: getGitType(summaryObject)\n    };\n    let entry;\n\n    if (value) {\n      assert(id === undefined, 0x0ad\n      /* \"Snapshot entry has both a tree value and a referenced id!\" */\n      );\n      entry = Object.assign({\n        value,\n        unreferenced\n      }, baseEntry);\n    } else if (id) {\n      entry = Object.assign(Object.assign({}, baseEntry), {\n        id\n      });\n    } else {\n      throw new Error(`Invalid tree entry for ${summaryObject.type}`);\n    }\n\n    wholeSummaryTree.entries.push(entry);\n  }\n\n  return wholeSummaryTree;\n}\n/**\n * Build a tree heirarchy from a flat tree.\n *\n * @param flatTree - a flat tree\n * @param treePrefixToRemove - tree prefix to strip\n * @returns the heirarchical tree\n */\n\nfunction buildHierarchy(flatTree, treePrefixToRemove) {\n  const lookup = {}; // Root tree id will be used to determine which version was downloaded.\n\n  const root = {\n    id: flatTree.id,\n    blobs: {},\n    trees: {}\n  };\n  lookup[\"\"] = root;\n\n  for (const entry of flatTree.entries) {\n    // Strip the `treePrefixToRemove` path from tree entries such that they are stored under root.\n    const entryPath = entry.path.replace(new RegExp(`^${treePrefixToRemove}/`), \"\");\n    const lastIndex = entryPath.lastIndexOf(\"/\");\n    const entryPathDir = entryPath.slice(0, Math.max(0, lastIndex));\n    const entryPathBase = entryPath.slice(lastIndex + 1); // The flat output is breadth-first so we can assume we see tree nodes prior to their contents\n\n    const node = lookup[entryPathDir]; // Add in either the blob or tree\n\n    if (entry.type === \"tree\") {\n      const newTree = {\n        blobs: {},\n        trees: {},\n        unreferenced: entry.unreferenced\n      };\n      node.trees[decodeURIComponent(entryPathBase)] = newTree;\n      lookup[entryPath] = newTree;\n    } else if (entry.type === \"blob\") {\n      node.blobs[decodeURIComponent(entryPathBase)] = entry.id;\n    } else {\n      throw new Error(`Unknown entry type!!`);\n    }\n  }\n\n  return root;\n}\n/**\n * Converts existing IWholeFlatSummary to snapshot tree, blob array, and sequence number.\n *\n * @param flatSummary - flat summary\n * @param treePrefixToRemove - tree prefix to strip. By default we are stripping \".app\" prefix\n * @returns snapshot tree, blob array, and sequence number\n */\n\n\nexport function convertWholeFlatSummaryToSnapshotTreeAndBlobs(flatSummary, treePrefixToRemove = \".app\") {\n  var _a;\n\n  const blobs = new Map();\n\n  if (flatSummary.blobs) {\n    flatSummary.blobs.forEach(blob => {\n      var _a;\n\n      blobs.set(blob.id, stringToBuffer(blob.content, (_a = blob.encoding) !== null && _a !== void 0 ? _a : \"utf-8\"));\n    });\n  }\n\n  const flatSummaryTree = (_a = flatSummary.trees) === null || _a === void 0 ? void 0 : _a[0];\n  const sequenceNumber = flatSummaryTree === null || flatSummaryTree === void 0 ? void 0 : flatSummaryTree.sequenceNumber;\n  const snapshotTree = buildHierarchy(flatSummaryTree, treePrefixToRemove);\n  return {\n    blobs,\n    snapshotTree,\n    sequenceNumber\n  };\n} //# sourceMappingURL=storageUtils.js.map","map":null,"metadata":{},"sourceType":"module"}