{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { IFluidDependencySynthesizer } from \"./IFluidDependencySynthesizer\";\n/**\n * DependencyContainer is similar to a IoC Container. It takes providers and will\n * synthesize an object based on them when requested.\n */\n\nexport class DependencyContainer {\n  constructor(...parents) {\n    this.providers = new Map();\n    this.parents = parents.filter(v => v !== undefined);\n  }\n\n  get IFluidDependencySynthesizer() {\n    return this;\n  }\n  /**\n   * Add a new provider\n   * @param type - Name of the Type T being provided\n   * @param provider - A provider that will resolve the T correctly when asked\n   * @throws - If passing a type that's already registered\n   */\n\n\n  register(type, provider) {\n    if (this.providers.has(type)) {\n      throw new Error(`Attempting to register a provider of type ${type} that already exists`);\n    }\n\n    this.providers.set(type, provider);\n  }\n  /**\n   * Remove a provider\n   * @param type - Name of the provider to remove\n   */\n\n\n  unregister(type) {\n    if (this.providers.has(type)) {\n      this.providers.delete(type);\n    }\n  }\n  /**\n   * {@inheritDoc (IFluidDependencySynthesizer:interface).synthesize}\n   */\n\n\n  synthesize(optionalTypes, requiredTypes) {\n    const base = {};\n    this.generateRequired(base, requiredTypes);\n    this.generateOptional(base, optionalTypes);\n    Object.defineProperty(base, IFluidDependencySynthesizer, {\n      get: () => this\n    });\n    return base;\n  }\n  /**\n   * {@inheritDoc (IFluidDependencySynthesizer:interface).has}\n   * @param excludeParents - If true, exclude checking parent registries\n   */\n\n\n  has(type, excludeParents) {\n    if (this.providers.has(type)) {\n      return true;\n    }\n\n    if (excludeParents !== true) {\n      return this.parents.some(p => p.has(type));\n    }\n\n    return false;\n  }\n  /**\n   * @deprecated - Needed for back compat\n   */\n\n\n  getProvider(provider) {\n    // this was removed, but some partners have trouble with back compat where they\n    // use invalid patterns with FluidObject and IFluidDependencySynthesizer\n    // this is just for back compat until those are removed\n    if (this.has(provider)) {\n      if (this.providers.has(provider)) {\n        return this.providers.get(provider);\n      }\n\n      for (const parent of this.parents) {\n        if (parent instanceof DependencyContainer) {\n          return parent.getProvider(provider);\n        } else {\n          // older implementations of the IFluidDependencySynthesizer exposed getProvider\n          const maybeGetProvider = parent;\n\n          if ((maybeGetProvider === null || maybeGetProvider === void 0 ? void 0 : maybeGetProvider.getProvider) !== undefined) {\n            return maybeGetProvider.getProvider(provider);\n          }\n        }\n      }\n    }\n  }\n\n  generateRequired(base, types) {\n    if (types === undefined) {\n      return;\n    }\n\n    for (const key of Object.keys(types)) {\n      const provider = this.resolveProvider(key);\n\n      if (provider === undefined) {\n        throw new Error(`Object attempted to be created without registered required provider ${key}`);\n      }\n\n      Object.defineProperty(base, key, provider);\n    }\n  }\n\n  generateOptional(base, types) {\n    var _a;\n\n    if (types === undefined) {\n      return;\n    }\n\n    for (const key of Object.keys(types)) {\n      // back-compat: in 0.56 we allow undefined in the types, but we didn't before\n      // this will keep runtime back compat, eventually we should support undefined properties\n      // rather than properties that return promises that resolve to undefined\n      const provider = (_a = this.resolveProvider(key)) !== null && _a !== void 0 ? _a : {\n        get: function () {\n          var _ref = _asyncToGenerator(function* () {\n            return undefined;\n          });\n\n          return function get() {\n            return _ref.apply(this, arguments);\n          };\n        }()\n      };\n      Object.defineProperty(base, key, provider);\n    }\n  }\n\n  resolveProvider(t) {\n    // If we have the provider return it\n    const provider = this.providers.get(t);\n\n    if (provider === undefined) {\n      for (const parent of this.parents) {\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        const sp = {\n          [t]: t\n        };\n        const syn = parent.synthesize(sp, {});\n        const descriptor = Object.getOwnPropertyDescriptor(syn, t);\n\n        if (descriptor !== undefined) {\n          return descriptor;\n        }\n      }\n\n      return undefined;\n    } // The double nested gets are required for lazy loading the provider resolution\n\n\n    if (typeof provider === \"function\") {\n      return {\n        get() {\n          if (provider && typeof provider === \"function\") {\n            return Promise.resolve(this[IFluidDependencySynthesizer]).then( /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator(function* (fds) {\n                return provider(fds);\n              });\n\n              return function (_x) {\n                return _ref2.apply(this, arguments);\n              };\n            }()).then(p => p === null || p === void 0 ? void 0 : p[t]);\n          }\n        }\n\n      };\n    }\n\n    return {\n      get() {\n        if (provider) {\n          return Promise.resolve(provider).then(p => {\n            if (p) {\n              return p[t];\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n} //# sourceMappingURL=dependencyContainer.js.map","map":null,"metadata":{},"sourceType":"module"}