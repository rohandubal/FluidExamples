{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BaseSegment, LocalReferenceCollection } from \"@fluidframework/merge-tree\";\nimport { SharedSegmentSequence } from \"./sequence\";\nconst MaxRun = 128;\nexport let SubSequence = /*#__PURE__*/(() => {\n  class SubSequence extends BaseSegment {\n    constructor(items) {\n      super();\n      this.items = items;\n      this.type = SubSequence.typeString;\n      this.cachedLength = items.length;\n    }\n\n    static is(segment) {\n      return segment.type === SubSequence.typeString;\n    }\n\n    static fromJSONObject(spec) {\n      if (spec && typeof spec === \"object\" && \"items\" in spec) {\n        const segment = new SubSequence(spec.items);\n\n        if (spec.props) {\n          segment.addProperties(spec.props);\n        }\n\n        return segment;\n      }\n\n      return undefined;\n    }\n\n    toJSONObject() {\n      const obj = {\n        items: this.items\n      };\n      super.addSerializedProps(obj);\n      return obj;\n    }\n\n    clone(start = 0, end) {\n      const clonedItems = this.items.slice(start, end);\n      const b = new SubSequence(clonedItems);\n      this.cloneInto(b);\n      return b;\n    }\n\n    canAppend(segment) {\n      return SubSequence.is(segment) && (this.cachedLength <= MaxRun || segment.cachedLength <= MaxRun);\n    }\n\n    toString() {\n      return this.items.toString();\n    }\n\n    append(segment) {\n      if (!SubSequence.is(segment)) {\n        throw new Error(\"can only append another run segment\");\n      } // Note: Must call 'appendLocalRefs' before modifying this segment's length as\n      //       'this.cachedLength' is used to adjust the offsets of the local refs.\n\n\n      LocalReferenceCollection.append(this, segment);\n      this.items = this.items.concat(segment.items);\n      this.cachedLength = this.items.length;\n    } // TODO: retain removed items for undo\n    // returns true if entire run removed\n\n\n    removeRange(start, end) {\n      let remnantItems = [];\n      const len = this.items.length;\n\n      if (start > 0) {\n        remnantItems = remnantItems.concat(this.items.slice(0, start));\n      }\n\n      if (end < len) {\n        remnantItems = remnantItems.concat(this.items.slice(end));\n      }\n\n      this.items = remnantItems;\n      this.cachedLength = this.items.length;\n      return this.items.length === 0;\n    }\n\n    createSplitSegmentAt(pos) {\n      if (pos > 0) {\n        const remainingItems = this.items.slice(pos);\n        this.items = this.items.slice(0, pos);\n        this.cachedLength = this.items.length;\n        const leafSegment = new SubSequence(remainingItems);\n        return leafSegment;\n      }\n    }\n\n  }\n\n  SubSequence.typeString = \"SubSequence\";\n  return SubSequence;\n})();\nexport class SharedSequence extends SharedSegmentSequence {\n  constructor(document, id, attributes, specToSegment) {\n    super(document, id, attributes, specToSegment);\n    this.id = id;\n  }\n  /**\n   * @param pos - The position to insert the items at.\n   * @param items - The items to insert.\n   * @param props - Optional. Properties to set on the inserted items.\n   */\n\n\n  insert(pos, items, props) {\n    const segment = new SubSequence(items);\n\n    if (props) {\n      segment.addProperties(props);\n    }\n\n    const insertOp = this.client.insertSegmentLocal(pos, segment);\n\n    if (insertOp) {\n      this.submitSequenceMessage(insertOp);\n    }\n  }\n  /**\n   * @param start - The inclusive start of the range to remove\n   * @param end - The exclusive end of the range to remove\n   */\n\n\n  remove(start, end) {\n    this.removeRange(start, end);\n  }\n  /**\n   * Returns the total count of items in the sequence\n   */\n\n\n  getItemCount() {\n    return this.getLength();\n  }\n  /**\n   * Gets the items in the specified range\n   *\n   * @param start - The inclusive start of the range\n   * @param end - The exclusive end of the range\n   */\n\n\n  getItems(start, end) {\n    const items = [];\n    let firstSegment; // Return if the range is incorrect.\n\n    if (end !== undefined && end <= start) {\n      return items;\n    }\n\n    this.walkSegments(segment => {\n      if (SubSequence.is(segment)) {\n        if (firstSegment === undefined) {\n          firstSegment = segment;\n        }\n\n        items.push(...segment.items);\n      }\n\n      return true;\n    }, start, end); // The above call to walkSegments adds all the items in the walked\n    // segments. However, we only want items beginning at |start| in\n    // the first segment. Similarly, if |end| is passed in, we only\n    // want items until |end| in the last segment. Remove the rest of\n    // the items.\n\n    if (firstSegment !== undefined) {\n      items.splice(0, start - this.getPosition(firstSegment));\n    }\n\n    if (end !== undefined) {\n      items.splice(end - start);\n    }\n\n    return items;\n  }\n\n} //# sourceMappingURL=sharedSequence.js.map","map":null,"metadata":{},"sourceType":"module"}