{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, Timer } from \"@fluidframework/common-utils\";\nimport { PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { ConnectionState } from \"./connectionState\";\nconst JoinOpTimeoutMs = 45000;\n/**\n * In the lifetime of a container, the connection will likely disconnect and reconnect periodically.\n * This class ensures that any ops sent by this container instance on previous connection are either\n * sequenced or blocked by the server before emitting the new \"connected\" event and allowing runtime to resubmit ops.\n *\n * Each connection is assigned a clientId by the service, and the connection is book-ended by a Join and a Leave op\n * generated by the service. Due to the distributed nature of the ordering service, in the case of reconnect we cannot\n * make any assumptions about ordering of operations between the old and new connections - i.e. new Join op could\n * be sequenced before old Leave op (and some acks from pending ops that were in flight when we disconnected).\n *\n * The job of this class is to encapsulate the transition period during reconnect, which is identified by\n * ConnectionState.CatchingUp. Specifically, before moving to Connected state with the new clientId, it ensures that:\n * (A) We process the Leave op for the previous clientId. This allows us to properly handle any acks from in-flight ops\n *     that got sequenced with the old clientId (we'll recognize them as local ops). After the Leave op, any other\n *     pending ops can safely be submitted with the new clientId without fear of duplication in the sequenced op stream.\n * (B) We process the Join op for the new clientId (identified when the underlying connection was first established),\n *     indicating the service is ready to sequence ops sent with the new clientId.\n *\n * For (A) we give up waiting after some time (same timeout as server uses), and go ahead and transition to Connected.\n * For (B) we log telemetry if it takes too long, but still only transition to Connected when the Join op is processed\n * and we are added to the Quorum.\n */\n\nexport class ConnectionStateHandler {\n  constructor(handler, logger, _clientId) {\n    var _a;\n\n    this.handler = handler;\n    this.logger = logger;\n    this._clientId = _clientId;\n    this._connectionState = ConnectionState.Disconnected;\n    this.prevClientLeftTimer = new Timer( // Default is 5 min for which we are going to wait for its own \"leave\" message. This is same as\n    // the max time on server after which leave op is sent.\n    (_a = this.handler.maxClientLeaveWaitTime) !== null && _a !== void 0 ? _a : 300000, () => {\n      assert(!this.connected, 0x2ac\n      /* \"Connected when timeout waiting for leave from previous session fired!\" */\n      );\n      this.applyForConnectedState(\"timeout\");\n    }); // Based on recent data, it looks like majority of cases where we get stuck are due to really slow or\n    // timing out ops fetches. So attempt recovery infrequently. Also fetch uses 30 second timeout, so\n    // if retrying fixes the problem, we should not see these events.\n\n    this.joinOpTimer = new Timer(JoinOpTimeoutMs, () => {\n      var _a; // I've observed timer firing within couple ms from disconnect event, looks like\n      // queued timer callback is not cancelled if timer is cancelled while callback sits in the queue.\n\n\n      if (this.connectionState !== ConnectionState.CatchingUp) {\n        return;\n      }\n\n      const quorumClients = this.handler.quorumClients();\n      const details = {\n        quorumInitialized: quorumClients !== undefined,\n        hasPendingClientId: this.pendingClientId !== undefined,\n        inQuorum: (quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember((_a = this.pendingClientId) !== null && _a !== void 0 ? _a : \"\")) !== undefined,\n        waitingForLeaveOp: this.waitingForLeaveOp\n      };\n      this.handler.logConnectionIssue(\"NoJoinOp\", details);\n    });\n  }\n\n  get connectionState() {\n    return this._connectionState;\n  }\n\n  get connected() {\n    return this.connectionState === ConnectionState.Connected;\n  }\n\n  get clientId() {\n    return this._clientId;\n  }\n\n  get pendingClientId() {\n    return this._pendingClientId;\n  }\n\n  startJoinOpTimer() {\n    assert(!this.joinOpTimer.hasTimer, 0x234\n    /* \"has joinOpTimer\" */\n    );\n    this.joinOpTimer.start();\n  }\n\n  stopJoinOpTimer() {\n    assert(this.joinOpTimer.hasTimer, 0x235\n    /* \"no joinOpTimer\" */\n    );\n    this.joinOpTimer.clear();\n  }\n\n  get waitingForLeaveOp() {\n    return this.prevClientLeftTimer.hasTimer;\n  }\n\n  dispose() {\n    assert(!this.joinOpTimer.hasTimer, 0x2a5\n    /* \"join timer\" */\n    );\n    this.prevClientLeftTimer.clear();\n  }\n\n  containerSaved() {\n    // If we were waiting for moving to Connected state, then only apply for state change. Since the container\n    // is now saved and we don't have any ops to roundtrip, we can clear the timer and apply for connected state.\n    if (this.waitingForLeaveOp) {\n      this.prevClientLeftTimer.clear();\n      this.applyForConnectedState(\"containerSaved\");\n    }\n  }\n\n  receivedAddMemberEvent(clientId) {\n    // This is the only one that requires the pending client ID\n    if (clientId === this.pendingClientId) {\n      if (this.joinOpTimer.hasTimer) {\n        this.stopJoinOpTimer();\n      } else {\n        // timer has already fired, meaning it took too long to get join on.\n        // Record how long it actually took to recover.\n        this.handler.logConnectionIssue(\"ReceivedJoinOp\");\n      } // Start the event in case we are waiting for leave or timeout.\n\n\n      if (this.waitingForLeaveOp) {\n        this.waitEvent = PerformanceEvent.start(this.logger, {\n          eventName: \"WaitBeforeClientLeave\",\n          details: JSON.stringify({\n            waitOnClientId: this._clientId,\n            hadOutstandingOps: this.handler.shouldClientJoinWrite()\n          })\n        });\n      }\n\n      this.applyForConnectedState(\"addMemberEvent\");\n    }\n  }\n\n  applyForConnectedState(source) {\n    var _a, _b;\n\n    const quorumClients = this.handler.quorumClients();\n    assert(quorumClients !== undefined, 0x236\n    /* \"In all cases it should be already installed\" */\n    );\n    assert(this.waitingForLeaveOp === false || this.clientId !== undefined && quorumClients.getMember(this.clientId) !== undefined, 0x2e2\n    /* \"Must only wait for leave message when clientId in quorum\" */\n    ); // Move to connected state only if we are in Connecting state, we have seen our join op\n    // and there is no timer running which means we are not waiting for previous client to leave\n    // or timeout has occurred while doing so.\n\n    if (this.pendingClientId !== this.clientId && this.pendingClientId !== undefined && quorumClients.getMember(this.pendingClientId) !== undefined && !this.waitingForLeaveOp) {\n      (_a = this.waitEvent) === null || _a === void 0 ? void 0 : _a.end({\n        source\n      });\n      this.setConnectionState(ConnectionState.Connected);\n    } else {\n      // Adding this event temporarily so that we can get help debugging if something goes wrong.\n      this.logger.sendTelemetryEvent({\n        eventName: \"connectedStateRejected\",\n        category: source === \"timeout\" ? \"error\" : \"generic\",\n        details: JSON.stringify({\n          source,\n          pendingClientId: this.pendingClientId,\n          clientId: this.clientId,\n          waitingForLeaveOp: this.waitingForLeaveOp,\n          inQuorum: (quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember((_b = this.pendingClientId) !== null && _b !== void 0 ? _b : \"\")) !== undefined\n        })\n      });\n    }\n  }\n\n  receivedRemoveMemberEvent(clientId) {\n    // If the client which has left was us, then finish the timer.\n    if (this.clientId === clientId) {\n      this.prevClientLeftTimer.clear();\n      this.applyForConnectedState(\"removeMemberEvent\");\n    }\n  }\n\n  receivedDisconnectEvent(reason) {\n    if (this.joinOpTimer.hasTimer) {\n      this.stopJoinOpTimer();\n    }\n\n    this.setConnectionState(ConnectionState.Disconnected, reason);\n  }\n  /**\n   * The \"connect\" event indicates the connection to the Relay Service is live.\n   * However, some additional conditions must be met before we can fully transition to\n   * \"Connected\" state. This function handles that interim period, known as \"Connecting\" state.\n   * @param connectionMode - Read or Write connection\n   * @param details - Connection details returned from the ordering service\n   */\n\n\n  receivedConnectEvent(connectionMode, details) {\n    const oldState = this._connectionState;\n    this._connectionState = ConnectionState.CatchingUp;\n    const writeConnection = connectionMode === \"write\";\n    assert(writeConnection || !this.handler.shouldClientJoinWrite(), 0x30a\n    /* shouldClientJoinWrite should imply this is a writeConnection */\n    );\n    assert(writeConnection || !this.waitingForLeaveOp, 0x2a6\n    /* \"waitingForLeaveOp should imply writeConnection (we need to be ready to flush pending ops)\" */\n    ); // Note that this may be undefined since the connection is established proactively on load\n    // and the quorum may still be under initialization.\n\n    const quorumClients = this.handler.quorumClients(); // Stash the clientID to detect when transitioning from connecting (socket.io channel open) to connected\n    // (have received the join message for the client ID)\n    // This is especially important in the reconnect case. It's possible there could be outstanding\n    // ops sent by this client, so we should keep the old client id until we see our own client's\n    // join message. after we see the join message for our new connection with our new client id,\n    // we know there can no longer be outstanding ops that we sent with the previous client id.\n\n    this._pendingClientId = details.clientId; // IMPORTANT: Report telemetry after we set _pendingClientId, but before transitioning to Connected state\n\n    this.handler.logConnectionStateChangeTelemetry(ConnectionState.CatchingUp, oldState); // For write connections, this pending clientId could be in the quorum already (i.e. join op already processed).\n    // We are fetching ops from storage in parallel to connecting to Relay Service,\n    // and given async processes, it's possible that we have already processed our own join message before\n    // connection was fully established.\n    // If quorumClients itself is undefined, we expect it will process the join op after it's initialized.\n\n    const waitingForJoinOp = writeConnection && (quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember(this._pendingClientId)) === undefined;\n\n    if (waitingForJoinOp) {\n      // Previous client left, and we are waiting for our own join op. When it is processed we'll join the quorum\n      // and attempt to transition to Connected state via receivedAddMemberEvent.\n      this.startJoinOpTimer();\n    } else if (!this.waitingForLeaveOp) {\n      // We're not waiting for Join or Leave op (if read-only connection those don't even apply),\n      // go ahead and declare the state to be Connected!\n      // If we are waiting for Leave op still, do nothing for now, we will transition to Connected later.\n      this.setConnectionState(ConnectionState.Connected);\n    }\n  }\n\n  setConnectionState(value, reason) {\n    if (this.connectionState === value) {\n      // Already in the desired state - exit early\n      this.logger.sendErrorEvent({\n        eventName: \"setConnectionStateSame\",\n        value\n      });\n      return;\n    }\n\n    const oldState = this._connectionState;\n    this._connectionState = value;\n    const quorumClients = this.handler.quorumClients();\n    let client;\n\n    if (this._clientId !== undefined) {\n      client = quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember(this._clientId);\n    }\n\n    if (value === ConnectionState.Connected) {\n      assert(oldState === ConnectionState.CatchingUp, 0x1d8\n      /* \"Should only transition from Connecting state\" */\n      ); // Mark our old client should have left in the quorum if it's still there\n\n      if (client !== undefined) {\n        client.shouldHaveLeft = true;\n      }\n\n      this._clientId = this.pendingClientId;\n    } else if (value === ConnectionState.Disconnected) {\n      // Important as we process our own joinSession message through delta request\n      this._pendingClientId = undefined; // Only wait for \"leave\" message if the connected client exists in the quorum because only the write\n      // client will exist in the quorum and only for those clients we will receive \"removeMember\" event and\n      // the client has some unacked ops.\n      // Also server would not accept ops from read client. Also check if the timer is not already running as\n      // we could receive \"Disconnected\" event multiple times without getting connected and in that case we\n      // don't want to reset the timer as we still want to wait on original client which started this timer.\n\n      if (client !== undefined && this.handler.shouldClientJoinWrite() && this.prevClientLeftTimer.hasTimer === false) {\n        this.prevClientLeftTimer.restart();\n      } else {\n        // Adding this event temporarily so that we can get help debugging if something goes wrong.\n        this.logger.sendTelemetryEvent({\n          eventName: \"noWaitOnDisconnected\",\n          details: JSON.stringify({\n            inQuorum: client !== undefined,\n            waitingForLeaveOp: this.waitingForLeaveOp,\n            hadOutstandingOps: this.handler.shouldClientJoinWrite()\n          })\n        });\n      }\n    } // Report transition before we propagate event across layers\n\n\n    this.handler.logConnectionStateChangeTelemetry(this._connectionState, oldState, reason); // Propagate event across layers\n\n    this.handler.connectionStateChanged();\n  }\n\n  initProtocol(protocol) {\n    protocol.quorum.on(\"addMember\", (clientId, _details) => {\n      this.receivedAddMemberEvent(clientId);\n    });\n    protocol.quorum.on(\"removeMember\", clientId => {\n      this.receivedRemoveMemberEvent(clientId);\n    }); // if we have a clientId from a previous container we need to wait for its leave message\n\n    if (this.clientId !== undefined && protocol.quorum.getMember(this.clientId) !== undefined) {\n      this.prevClientLeftTimer.restart();\n    }\n  }\n\n} //# sourceMappingURL=connectionStateHandler.js.map","map":null,"metadata":{},"sourceType":"module"}