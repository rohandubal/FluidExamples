{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { ChildLogger, PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { DriverErrorType } from \"@fluidframework/driver-definitions\";\nconst defaultInitialDelayMs = 5000;\nconst defaultOpsToBypassInitialDelay = 4000;\nexport var SummaryManagerState = /*#__PURE__*/(() => {\n  (function (SummaryManagerState) {\n    SummaryManagerState[SummaryManagerState[\"Off\"] = 0] = \"Off\";\n    SummaryManagerState[SummaryManagerState[\"Starting\"] = 1] = \"Starting\";\n    SummaryManagerState[SummaryManagerState[\"Running\"] = 2] = \"Running\";\n    SummaryManagerState[SummaryManagerState[\"Stopping\"] = 3] = \"Stopping\";\n  })(SummaryManagerState || (SummaryManagerState = {}));\n\n  return SummaryManagerState;\n})();\n\n/**\n * SummaryManager is created by parent container (i.e. interactive container with clientType !== \"summarizer\") only.\n * It observes changes in calculated summarizer and reacts to changes by either creating summarizer client or\n * stopping existing summarizer client.\n */\nexport let SummaryManager = /*#__PURE__*/(() => {\n  class SummaryManager {\n    constructor(clientElection, connectedState, summaryCollection, parentLogger,\n    /** Creates summarizer by asking interactive container to spawn summarizing container and\n     * get back its Summarizer instance. */\n    requestSummarizerFn, startThrottler, {\n      initialDelayMs = defaultInitialDelayMs,\n      opsToBypassInitialDelay = defaultOpsToBypassInitialDelay\n    } = {}, disableHeuristics) {\n      this.clientElection = clientElection;\n      this.connectedState = connectedState;\n      this.summaryCollection = summaryCollection;\n      this.requestSummarizerFn = requestSummarizerFn;\n      this.startThrottler = startThrottler;\n      this.disableHeuristics = disableHeuristics;\n      this.state = SummaryManagerState.Off;\n      this._disposed = false;\n\n      this.handleConnected = clientId => {\n        this.latestClientId = clientId; // If we have a summarizer, it should have been either cancelled on disconnected by now.\n        // But because of lastSummary process, it can still hang around, so there is not much we can\n        // check or assert.\n\n        this.refreshSummarizer();\n      };\n\n      this.handleDisconnected = () => {\n        this.refreshSummarizer();\n      };\n\n      this.refreshSummarizer = () => {\n        // Transition states depending on shouldSummarize, which is a calculated property\n        // that is only true if this client is connected and is the elected summarizer.\n        const shouldSummarizeState = this.getShouldSummarizeState();\n\n        switch (this.state) {\n          case SummaryManagerState.Off:\n            {\n              if (shouldSummarizeState.shouldSummarize) {\n                this.startSummarization();\n              }\n\n              return;\n            }\n\n          case SummaryManagerState.Starting:\n            {\n              // Cannot take any action until summarizer is created\n              // state transition will occur after creation\n              return;\n            }\n\n          case SummaryManagerState.Running:\n            {\n              if (shouldSummarizeState.shouldSummarize === false) {\n                this.stop(shouldSummarizeState.stopReason);\n              }\n\n              return;\n            }\n\n          case SummaryManagerState.Stopping:\n            {\n              // Cannot take any action until running summarizer finishes\n              // state transition will occur after it stops\n              return;\n            }\n\n          default:\n            {\n              return;\n            }\n        }\n      };\n\n      this.summarizeOnDemand = (...args) => {\n        if (this.summarizer === undefined) {\n          throw Error(\"No running summarizer client\"); // TODO: could spawn a summarizer client temporarily.\n        }\n\n        return this.summarizer.summarizeOnDemand(...args);\n      };\n\n      this.enqueueSummarize = (...args) => {\n        if (this.summarizer === undefined) {\n          throw Error(\"No running summarizer client\"); // TODO: could spawn a summarizer client temporarily.\n        }\n\n        return this.summarizer.enqueueSummarize(...args);\n      };\n\n      this.logger = ChildLogger.create(parentLogger, \"SummaryManager\", {\n        all: {\n          clientId: () => this.latestClientId\n        }\n      });\n      this.connectedState.on(\"connected\", this.handleConnected);\n      this.connectedState.on(\"disconnected\", this.handleDisconnected);\n      this.latestClientId = this.connectedState.clientId;\n      this.opsToBypassInitialDelay = opsToBypassInitialDelay;\n      this.initialDelayMs = initialDelayMs;\n    }\n\n    get disposed() {\n      return this._disposed;\n    }\n\n    get currentState() {\n      return this.state;\n    }\n    /**\n     * Until start is called, the SummaryManager won't begin attempting to start summarization.  This ensures there's\n     * a window between construction and starting where the caller can attach listeners.\n     */\n\n\n    start() {\n      this.clientElection.on(\"electedSummarizerChanged\", this.refreshSummarizer);\n      this.refreshSummarizer();\n    }\n\n    getShouldSummarizeState() {\n      // Note that if we're in the Running state, the electedClient may be a summarizer client, so we can't\n      // enforce connectedState.clientId === clientElection.electedClientId. But once we're Running, we should\n      // only transition to Stopping when the electedParentId changes. Stopping the summarizer without\n      // changing the electedParent will just cause us to transition to Starting again.\n      if (this.connectedState.clientId !== this.clientElection.electedParentId || this.state !== SummaryManagerState.Running && this.connectedState.clientId !== this.clientElection.electedClientId) {\n        return {\n          shouldSummarize: false,\n          stopReason: \"parentShouldNotSummarize\"\n        };\n      } else if (!this.connectedState.connected) {\n        return {\n          shouldSummarize: false,\n          stopReason: \"parentNotConnected\"\n        };\n      } else if (this.disposed) {\n        assert(false, 0x260\n        /* \"Disposed should mean disconnected!\" */\n        );\n      } else {\n        return {\n          shouldSummarize: true\n        };\n      }\n    }\n\n    startSummarization() {\n      var _this = this;\n\n      assert(this.state === SummaryManagerState.Off, 0x261\n      /* \"Expected: off\" */\n      );\n      this.state = SummaryManagerState.Starting;\n      assert(this.summarizer === undefined, 0x262\n      /* \"Old summarizer is still working!\" */\n      );\n      this.delayBeforeCreatingSummarizer().then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (startWithInitialDelay) {\n          // Re-validate that it need to be running. Due to asynchrony, it may be not the case anymore\n          // but only if creation was delayed. If it was not, then we want to ensure we always create\n          // a summarizer to kick off lastSummary. Without that, we would not be able to summarize and get\n          // document out of broken state if it has too many ops and ordering service keeps nacking main\n          // container (and thus it goes into cycle of reconnects)\n          if (startWithInitialDelay && _this.getShouldSummarizeState().shouldSummarize === false) {\n            return \"early exit\";\n          } // We transition to Running before requesting the summarizer, because after requesting we can't predict\n          // when the electedClient will be replaced with the new summarizer client.\n          // The alternative would be to let connectedState.clientId !== clientElection.electedClientId when\n          // state === Starting || state === Running.\n\n\n          assert(_this.state === SummaryManagerState.Starting, 0x263\n          /* \"Expected: starting\" */\n          );\n          _this.state = SummaryManagerState.Running;\n          const summarizer = yield _this.requestSummarizerFn();\n          _this.summarizer = summarizer; // Re-validate that it need to be running. Due to asynchrony, it may be not the case anymore\n\n          const shouldSummarizeState = _this.getShouldSummarizeState();\n\n          if (shouldSummarizeState.shouldSummarize === false) {\n            _this.state = SummaryManagerState.Starting;\n            summarizer.stop(shouldSummarizeState.stopReason);\n            return \"early exit after starting summarizer\";\n          } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n          const clientId = _this.latestClientId;\n          return PerformanceEvent.timedExecAsync(_this.logger, {\n            eventName: \"RunningSummarizer\",\n            attempt: _this.startThrottler.numAttempts\n          }, /*#__PURE__*/_asyncToGenerator(function* () {\n            return summarizer.run(clientId, _this.disableHeuristics);\n          }));\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()).then(reason => {\n        this.logger.sendTelemetryEvent({\n          eventName: \"EndingSummarizer\",\n          reason\n        });\n      }).catch(error => {\n        this.logger.sendTelemetryEvent({\n          eventName: \"EndingSummarizer\",\n          reason: \"exception\"\n        }, error); // Most of exceptions happen due to container being closed while loading it, due to\n        // summarizer container loosing connection while load.\n        // Not worth reporting such errors as errors. That said, we might miss some real errors if\n        // we ignore blindly, so try to narrow signature we are looking for - skip logging\n        // error only if this client should no longer be a summarizer (which in practice\n        // means it also lost connection), and error happened on load (we do not have summarizer).\n        // We could annotate the error raised in Container.load where the container closed during load with no error\n        // and check for that case here, but that does not seem to be necessary.\n\n        if (this.getShouldSummarizeState().shouldSummarize || this.summarizer !== undefined) {\n          // Report any failure as an error unless it was due to cancellation (like \"disconnected\" error)\n          // If failure happened on container load, we may not yet realized that socket disconnected, so check\n          // offlineError.\n          const category = (error === null || error === void 0 ? void 0 : error.errorType) === DriverErrorType.offlineError ? \"generic\" : \"error\";\n          this.logger.sendTelemetryEvent({\n            eventName: \"SummarizerException\",\n            category\n          }, error);\n        }\n      }).finally(() => {\n        var _a;\n\n        assert(this.state !== SummaryManagerState.Off, 0x264\n        /* \"Expected: Not Off\" */\n        );\n        this.state = SummaryManagerState.Off;\n        (_a = this.summarizer) === null || _a === void 0 ? void 0 : _a.close();\n        this.summarizer = undefined;\n\n        if (this.getShouldSummarizeState().shouldSummarize) {\n          this.startSummarization();\n        }\n      });\n    }\n\n    stop(reason) {\n      var _a;\n\n      if (!SummaryManager.isStartingOrRunning(this.state)) {\n        return;\n      }\n\n      this.state = SummaryManagerState.Stopping; // Stopping the running summarizer client should trigger a change\n      // in states when the running summarizer closes\n\n      (_a = this.summarizer) === null || _a === void 0 ? void 0 : _a.stop(reason);\n    }\n    /**\n     * Implements initial delay before creating summarizer\n     * @returns true, if creation is delayed due to heuristics (not many ops to summarize).\n     *          False if summarizer should start immediately due to too many unsummarized ops.\n     */\n\n\n    delayBeforeCreatingSummarizer() {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        // throttle creation of new summarizer containers to prevent spamming the server with websocket connections\n        let delayMs = _this2.startThrottler.getDelay(); // We have been elected the summarizer. Some day we may be able to summarize with a live document but for\n        // now we play it safe and launch a second copy.\n\n\n        _this2.logger.sendTelemetryEvent({\n          eventName: \"CreatingSummarizer\",\n          throttlerDelay: delayMs,\n          initialDelay: _this2.initialDelayMs,\n          startThrottlerMaxDelayMs: _this2.startThrottler.maxDelayMs,\n          opsSinceLastAck: _this2.summaryCollection.opsSinceLastAck,\n          opsToBypassInitialDelay: _this2.opsToBypassInitialDelay\n        }); // This delay helps ensure that last summarizer that might be left from previous client\n        // has enough time to complete its last summary and thus new summarizer not conflict with previous one.\n        // If, however, there are too many unsummarized ops, try to resolve it as quickly as possible, with\n        // understanding that we may see nacks because of such quick action.\n        // A better design would be for summarizer election logic to always select current summarizer as\n        // summarizing client (i.e. clientType === \"summarizer\" can be elected) to ensure that nobody else can\n        // summarizer while it finishes its work and moves to exit.\n        // It also helps with pure boot scenario (single client) to offset expensive work a bit out from\n        // critical boot sequence.\n\n\n        let startWithInitialDelay = false;\n\n        if (_this2.summaryCollection.opsSinceLastAck < _this2.opsToBypassInitialDelay) {\n          startWithInitialDelay = true;\n          delayMs = Math.max(delayMs, _this2.initialDelayMs);\n        }\n\n        if (delayMs > 0) {\n          let timer;\n          let resolveOpPromiseFn; // Create a listener that will break the delay if we've exceeded the initial delay ops count.\n\n          const opsListenerFn = () => {\n            if (_this2.summaryCollection.opsSinceLastAck >= _this2.opsToBypassInitialDelay) {\n              clearTimeout(timer);\n              resolveOpPromiseFn();\n            }\n          }; // Create a Promise that will resolve when the delay expires.\n\n\n          const delayPromise = new Promise(resolve => {\n            timer = setTimeout(() => resolve(), delayMs);\n          }); // Create a Promise that will resolve if the ops count passes the threshold.\n\n          const opPromise = new Promise(resolve => {\n            resolveOpPromiseFn = resolve;\n          });\n\n          _this2.summaryCollection.addOpListener(opsListenerFn);\n\n          yield Promise.race([delayPromise, opPromise]);\n\n          _this2.summaryCollection.removeOpListener(opsListenerFn);\n        }\n\n        return startWithInitialDelay;\n      })();\n    }\n\n    dispose() {\n      this.clientElection.off(\"electedSummarizerChanged\", this.refreshSummarizer);\n      this.connectedState.off(\"connected\", this.handleConnected);\n      this.connectedState.off(\"disconnected\", this.handleDisconnected);\n      this._disposed = true;\n    }\n\n  }\n\n  SummaryManager.isStartingOrRunning = state => state === SummaryManagerState.Starting || state === SummaryManagerState.Running; //# sourceMappingURL=summaryManager.js.map\n\n\n  return SummaryManager;\n})();","map":null,"metadata":{},"sourceType":"module"}