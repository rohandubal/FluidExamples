{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { TelemetryLogger } from \"./logger\";\n/**\n * The MockLogger records events sent to it, and then can walk back over those events\n * searching for a set of expected events to match against the logged events.\n */\n\nexport class MockLogger extends TelemetryLogger {\n  constructor() {\n    super();\n    this.events = [];\n  }\n\n  clear() {\n    this.events = [];\n  }\n\n  send(event) {\n    this.events.push(event);\n  }\n  /**\n   * Search events logged since the last time matchEvents was called, looking for the given expected\n   * events in order.\n   * @param expectedEvents - events in order that are expected to appear in the recorded log.\n   * These event objects may be subsets of the logged events.\n   * Note: category is ommitted from the type because it's usually uninteresting and tedious to type.\n   */\n\n\n  matchEvents(expectedEvents) {\n    const matchedExpectedEventCount = this.getMatchedEventsCount(expectedEvents); // How many expected events were left over? Hopefully none.\n\n    const unmatchedExpectedEventCount = expectedEvents.length - matchedExpectedEventCount;\n    return unmatchedExpectedEventCount === 0;\n  }\n  /** Asserts that matchEvents is true, and prints the actual/expected output if not */\n\n\n  assertMatch(expectedEvents, message) {\n    const actualEvents = this.events;\n\n    if (!this.matchEvents(expectedEvents)) {\n      throw new Error(`${message}\nexpected:\n${JSON.stringify(expectedEvents)}\n\nactual:\n${JSON.stringify(actualEvents)}`);\n    }\n  }\n  /**\n   * Search events logged since the last time matchEvents was called, looking for any of the given\n   * expected events.\n   * @param expectedEvents - events that are expected to appear in the recorded log.\n   * These event objects may be subsets of the logged events.\n   * Note: category is ommitted from the type because it's usually uninteresting and tedious to type.\n   * @returns if any of the expected events is found.\n   */\n\n\n  matchAnyEvent(expectedEvents) {\n    const matchedExpectedEventCount = this.getMatchedEventsCount(expectedEvents);\n    return matchedExpectedEventCount > 0;\n  }\n  /** Asserts that matchAnyEvent is true, and prints the actual/expected output if not */\n\n\n  assertMatchAny(expectedEvents, message) {\n    const actualEvents = this.events;\n\n    if (!this.matchAnyEvent(expectedEvents)) {\n      throw new Error(`${message}\nexpected:\n${JSON.stringify(expectedEvents)}\n\nactual:\n${JSON.stringify(actualEvents)}`);\n    }\n  }\n\n  getMatchedEventsCount(expectedEvents) {\n    let iExpectedEvent = 0;\n    this.events.forEach(event => {\n      if (iExpectedEvent < expectedEvents.length && MockLogger.eventsMatch(event, expectedEvents[iExpectedEvent])) {\n        // We found the next expected event; increment\n        ++iExpectedEvent;\n      }\n    }); // Remove the events so far; next call will just compare subsequent events from here\n\n    this.events = []; // Return the count of matched events.\n\n    return iExpectedEvent;\n  }\n  /**\n   * Ensure the expected event is a strict subset of the actual event\n   */\n\n\n  static eventsMatch(actual, expected) {\n    const masked = Object.assign(Object.assign({}, actual), expected);\n    return JSON.stringify(masked) === JSON.stringify(actual);\n  }\n\n} //# sourceMappingURL=mockLogger.js.map","map":null,"metadata":{},"sourceType":"module"}