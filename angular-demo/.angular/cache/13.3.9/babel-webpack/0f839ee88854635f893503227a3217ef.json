{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { v4 as uuid } from \"uuid\";\nimport { hasErrorInstanceId, isFluidError, isValidLegacyError } from \"./fluidErrorBase\";\n/** @returns true if value is an object but neither null nor an array */\n\nconst isRegularObject = value => {\n  return value !== null && !Array.isArray(value) && typeof value === \"object\";\n};\n/** Inspect the given error for common \"safe\" props and return them */\n\n\nexport function extractLogSafeErrorProperties(error, sanitizeStack) {\n  const removeMessageFromStack = (stack, errorName) => {\n    if (!sanitizeStack) {\n      return stack;\n    }\n\n    const stackFrames = stack.split(\"\\n\");\n    stackFrames.shift(); // Remove \"[ErrorName]: [ErrorMessage]\"\n\n    if (errorName !== undefined) {\n      stackFrames.unshift(errorName); // Add \"[ErrorName]\"\n    }\n\n    return stackFrames.join(\"\\n\");\n  };\n\n  const message = typeof (error === null || error === void 0 ? void 0 : error.message) === \"string\" ? error.message : String(error);\n  const safeProps = {\n    message\n  };\n\n  if (isRegularObject(error)) {\n    const {\n      errorType,\n      stack,\n      name\n    } = error;\n\n    if (typeof errorType === \"string\") {\n      safeProps.errorType = errorType;\n    }\n\n    if (typeof stack === \"string\") {\n      const errorName = typeof name === \"string\" ? name : undefined;\n      safeProps.stack = removeMessageFromStack(stack, errorName);\n    }\n  }\n\n  return safeProps;\n}\n/** type guard for ILoggingError interface */\n\nexport const isILoggingError = x => typeof (x === null || x === void 0 ? void 0 : x.getTelemetryProperties) === \"function\";\n/** Copy props from source onto target, but do not overwrite an existing prop that matches */\n\nfunction copyProps(target, source) {\n  for (const key of Object.keys(source)) {\n    if (target[key] === undefined) {\n      target[key] = source[key];\n    }\n  }\n}\n/** For backwards compatibility with pre-errorInstanceId valid errors */\n\n\nfunction patchLegacyError(legacyError) {\n  const patchMe = legacyError;\n\n  if (patchMe.errorInstanceId === undefined) {\n    patchMe.errorInstanceId = uuid();\n  }\n}\n/**\n * Normalize the given error yielding a valid Fluid Error\n * @returns A valid Fluid Error with any provided annotations applied\n * @param error - The error to normalize\n * @param annotations - Annotations to apply to the normalized error\n */\n\n\nexport function normalizeError(error, annotations = {}) {\n  var _a; // Back-compat, while IFluidErrorBase is rolled out\n\n\n  if (isValidLegacyError(error)) {\n    patchLegacyError(error);\n  }\n\n  if (isFluidError(error)) {\n    // We can simply add the telemetry props to the error and return it\n    error.addTelemetryProperties((_a = annotations.props) !== null && _a !== void 0 ? _a : {});\n    return error;\n  } // We have to construct a new Fluid Error, copying safe properties over\n\n\n  const {\n    message,\n    stack\n  } = extractLogSafeErrorProperties(error, false\n  /* sanitizeStack */\n  );\n  const fluidError = new NormalizedExternalError({\n    message,\n    stack\n  }); // We need to preserve these properties which are used in a non-typesafe way throughout driver code (see #8743)\n  // Anywhere they are set should be on a valid Fluid Error that would have been returned above,\n  // but we can't prove it with the types, so adding this defensive measure.\n\n  if (typeof error === \"object\" && error !== null) {\n    const {\n      canRetry,\n      retryAfterSeconds\n    } = error;\n    Object.assign(normalizeError, {\n      canRetry,\n      retryAfterSeconds\n    });\n  }\n\n  if (typeof error !== \"object\") {\n    // This is only interesting for non-objects\n    fluidError.addTelemetryProperties({\n      typeofError: typeof error\n    });\n  }\n\n  const originalErrorTelemetryProps = isILoggingError(error) ? error.getTelemetryProperties() : {};\n  fluidError.addTelemetryProperties(Object.assign(Object.assign(Object.assign({}, originalErrorTelemetryProps), annotations.props), {\n    untrustedOrigin: 1\n  }));\n  return fluidError;\n}\nlet stackPopulatedOnCreation;\n/**\n * The purpose of this function is to provide ability to capture stack context quickly.\n * Accessing new Error().stack is slow, and the slowest part is accessing stack property itself.\n * There are scenarios where we generate error with stack, but error is handled in most cases and\n * stack property is not accessed.\n * For such cases it's better to not read stack property right away, but rather delay it until / if it's needed\n * Some browsers will populate stack right away, others require throwing Error, so we do auto-detection on the fly.\n * @returns Error object that has stack populated.\n */\n\nexport function generateErrorWithStack() {\n  const err = new Error(\"<<generated stack>>\");\n\n  if (stackPopulatedOnCreation === undefined) {\n    stackPopulatedOnCreation = err.stack !== undefined;\n  }\n\n  if (stackPopulatedOnCreation) {\n    return err;\n  }\n\n  try {\n    throw err;\n  } catch (e) {\n    return e;\n  }\n}\nexport function generateStack() {\n  return generateErrorWithStack().stack;\n}\n/**\n * Create a new error using newErrorFn, wrapping and caused by the given unknown error.\n * Copies the inner error's stack, errorInstanceId and telemetry props over to the new error if present\n * @param innerError - An error from untrusted/unknown origins\n * @param newErrorFn - callback that will create a new error given the original error's message\n * @returns A new error object \"wrapping\" the given error\n */\n\nexport function wrapError(innerError, newErrorFn) {\n  const {\n    message,\n    stack\n  } = extractLogSafeErrorProperties(innerError, false\n  /* sanitizeStack */\n  );\n  const newError = newErrorFn(message);\n\n  if (stack !== undefined) {\n    overwriteStack(newError, stack);\n  } // Mark external errors with untrustedOrigin flag\n\n\n  if (isExternalError(innerError)) {\n    newError.addTelemetryProperties({\n      untrustedOrigin: 1\n    });\n  } // Reuse errorInstanceId\n\n\n  if (hasErrorInstanceId(innerError)) {\n    newError.overwriteErrorInstanceId(innerError.errorInstanceId); // For \"back-compat\" in the logs\n\n    newError.addTelemetryProperties({\n      innerErrorInstanceId: innerError.errorInstanceId\n    });\n  } // Lastly, copy over all other telemetry properties. Note these will not overwrite existing properties\n  // This will include the untrustedOrigin property if the inner error itself was created from an external error\n\n\n  if (isILoggingError(innerError)) {\n    newError.addTelemetryProperties(innerError.getTelemetryProperties());\n  }\n\n  return newError;\n}\n/** The same as wrapError, but also logs the innerError, including the wrapping error's instance id */\n\nexport function wrapErrorAndLog(innerError, newErrorFn, logger) {\n  const newError = wrapError(innerError, newErrorFn); // This will match innerError.errorInstanceId if present (see wrapError)\n\n  const errorInstanceId = newError.errorInstanceId; // For \"back-compat\" in the logs\n\n  const wrappedByErrorInstanceId = errorInstanceId;\n  logger.sendTelemetryEvent({\n    eventName: \"WrapError\",\n    errorInstanceId,\n    wrappedByErrorInstanceId\n  }, innerError);\n  return newError;\n}\n\nfunction overwriteStack(error, stack) {\n  // supposedly setting stack on an Error can throw.\n  try {\n    Object.assign(error, {\n      stack\n    });\n  } catch (errorSettingStack) {\n    error.addTelemetryProperties({\n      stack2: stack\n    });\n  }\n}\n/**\n * True for any error object that is an (optionally normalized) external error\n * False for any error we created and raised within the FF codebase, or wrapped in a well-known error type\n */\n\n\nexport function isExternalError(e) {\n  return !isValidLegacyError(e) || e.getTelemetryProperties().untrustedOrigin === 1 && e.errorType === NormalizedExternalError.normalizedErrorType;\n}\n/**\n * Type guard to identify if a particular value (loosely) appears to be a tagged telemetry property\n */\n\nexport function isTaggedTelemetryPropertyValue(x) {\n  return typeof (x === null || x === void 0 ? void 0 : x.value) !== \"object\" && typeof (x === null || x === void 0 ? void 0 : x.tag) === \"string\";\n}\n/**\n * Walk an object's enumerable properties to find those fit for telemetry.\n */\n\nfunction getValidTelemetryProps(obj, keysToOmit) {\n  const props = {};\n\n  for (const key of Object.keys(obj)) {\n    if (keysToOmit.has(key)) {\n      continue;\n    }\n\n    const val = obj[key];\n\n    switch (typeof val) {\n      case \"string\":\n      case \"number\":\n      case \"boolean\":\n      case \"undefined\":\n        props[key] = val;\n        break;\n\n      default:\n        {\n          if (isTaggedTelemetryPropertyValue(val)) {\n            props[key] = val;\n          } else {\n            // We don't support logging arbitrary objects\n            props[key] = \"REDACTED (arbitrary object)\";\n          }\n\n          break;\n        }\n    }\n  }\n\n  return props;\n}\n/**\n * Borrowed from\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value#examples}\n * Avoids runtime errors with circular references.\n * Not ideal, as will cut values that are not necessarily circular references.\n * Could be improved by implementing Node's util.inspect() for browser (minus all the coloring code)\n*/\n\n\nexport const getCircularReplacer = () => {\n  const seen = new WeakSet();\n  return (key, value) => {\n    if (typeof value === \"object\" && value !== null) {\n      if (seen.has(value)) {\n        return \"<removed/circular>\";\n      }\n\n      seen.add(value);\n    }\n\n    return value;\n  };\n};\n/**\n * Base class for \"trusted\" errors we create, whose properties can generally be logged to telemetry safely.\n * All properties set on the object, or passed in (via the constructor or addTelemetryProperties),\n * will be logged in accordance with their tag, if present.\n *\n * PLEASE take care to avoid setting sensitive data on this object without proper tagging!\n */\n\nexport class LoggingError extends Error {\n  /**\n   * Create a new LoggingError\n   * @param message - Error message to use for Error base class\n   * @param props - telemetry props to include on the error for when it's logged\n   * @param omitPropsFromLogging - properties by name to omit from telemetry props\n   */\n  constructor(message, props, omitPropsFromLogging = new Set()) {\n    super(message);\n    this.omitPropsFromLogging = omitPropsFromLogging;\n    this._errorInstanceId = uuid();\n    /** Back-compat to appease isFluidError typeguard in old code that may handle this error */\n    // @ts-expect-error - This field shouldn't be referenced in the current version, but needs to exist at runtime.\n\n    this.fluidErrorCode = \"-\"; // Don't log this list itself, or the private _errorInstanceId\n\n    omitPropsFromLogging.add(\"omitPropsFromLogging\");\n    omitPropsFromLogging.add(\"_errorInstanceId\");\n\n    if (props) {\n      this.addTelemetryProperties(props);\n    }\n  }\n\n  get errorInstanceId() {\n    return this._errorInstanceId;\n  }\n\n  overwriteErrorInstanceId(id) {\n    this._errorInstanceId = id;\n  }\n  /**\n   * Add additional properties to be logged\n   */\n\n\n  addTelemetryProperties(props) {\n    copyProps(this, props);\n  }\n  /**\n   * Get all properties fit to be logged to telemetry for this error\n   */\n\n\n  getTelemetryProperties() {\n    const taggableProps = getValidTelemetryProps(this, this.omitPropsFromLogging); // Include non-enumerable props that are not returned by getValidTelemetryProps\n\n    return Object.assign(Object.assign({}, taggableProps), {\n      stack: this.stack,\n      message: this.message,\n      errorInstanceId: this._errorInstanceId\n    });\n  }\n\n}\n/** The Error class used when normalizing an external error */\n\nlet NormalizedExternalError = /*#__PURE__*/(() => {\n  class NormalizedExternalError extends LoggingError {\n    constructor(errorProps) {\n      super(errorProps.message);\n      this.errorType = NormalizedExternalError.normalizedErrorType;\n\n      if (errorProps.stack !== undefined) {\n        overwriteStack(this, errorProps.stack);\n      }\n    }\n\n  }\n\n  // errorType \"genericError\" is used as a default value throughout the code.\n  // Note that this matches ContainerErrorType/DriverErrorType's genericError\n  //# sourceMappingURL=errorLogging.js.map\n  NormalizedExternalError.normalizedErrorType = \"genericError\";\n  return NormalizedExternalError;\n})();","map":null,"metadata":{},"sourceType":"module"}