{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, Deferred, Lazy } from \"@fluidframework/common-utils\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nexport class DataStoreContexts {\n  constructor(baseLogger) {\n    this.notBoundContexts = new Set();\n    /** Attached and loaded context proxies */\n\n    this._contexts = new Map();\n    /**\n     * List of pending context waiting either to be bound or to arrive from another client.\n     * This covers the case where a local context has been created but not yet bound,\n     * or the case where a client knows a store will exist and is waiting on its creation,\n     * so that a caller may await the deferred's promise until such a time as the context is fully ready.\n     * This is a superset of _contexts, since contexts remain here once the Deferred resolves.\n     */\n\n    this.deferredContexts = new Map();\n    this.disposeOnce = new Lazy(() => {\n      // close/stop all store contexts\n      for (const [fluidDataStoreId, contextD] of this.deferredContexts) {\n        contextD.promise.then(context => {\n          context.dispose();\n        }).catch(contextError => {\n          this._logger.sendErrorEvent({\n            eventName: \"FluidDataStoreContextDisposeError\",\n            fluidDataStoreId\n          }, contextError);\n        });\n      }\n    });\n\n    this.dispose = () => this.disposeOnce.value;\n\n    this._logger = ChildLogger.create(baseLogger);\n  }\n\n  [Symbol.iterator]() {\n    return this._contexts.entries();\n  }\n\n  get size() {\n    return this._contexts.size;\n  }\n\n  get disposed() {\n    return this.disposeOnce.evaluated;\n  }\n\n  notBoundLength() {\n    return this.notBoundContexts.size;\n  }\n\n  isNotBound(id) {\n    return this.notBoundContexts.has(id);\n  }\n\n  has(id) {\n    return this._contexts.has(id);\n  }\n\n  get(id) {\n    return this._contexts.get(id);\n  }\n\n  delete(id) {\n    this.deferredContexts.delete(id);\n    this.notBoundContexts.delete(id);\n    return this._contexts.delete(id);\n  }\n  /**\n   * Return the unbound local context with the given id,\n   * or undefined if it's not found or not unbound.\n   */\n\n\n  getUnbound(id) {\n    const context = this._contexts.get(id);\n\n    if (context === undefined || !this.notBoundContexts.has(id)) {\n      return undefined;\n    }\n\n    return this._contexts.get(id);\n  }\n  /**\n   * Add the given context, marking it as to-be-bound\n   */\n\n\n  addUnbound(context) {\n    const id = context.id;\n    assert(!this._contexts.has(id), 0x158\n    /* \"Creating store with existing ID\" */\n    );\n\n    this._contexts.set(id, context);\n\n    this.notBoundContexts.add(id);\n    this.ensureDeferred(id);\n  }\n  /**\n   * Get the context with the given id, once it exists locally and is attached.\n   * e.g. If created locally, it must be bound, or if created remotely then it's fine as soon as it's sync'd in.\n   * @param id - The id of the context to get\n   * @param wait - If false, return undefined if the context isn't present and ready now. Otherwise, wait for it.\n   */\n\n\n  getBoundOrRemoted(id, wait) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const deferredContext = _this.ensureDeferred(id);\n\n      if (!wait && !deferredContext.isCompleted) {\n        return undefined;\n      }\n\n      return deferredContext.promise;\n    })();\n  }\n\n  ensureDeferred(id) {\n    const deferred = this.deferredContexts.get(id);\n\n    if (deferred) {\n      return deferred;\n    }\n\n    const newDeferred = new Deferred();\n    this.deferredContexts.set(id, newDeferred);\n    return newDeferred;\n  }\n  /**\n   * Update this context as bound\n   */\n\n\n  bind(id) {\n    const removed = this.notBoundContexts.delete(id);\n    assert(removed, 0x159\n    /* \"The given id was not found in notBoundContexts to delete\" */\n    );\n    this.resolveDeferred(id);\n  }\n  /**\n   * Triggers the deferred to resolve, indicating the context is not local-only\n   * @param id - The id of the context to resolve to\n   */\n\n\n  resolveDeferred(id) {\n    const context = this._contexts.get(id);\n\n    assert(!!context, 0x15a\n    /* \"Cannot find context to resolve to\" */\n    );\n    assert(!this.notBoundContexts.has(id), 0x15b\n    /* \"Expected this id to already be removed from notBoundContexts\" */\n    );\n    const deferred = this.deferredContexts.get(id);\n    assert(!!deferred, 0x15c\n    /* \"Cannot find deferred to resolve\" */\n    );\n    deferred.resolve(context);\n  }\n  /**\n   * Add the given context, marking it as not local-only.\n   * This could be because it's a local context that's been bound, or because it's a remote context.\n   * @param context - The context to add\n   */\n\n\n  addBoundOrRemoted(context) {\n    const id = context.id;\n    assert(!this._contexts.has(id), 0x15d\n    /* \"Creating store with existing ID\" */\n    );\n\n    this._contexts.set(id, context); // Resolve the deferred immediately since this context is not unbound\n\n\n    this.ensureDeferred(id);\n    this.resolveDeferred(id);\n  }\n\n} //# sourceMappingURL=dataStoreContexts.js.map","map":null,"metadata":{},"sourceType":"module"}