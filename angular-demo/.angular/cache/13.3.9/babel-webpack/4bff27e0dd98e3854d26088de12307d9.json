{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Runs garbage collection on the given reference graph.\n * @param referenceGraph - The reference graph to run GC on. It's a list of nodes where each node has an id and set of\n * routes to other nodes in the graph.\n * @param rootIds - The ids of root nodes that are considered referenced.\n * @returns the ids of referenced nodes and the ids of deleted nodes in the referenced graph.\n */\nexport function runGarbageCollection(referenceGraph, rootIds) {\n  // This set keeps track of nodes that we have visited. It is used to detect cycles in the graph.\n  const visited = new Set(); // This tracks the ids of referenced nodes. The nodes corresponding to rootIds are always considered\n  // referenced so we start with those.\n\n  const referencedIds = [...rootIds];\n\n  for (const id of referencedIds) {\n    // If we have already seen this node, ignore and continue. Else, add it to visited list.\n    if (visited.has(id)) {\n      continue;\n    }\n\n    visited.add(id); // Get the node for the referenced id and add its outbound routes to referencedIds since they are\n    // also referenced.\n\n    const routes = referenceGraph[id];\n\n    if (routes !== undefined) {\n      referencedIds.push(...routes);\n    }\n  }\n\n  const referencedNodeIds = [];\n  const deletedNodeIds = [];\n\n  for (const id of Object.keys(referenceGraph)) {\n    // The nodes from the reference graph whose ids are in the visited list are referenced.\n    // The rest of the nodes are deleted.\n    if (visited.has(id)) {\n      referencedNodeIds.push(id);\n    } else {\n      deletedNodeIds.push(id);\n    }\n  }\n\n  return {\n    referencedNodeIds,\n    deletedNodeIds\n  };\n} //# sourceMappingURL=garbageCollector.js.map","map":null,"metadata":{},"sourceType":"module"}