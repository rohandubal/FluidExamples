{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\n/* eslint-disable @typescript-eslint/consistent-type-assertions */\n\n/* eslint-disable @typescript-eslint/prefer-optional-chain, no-bitwise */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { UsageError } from \"@fluidframework/container-utils\";\nimport { Heap, ListMakeHead, Stack } from \"./collections\";\nimport { LocalClientId, NonCollabClient, TreeMaintenanceSequenceNumber, UnassignedSequenceNumber, UniversalSequenceNumber } from \"./constants\";\nimport { LocalReference, LocalReferenceCollection } from \"./localReference\";\nimport { MergeTreeMaintenanceType } from \"./mergeTreeDeltaCallback\";\nimport { TrackingGroupCollection } from \"./mergeTreeTracking\";\nimport { MergeTreeDeltaType, ReferenceType } from \"./ops\";\nimport { PartialSequenceLengths } from \"./partialLengths\";\nimport { clone, createMap, extend, extendIfUndefined, matchProperties } from \"./properties\";\nimport { refTypeIncludesFlag, refGetRangeLabels, refGetTileLabels, refHasRangeLabel, refHasRangeLabels, refHasTileLabel, refHasTileLabels } from \"./referencePositions\";\nimport { SegmentGroupCollection } from \"./segmentGroupCollection\";\nimport { PropertiesManager } from \"./segmentPropertiesManager\";\nexport function toRemovalInfo(maybe) {\n  if ((maybe === null || maybe === void 0 ? void 0 : maybe.removedClientIds) !== undefined && (maybe === null || maybe === void 0 ? void 0 : maybe.removedSeq) !== undefined) {\n    return maybe;\n  }\n\n  assert((maybe === null || maybe === void 0 ? void 0 : maybe.removedClientIds) === undefined && (maybe === null || maybe === void 0 ? void 0 : maybe.removedSeq) === undefined, 0x2bf\n  /* \"both removedClientIds and removedSeq should be set or not set\" */\n  );\n}\n\nfunction isRemoved(segment) {\n  return toRemovalInfo(segment) !== undefined;\n}\n\nfunction isRemovedAndAcked(segment) {\n  const removalInfo = toRemovalInfo(segment);\n  return removalInfo !== undefined && removalInfo.removedSeq !== UnassignedSequenceNumber;\n}\n\nexport class MergeNode {\n  constructor() {\n    this.index = 0;\n    this.ordinal = \"\";\n    this.cachedLength = 0;\n  }\n\n  isLeaf() {\n    return false;\n  }\n\n}\n\nfunction addTile(tile, tiles) {\n  const tileLabels = refGetTileLabels(tile);\n\n  if (tileLabels) {\n    for (const tileLabel of tileLabels) {\n      tiles[tileLabel] = tile;\n    }\n  }\n}\n\nfunction addTileIfNotPresent(tile, tiles) {\n  const tileLabels = refGetTileLabels(tile);\n\n  if (tileLabels) {\n    for (const tileLabel of tileLabels) {\n      if (tiles[tileLabel] === undefined) {\n        tiles[tileLabel] = tile;\n      }\n    }\n  }\n}\n\nfunction applyStackDelta(currentStackMap, deltaStackMap) {\n  // eslint-disable-next-line guard-for-in, no-restricted-syntax\n  for (const label in deltaStackMap) {\n    const deltaStack = deltaStackMap[label];\n\n    if (!deltaStack.empty()) {\n      let currentStack = currentStackMap[label];\n\n      if (currentStack === undefined) {\n        currentStack = new Stack();\n        currentStackMap[label] = currentStack;\n      }\n\n      for (const delta of deltaStack.items) {\n        applyRangeReference(currentStack, delta);\n      }\n    }\n  }\n}\n\nfunction applyRangeReference(stack, delta) {\n  if (refTypeIncludesFlag(delta, ReferenceType.NestBegin)) {\n    stack.push(delta);\n    return true;\n  } else {\n    // Assume delta is end reference\n    const top = stack.top(); // TODO: match end with begin\n\n    if (top && refTypeIncludesFlag(top, ReferenceType.NestBegin)) {\n      stack.pop();\n    } else {\n      stack.push(delta);\n    }\n\n    return false;\n  }\n}\n\nfunction addNodeReferences(mergeTree, node, rightmostTiles, leftmostTiles, rangeStacks) {\n  var _a;\n\n  function updateRangeInfo(label, refPos) {\n    let stack = rangeStacks[label];\n\n    if (stack === undefined) {\n      stack = new Stack();\n      rangeStacks[label] = stack;\n    }\n\n    applyRangeReference(stack, refPos);\n  }\n\n  if (node.isLeaf()) {\n    const segment = node;\n\n    if (((_a = mergeTree.localNetLength(segment)) !== null && _a !== void 0 ? _a : 0) > 0) {\n      if (Marker.is(segment)) {\n        const markerId = segment.getId(); // Also in insertMarker but need for reload segs case\n        // can add option for this only from reload segs\n\n        if (markerId) {\n          mergeTree.mapIdToSegment(markerId, segment);\n        }\n\n        if (refTypeIncludesFlag(segment, ReferenceType.Tile)) {\n          addTile(segment, rightmostTiles);\n          addTileIfNotPresent(segment, leftmostTiles);\n        }\n\n        if (segment.refType & (ReferenceType.NestBegin | ReferenceType.NestEnd)) {\n          const rangeLabels = refGetRangeLabels(segment);\n\n          if (rangeLabels) {\n            for (const label of rangeLabels) {\n              updateRangeInfo(label, segment);\n            }\n          }\n        }\n      } else {\n        const baseSegment = node;\n\n        if (baseSegment.localRefs && baseSegment.localRefs.hierRefCount !== undefined && baseSegment.localRefs.hierRefCount > 0) {\n          for (const lref of baseSegment.localRefs) {\n            if (refTypeIncludesFlag(lref, ReferenceType.Tile)) {\n              addTile(lref, rightmostTiles);\n              addTileIfNotPresent(lref, leftmostTiles);\n            }\n\n            if (lref.refType & (ReferenceType.NestBegin | ReferenceType.NestEnd)) {\n              for (const label of refGetRangeLabels(lref)) {\n                updateRangeInfo(label, lref);\n              }\n            }\n          }\n        }\n      }\n    }\n  } else {\n    const block = node;\n    applyStackDelta(rangeStacks, block.rangeStacks);\n    extend(rightmostTiles, block.rightmostTiles);\n    extendIfUndefined(leftmostTiles, block.leftmostTiles);\n  }\n}\n\nexport function ordinalToArray(ord) {\n  const a = [];\n\n  if (ord) {\n    for (let i = 0, len = ord.length; i < len; i++) {\n      a.push(ord.charCodeAt(i));\n    }\n  }\n\n  return a;\n} // Note that the actual branching factor of the MergeTree is `MaxNodesInBlock - 1`.  This is because\n// the MergeTree always inserts first, then checks for overflow and splits if the child count equals\n// `MaxNodesInBlock`.  (i.e., `MaxNodesInBlock` contains 1 extra slot for temporary storage to\n// facilitate splits.)\n\nexport const MaxNodesInBlock = 8;\nexport class MergeBlock extends MergeNode {\n  constructor(childCount) {\n    super();\n    this.childCount = childCount;\n    this.children = new Array(MaxNodesInBlock);\n  }\n\n  hierBlock() {\n    return undefined;\n  }\n\n  setOrdinal(child, index) {\n    let childCount = this.childCount;\n\n    if (childCount === 8) {\n      childCount = 7;\n    }\n\n    assert(childCount >= 1 && childCount <= 7, 0x040\n    /* \"Child count is not within [1,7] range!\" */\n    );\n    let localOrdinal;\n    const ordinalWidth = 1 << MaxNodesInBlock - (childCount + 1);\n\n    if (index === 0) {\n      localOrdinal = ordinalWidth - 1;\n    } else {\n      const prevOrd = this.children[index - 1].ordinal;\n      const prevOrdCode = prevOrd.charCodeAt(prevOrd.length - 1);\n      localOrdinal = prevOrdCode + ordinalWidth;\n    }\n\n    child.ordinal = this.ordinal + String.fromCharCode(localOrdinal);\n    assert(child.ordinal.length === this.ordinal.length + 1, 0x041\n    /* \"Unexpected child ordinal length!\" */\n    );\n\n    if (index > 0) {\n      assert(child.ordinal > this.children[index - 1].ordinal, 0x042);\n    }\n  }\n\n  assignChild(child, index, updateOrdinal = true) {\n    child.parent = this;\n    child.index = index;\n\n    if (updateOrdinal) {\n      this.setOrdinal(child, index);\n    }\n\n    this.children[index] = child;\n  }\n\n}\n\nclass HierMergeBlock extends MergeBlock {\n  constructor(childCount) {\n    super(childCount);\n    this.rightmostTiles = createMap();\n    this.leftmostTiles = createMap();\n    this.rangeStacks = createMap();\n  }\n\n  addNodeReferences(mergeTree, node) {\n    addNodeReferences(mergeTree, node, this.rightmostTiles, this.leftmostTiles, this.rangeStacks);\n  }\n\n  hierBlock() {\n    return this;\n  }\n\n  hierToString(indentCount) {\n    let strbuf = \"\"; // eslint-disable-next-line guard-for-in, no-restricted-syntax\n\n    for (const key in this.rangeStacks) {\n      const stack = this.rangeStacks[key];\n      strbuf += internedSpaces(indentCount);\n      strbuf += `${key}: `;\n\n      for (const item of stack.items) {\n        strbuf += `${item.toString()} `;\n      }\n\n      strbuf += \"\\n\";\n    }\n\n    return strbuf;\n  }\n\n}\n\nfunction nodeTotalLength(mergeTree, node) {\n  if (!node.isLeaf()) {\n    return node.cachedLength;\n  }\n\n  return mergeTree.localNetLength(node);\n}\n\nexport class BaseSegment extends MergeNode {\n  constructor() {\n    super(...arguments);\n    this.clientId = LocalClientId;\n    this.seq = UniversalSequenceNumber;\n    this.segmentGroups = new SegmentGroupCollection(this);\n    this.trackingCollection = new TrackingGroupCollection(this);\n  }\n\n  addProperties(newProps, op, seq, collabWindow) {\n    if (!this.propertyManager) {\n      this.propertyManager = new PropertiesManager();\n    }\n\n    if (!this.properties) {\n      this.properties = createMap();\n    }\n\n    return this.propertyManager.addProperties(this.properties, newProps, op, seq, collabWindow && collabWindow.collaborating);\n  }\n\n  hasProperty(key) {\n    return !!this.properties && this.properties[key] !== undefined;\n  }\n\n  isLeaf() {\n    return true;\n  }\n\n  cloneInto(b) {\n    var _a;\n\n    b.clientId = this.clientId; // TODO: deep clone properties\n\n    b.properties = clone(this.properties);\n    b.removedClientIds = (_a = this.removedClientIds) === null || _a === void 0 ? void 0 : _a.slice(); // TODO: copy removed client overlap and branch removal info\n\n    b.removedSeq = this.removedSeq;\n    b.seq = this.seq;\n  }\n\n  canAppend(segment) {\n    return false;\n  }\n\n  addSerializedProps(jseg) {\n    if (this.properties) {\n      jseg.props = this.properties;\n    }\n  }\n\n  ack(segmentGroup, opArgs, mergeTree) {\n    const currentSegmentGroup = this.segmentGroups.dequeue();\n    assert(currentSegmentGroup === segmentGroup, 0x043\n    /* \"On ack, unexpected segmentGroup!\" */\n    );\n\n    switch (opArgs.op.type) {\n      case MergeTreeDeltaType.ANNOTATE:\n        assert(!!this.propertyManager, 0x044\n        /* \"On annotate ack, missing segment property manager!\" */\n        );\n        this.propertyManager.ackPendingProperties(opArgs.op);\n        return true;\n\n      case MergeTreeDeltaType.INSERT:\n        assert(this.seq === UnassignedSequenceNumber, 0x045\n        /* \"On insert, seq number already assigned!\" */\n        );\n        this.seq = opArgs.sequencedMessage.sequenceNumber;\n        this.localSeq = undefined;\n        return true;\n\n      case MergeTreeDeltaType.REMOVE:\n        const removalInfo = toRemovalInfo(this);\n        assert(removalInfo !== undefined, 0x046\n        /* \"On remove ack, missing removal info!\" */\n        );\n        this.localRemovedSeq = undefined;\n\n        if (removalInfo.removedSeq === UnassignedSequenceNumber) {\n          removalInfo.removedSeq = opArgs.sequencedMessage.sequenceNumber;\n          return true;\n        }\n\n        return false;\n\n      default:\n        throw new Error(`${opArgs.op.type} is in unrecognized operation type`);\n    }\n  }\n\n  splitAt(pos) {\n    var _a;\n\n    if (pos > 0) {\n      const leafSegment = this.createSplitSegmentAt(pos);\n\n      if (leafSegment) {\n        this.copyPropertiesTo(leafSegment);\n        leafSegment.parent = this.parent; // Give the leaf a temporary yet valid ordinal.\n        // when this segment is put in the tree, it will get it's real ordinal,\n        // but this ordinal meets all the necessary invariants for now.\n\n        leafSegment.ordinal = this.ordinal + String.fromCharCode(0);\n        leafSegment.removedClientIds = (_a = this.removedClientIds) === null || _a === void 0 ? void 0 : _a.slice();\n        leafSegment.removedSeq = this.removedSeq;\n        leafSegment.localRemovedSeq = this.localRemovedSeq;\n        leafSegment.seq = this.seq;\n        leafSegment.localSeq = this.localSeq;\n        leafSegment.clientId = this.clientId;\n        this.segmentGroups.copyTo(leafSegment);\n        this.trackingCollection.copyTo(leafSegment);\n\n        if (this.localRefs) {\n          this.localRefs.split(pos, leafSegment);\n        }\n      }\n\n      return leafSegment;\n    }\n  }\n\n  copyPropertiesTo(other) {\n    if (this.propertyManager) {\n      if (this.properties) {\n        other.propertyManager = new PropertiesManager();\n        other.properties = this.propertyManager.copyTo(this.properties, other.properties, other.propertyManager);\n      }\n    }\n  }\n\n}\nexport const reservedMarkerIdKey = \"markerId\";\nexport const reservedMarkerSimpleTypeKey = \"markerSimpleType\";\nexport let Marker = /*#__PURE__*/(() => {\n  class Marker extends BaseSegment {\n    constructor(refType) {\n      super();\n      this.refType = refType;\n      this.type = Marker.type;\n      this.cachedLength = 1;\n    }\n\n    static is(segment) {\n      return segment.type === Marker.type;\n    }\n\n    static make(refType, props) {\n      const marker = new Marker(refType);\n\n      if (props) {\n        marker.addProperties(props);\n      }\n\n      return marker;\n    }\n\n    toJSONObject() {\n      const obj = {\n        marker: {\n          refType: this.refType\n        }\n      };\n      super.addSerializedProps(obj);\n      return obj;\n    }\n\n    static fromJSONObject(spec) {\n      if (spec && typeof spec === \"object\" && \"marker\" in spec) {\n        return Marker.make(spec.marker.refType, spec.props);\n      }\n\n      return undefined;\n    }\n\n    clone() {\n      const b = Marker.make(this.refType, this.properties);\n      this.cloneInto(b);\n      return b;\n    }\n\n    getSegment() {\n      return this;\n    }\n\n    getOffset() {\n      return 0;\n    }\n\n    hasSimpleType(simpleTypeName) {\n      return !!this.properties && this.properties[reservedMarkerSimpleTypeKey] === simpleTypeName;\n    }\n\n    getProperties() {\n      return this.properties;\n    }\n\n    getId() {\n      if (this.properties && this.properties[reservedMarkerIdKey]) {\n        return this.properties[reservedMarkerIdKey];\n      }\n    }\n    /**\n     * @deprecated - use refHasTileLabels\n     */\n\n\n    hasTileLabels() {\n      return refHasTileLabels(this);\n    }\n    /**\n     * @deprecated - use refHasRangeLabels\n     */\n\n\n    hasRangeLabels() {\n      return refHasRangeLabels(this);\n    }\n    /**\n     * @deprecated - use refHasTileLabel\n     */\n\n\n    hasTileLabel(label) {\n      return refHasTileLabel(this, label);\n    }\n    /**\n     * @deprecated - use refHasRangeLabel\n     */\n\n\n    hasRangeLabel(label) {\n      return refHasRangeLabel(this, label);\n    }\n    /**\n     * @deprecated - use refGetTileLabels\n     */\n\n\n    getTileLabels() {\n      return refGetTileLabels(this);\n    }\n    /**\n     * @deprecated - use refGetRangeLabels\n     */\n\n\n    getRangeLabels() {\n      return refGetRangeLabels(this);\n    }\n\n    toString() {\n      let bbuf = \"\";\n\n      if (refTypeIncludesFlag(this, ReferenceType.Tile)) {\n        bbuf += \"Tile\";\n      }\n\n      if (refTypeIncludesFlag(this, ReferenceType.NestBegin)) {\n        if (bbuf.length > 0) {\n          bbuf += \"; \";\n        }\n\n        bbuf += \"RangeBegin\";\n      }\n\n      if (refTypeIncludesFlag(this, ReferenceType.NestEnd)) {\n        if (bbuf.length > 0) {\n          bbuf += \"; \";\n        }\n\n        bbuf += \"RangeEnd\";\n      }\n\n      let lbuf = \"\";\n      const id = this.getId();\n\n      if (id) {\n        bbuf += ` (${id}) `;\n      }\n\n      const tileLabels = refGetTileLabels(this);\n\n      if (tileLabels) {\n        lbuf += \"tile -- \";\n\n        for (let i = 0, len = tileLabels.length; i < len; i++) {\n          const tileLabel = tileLabels[i];\n\n          if (i > 0) {\n            lbuf += \"; \";\n          }\n\n          lbuf += tileLabel;\n        }\n      }\n\n      const rangeLabels = refGetRangeLabels(this);\n\n      if (rangeLabels) {\n        let rangeKind = \"begin\";\n\n        if (refTypeIncludesFlag(this, ReferenceType.NestEnd)) {\n          rangeKind = \"end\";\n        }\n\n        if (tileLabels) {\n          lbuf += \" \";\n        }\n\n        lbuf += `range ${rangeKind} -- `;\n        const labels = rangeLabels;\n\n        for (let i = 0, len = labels.length; i < len; i++) {\n          const rangeLabel = labels[i];\n\n          if (i > 0) {\n            lbuf += \"; \";\n          }\n\n          lbuf += rangeLabel;\n        }\n      }\n\n      let pbuf = \"\";\n\n      if (this.properties) {\n        pbuf += JSON.stringify(this.properties, (key, value) => {\n          // Avoid circular reference when stringifying makers containing handles.\n          // (Substitute a debug string instead.)\n          const handle = !!value && value.IFluidHandle; // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n          return handle ? `#Handle(${handle.routeContext.path}/${handle.path})` : value;\n        });\n      }\n\n      return `M ${bbuf}: ${lbuf} ${pbuf}`;\n    }\n\n    createSplitSegmentAt(pos) {\n      return undefined;\n    }\n\n    canAppend(segment) {\n      return false;\n    }\n\n    append() {\n      throw new Error(\"Can not append to marker\");\n    }\n\n  }\n\n  Marker.type = \"Marker\";\n  return Marker;\n})();\nexport var IncrementalExecOp = /*#__PURE__*/(() => {\n  (function (IncrementalExecOp) {\n    IncrementalExecOp[IncrementalExecOp[\"Go\"] = 0] = \"Go\";\n    IncrementalExecOp[IncrementalExecOp[\"Stop\"] = 1] = \"Stop\";\n    IncrementalExecOp[IncrementalExecOp[\"Yield\"] = 2] = \"Yield\";\n  })(IncrementalExecOp || (IncrementalExecOp = {}));\n\n  return IncrementalExecOp;\n})();\nexport class IncrementalMapState {\n  constructor(block, actions, pos, refSeq, clientId, context, start, end, childIndex = 0) {\n    this.block = block;\n    this.actions = actions;\n    this.pos = pos;\n    this.refSeq = refSeq;\n    this.clientId = clientId;\n    this.context = context;\n    this.start = start;\n    this.end = end;\n    this.childIndex = childIndex;\n    this.op = IncrementalExecOp.Go;\n  }\n\n}\nexport class CollaborationWindow {\n  constructor() {\n    this.clientId = LocalClientId;\n    this.collaborating = false; // Lowest-numbered segment in window; no client can reference a state before this one\n\n    this.minSeq = 0; // Highest-numbered segment in window and current\n    // reference segment for this client\n\n    this.currentSeq = 0;\n    this.localSeq = 0;\n  }\n\n  loadFrom(a) {\n    this.clientId = a.clientId;\n    this.collaborating = a.collaborating;\n    this.minSeq = a.minSeq;\n    this.currentSeq = a.currentSeq;\n  }\n\n}\nexport const compareNumbers = (a, b) => a - b;\nexport const compareStrings = (a, b) => a.localeCompare(b);\nconst indentStrings = [\"\", \" \", \"  \"];\nexport function internedSpaces(n) {\n  if (indentStrings[n] === undefined) {\n    indentStrings[n] = \"\";\n\n    for (let i = 0; i < n; i++) {\n      indentStrings[n] += \" \";\n    }\n  }\n\n  return indentStrings[n];\n}\nexport const clientSeqComparer = {\n  min: {\n    refSeq: -1,\n    clientId: \"\"\n  },\n  compare: (a, b) => a.refSeq - b.refSeq\n};\nconst LRUSegmentComparer = {\n  min: {\n    maxSeq: -2\n  },\n  compare: (a, b) => a.maxSeq - b.maxSeq\n};\n\nfunction applyLeafRangeMarker(marker, searchInfo) {\n  for (const rangeLabel of searchInfo.rangeLabels) {\n    if (refHasRangeLabel(marker, rangeLabel)) {\n      let currentStack = searchInfo.stacks[rangeLabel];\n\n      if (currentStack === undefined) {\n        currentStack = new Stack();\n        searchInfo.stacks[rangeLabel] = currentStack;\n      }\n\n      applyRangeReference(currentStack, marker);\n    }\n  }\n}\n\nfunction recordRangeLeaf(segment, segpos, refSeq, clientId, start, end, searchInfo) {\n  if (Marker.is(segment)) {\n    if (segment.refType & (ReferenceType.NestBegin | ReferenceType.NestEnd)) {\n      applyLeafRangeMarker(segment, searchInfo);\n    }\n  }\n\n  return false;\n}\n\nfunction rangeShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {\n  var _a;\n\n  if (node.isLeaf()) {\n    const seg = node;\n\n    if (((_a = searchInfo.mergeTree.localNetLength(seg)) !== null && _a !== void 0 ? _a : 0) > 0 && Marker.is(seg)) {\n      if (seg.refType & (ReferenceType.NestBegin | ReferenceType.NestEnd)) {\n        applyLeafRangeMarker(seg, searchInfo);\n      }\n    }\n  } else {\n    const block = node;\n    applyStackDelta(searchInfo.stacks, block.rangeStacks);\n  }\n\n  return true;\n}\n\nfunction recordTileStart(segment, segpos, refSeq, clientId, start, end, searchInfo) {\n  if (Marker.is(segment)) {\n    if (refHasTileLabel(segment, searchInfo.tileLabel)) {\n      searchInfo.tile = segment;\n    }\n  }\n\n  return false;\n}\n\nfunction tileShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {\n  if (node.isLeaf()) {\n    const seg = node;\n\n    if (searchInfo.mergeTree.localNetLength(seg) > 0 && Marker.is(seg)) {\n      if (refHasTileLabel(seg, searchInfo.tileLabel)) {\n        searchInfo.tile = seg;\n      }\n    }\n  } else {\n    const block = node;\n    let marker;\n\n    if (searchInfo.posPrecedesTile) {\n      marker = block.rightmostTiles[searchInfo.tileLabel];\n    } else {\n      marker = block.leftmostTiles[searchInfo.tileLabel];\n    }\n\n    if (marker !== undefined) {\n      searchInfo.tile = marker;\n    }\n  }\n\n  return true;\n}\n\nconst minListenerComparer = {\n  min: {\n    minRequired: Number.MIN_VALUE,\n    onMinGE: () => {\n      assert(false, 0x048\n      /* \"onMinGE()\" */\n      );\n    }\n  },\n  compare: (a, b) => a.minRequired - b.minRequired\n}; // Represents a sequence of text segments\n\nexport let MergeTree = /*#__PURE__*/(() => {\n  class MergeTree {\n    // TODO: make and use interface describing options\n    constructor(options) {\n      this.options = options;\n      this.blockUpdateActions = MergeTree.initBlockUpdateActions;\n      this.collabWindow = new CollaborationWindow(); // TODO: add remove on segment remove\n      // for now assume only markers have ids and so point directly at the Segment\n      // if we need to have pointers to non-markers, we can change to point at local refs\n\n      this.idToSegment = new Map();\n\n      this.splitLeafSegment = (segment, pos) => {\n        if (!(pos > 0 && segment)) {\n          return {};\n        }\n\n        const next = segment.splitAt(pos);\n\n        if (this.mergeTreeMaintenanceCallback) {\n          this.mergeTreeMaintenanceCallback({\n            operation: MergeTreeMaintenanceType.SPLIT,\n            deltaSegments: [{\n              segment\n            }, {\n              segment: next\n            }]\n          }, undefined);\n        }\n\n        return {\n          next\n        };\n      };\n\n      this.root = this.makeBlock(0);\n    }\n\n    makeBlock(childCount) {\n      const block = new HierMergeBlock(childCount);\n      block.ordinal = \"\";\n      return block;\n    }\n\n    clone() {\n      const b = new MergeTree(this.options); // For now assume that b will not collaborate\n\n      b.root = b.blockClone(this.root);\n    }\n\n    blockClone(block, segments) {\n      const bBlock = this.makeBlock(block.childCount);\n\n      for (let i = 0; i < block.childCount; i++) {\n        const child = block.children[i];\n\n        if (child.isLeaf()) {\n          const segment = this.segmentClone(child);\n          bBlock.assignChild(segment, i);\n\n          if (segments) {\n            segments.push(segment);\n          }\n        } else {\n          bBlock.assignChild(this.blockClone(child, segments), i);\n        }\n      }\n\n      this.nodeUpdateLengthNewStructure(bBlock);\n      this.nodeUpdateOrdinals(bBlock);\n      return bBlock;\n    }\n\n    segmentClone(segment) {\n      const b = segment.clone();\n      return b;\n    }\n\n    localNetLength(segment) {\n      const removalInfo = toRemovalInfo(segment);\n\n      if (removalInfo !== undefined) {\n        return 0;\n      } else {\n        return segment.cachedLength;\n      }\n    } // TODO: remove id when segment removed\n\n\n    mapIdToSegment(id, segment) {\n      this.idToSegment.set(id, segment);\n    }\n\n    addNode(block, node) {\n      const index = block.childCount++;\n      block.assignChild(node, index, false);\n      return index;\n    }\n    /* eslint-disable max-len */\n\n\n    reloadFromSegments(segments) {\n      // This code assumes that a later call to `startCollaboration()` will initialize partial lengths.\n      assert(!this.collabWindow.collaborating, 0x049\n      /* \"Trying to reload from segments while collaborating!\" */\n      );\n      const maxChildren = MaxNodesInBlock - 1; // Starting with the leaf segments, recursively builds the B-Tree layer by layer from the bottom up.\n\n      const buildMergeBlock = nodes => {\n        const blockCount = Math.ceil(nodes.length / maxChildren); // Compute # blocks require for this level of B-Tree\n\n        const blocks = new Array(blockCount); // Pre-alloc array to collect nodes\n        // For each block in this level of the B-Tree...\n\n        for (let nodeIndex = 0, blockIndex = 0; // Start with the first block and first node\n        blockIndex < blockCount; // If we have more blocks, we also have more nodes to insert\n        blockIndex++ // Advance to next block in this layer.\n        ) {\n          const block = blocks[blockIndex] = this.makeBlock(0); // For each child of the current block, insert a node (while we have nodes left)\n          // and update the block's info.\n\n          for (let childIndex = 0; childIndex < maxChildren && nodeIndex < nodes.length; // While we still have children & nodes left\n          childIndex++, nodeIndex++ // Advance to next child & node\n          ) {\n            // Insert the next node into the current block\n            this.addNode(block, nodes[nodeIndex]);\n          } // Calculate this block's info.  Previously this was inlined into the above loop as a micro-optimization,\n          // but it turns out to be negligible in practice since `reloadFromSegments()` is only invoked for the\n          // snapshot header.  The bulk of the segments in long documents are inserted via `insertSegments()`.\n\n\n          this.blockUpdate(block);\n        } // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n        return blocks.length === 1 // If there is only one block at this layer...\n        ? blocks[0] // ...then we're done.  Return the root.\n        : buildMergeBlock(blocks); // ...otherwise recursively build the next layer above blocks.\n      };\n\n      if (segments.length > 0) {\n        this.root = buildMergeBlock(segments);\n        this.nodeUpdateOrdinals(this.root);\n      } else {\n        this.root = this.makeBlock(0);\n      }\n    }\n    /* eslint-enable max-len */\n    // For now assume min starts at zero\n\n\n    startCollaboration(localClientId, minSeq, currentSeq) {\n      this.collabWindow.clientId = localClientId;\n      this.collabWindow.minSeq = minSeq;\n      this.collabWindow.collaborating = true;\n      this.collabWindow.currentSeq = currentSeq;\n      this.segmentsToScour = new Heap([], LRUSegmentComparer);\n      this.pendingSegments = ListMakeHead();\n      this.nodeUpdateLengthNewStructure(this.root, true);\n    }\n\n    addToLRUSet(segment, seq) {\n      // If the parent node has not yet been marked for scour (i.e., needsScour is not false or undefined),\n      // add the segment and mark the mark the node now.\n      // TODO: 'seq' may be less than the current sequence number when inserting pre-ACKed\n      //       segments from a snapshot.  We currently skip these for now.\n      if (segment.parent.needsScour !== true && seq > this.collabWindow.currentSeq) {\n        segment.parent.needsScour = true;\n        this.segmentsToScour.add({\n          segment,\n          maxSeq: seq\n        });\n      }\n    }\n\n    underflow(node) {\n      return node.childCount < MaxNodesInBlock / 2;\n    }\n\n    scourNode(node, holdNodes) {\n      let prevSegment;\n\n      for (let k = 0; k < node.childCount; k++) {\n        const childNode = node.children[k];\n\n        if (childNode.isLeaf()) {\n          const segment = childNode;\n\n          if (segment.segmentGroups.empty) {\n            if (segment.removedSeq !== undefined) {\n              if (segment.removedSeq > this.collabWindow.minSeq) {\n                holdNodes.push(segment);\n              } else if (!segment.trackingCollection.empty) {\n                holdNodes.push(segment);\n              } else {\n                // Notify maintenance event observers that the segment is being unlinked from the MergeTree\n                if (this.mergeTreeMaintenanceCallback) {\n                  this.mergeTreeMaintenanceCallback({\n                    operation: MergeTreeMaintenanceType.UNLINK,\n                    deltaSegments: [{\n                      segment\n                    }]\n                  }, undefined);\n                }\n\n                segment.parent = undefined;\n              }\n\n              prevSegment = undefined;\n            } else {\n              if (segment.seq <= this.collabWindow.minSeq) {\n                const canAppend = prevSegment && prevSegment.canAppend(segment) && matchProperties(prevSegment.properties, segment.properties) && prevSegment.trackingCollection.matches(segment.trackingCollection) && this.localNetLength(segment) > 0;\n\n                if (canAppend) {\n                  prevSegment.append(segment);\n\n                  if (this.mergeTreeMaintenanceCallback) {\n                    this.mergeTreeMaintenanceCallback({\n                      operation: MergeTreeMaintenanceType.APPEND,\n                      deltaSegments: [{\n                        segment: prevSegment\n                      }, {\n                        segment\n                      }]\n                    }, undefined);\n                  }\n\n                  segment.parent = undefined;\n                  segment.trackingCollection.trackingGroups.forEach(tg => tg.unlink(segment));\n                } else {\n                  holdNodes.push(segment);\n\n                  if (this.localNetLength(segment) > 0) {\n                    prevSegment = segment;\n                  } else {\n                    prevSegment = undefined;\n                  }\n                }\n              } else {\n                holdNodes.push(segment);\n                prevSegment = undefined;\n              }\n            }\n          } else {\n            holdNodes.push(segment);\n            prevSegment = undefined;\n          }\n        } else {\n          holdNodes.push(childNode);\n          prevSegment = undefined;\n        }\n      }\n    } // Interior node with all node children\n\n\n    packParent(parent) {\n      const children = parent.children;\n      let childIndex;\n      let childBlock;\n      const holdNodes = [];\n\n      for (childIndex = 0; childIndex < parent.childCount; childIndex++) {\n        // Debug assert not isLeaf()\n        childBlock = children[childIndex];\n        this.scourNode(childBlock, holdNodes); // Will replace this block with a packed block\n\n        childBlock.parent = undefined;\n      }\n\n      const totalNodeCount = holdNodes.length;\n      const halfCount = MaxNodesInBlock / 2;\n      let childCount = Math.min(MaxNodesInBlock - 1, Math.floor(totalNodeCount / halfCount));\n\n      if (childCount < 1) {\n        childCount = 1;\n      }\n\n      const baseCount = Math.floor(totalNodeCount / childCount);\n      let extraCount = totalNodeCount % childCount;\n      const packedBlocks = new Array(MaxNodesInBlock);\n      let readCount = 0;\n\n      for (let nodeIndex = 0; nodeIndex < childCount; nodeIndex++) {\n        let nodeCount = baseCount;\n\n        if (extraCount > 0) {\n          nodeCount++;\n          extraCount--;\n        }\n\n        const packedBlock = this.makeBlock(nodeCount);\n\n        for (let packedNodeIndex = 0; packedNodeIndex < nodeCount; packedNodeIndex++) {\n          const nodeToPack = holdNodes[readCount++];\n          packedBlock.assignChild(nodeToPack, packedNodeIndex, false);\n        }\n\n        packedBlock.parent = parent;\n        packedBlocks[nodeIndex] = packedBlock;\n        this.nodeUpdateLengthNewStructure(packedBlock);\n      }\n\n      parent.children = packedBlocks;\n\n      for (let j = 0; j < childCount; j++) {\n        parent.assignChild(packedBlocks[j], j, false);\n      }\n\n      parent.childCount = childCount;\n\n      if (this.underflow(parent) && parent.parent) {\n        this.packParent(parent.parent);\n      } else {\n        this.nodeUpdateOrdinals(parent);\n        this.blockUpdatePathLengths(parent, UnassignedSequenceNumber, -1, true);\n      }\n    }\n\n    zamboniSegments(zamboniSegmentsMaxCount = MergeTree.zamboniSegmentsMaxCount) {\n      if (!this.collabWindow.collaborating) {\n        return;\n      }\n\n      for (let i = 0; i < zamboniSegmentsMaxCount; i++) {\n        let segmentToScour = this.segmentsToScour.peek();\n\n        if (!segmentToScour || segmentToScour.maxSeq > this.collabWindow.minSeq) {\n          break;\n        }\n\n        segmentToScour = this.segmentsToScour.get(); // Only skip scouring if needs scour is explicitly false, not true or undefined\n\n        if (segmentToScour.segment.parent && segmentToScour.segment.parent.needsScour !== false) {\n          const block = segmentToScour.segment.parent;\n          const childrenCopy = [];\n          this.scourNode(block, childrenCopy); // This will avoid the cost of re-scouring nodes\n          // that have recently been scoured\n\n          block.needsScour = false;\n          const newChildCount = childrenCopy.length;\n\n          if (newChildCount < block.childCount) {\n            block.childCount = newChildCount;\n            block.children = childrenCopy;\n\n            for (let j = 0; j < newChildCount; j++) {\n              block.assignChild(childrenCopy[j], j, false);\n            }\n\n            if (this.underflow(block) && block.parent) {\n              this.packParent(block.parent);\n            } else {\n              this.nodeUpdateOrdinals(block);\n              this.blockUpdatePathLengths(block, UnassignedSequenceNumber, -1, true);\n            }\n          }\n        }\n      }\n    }\n\n    getCollabWindow() {\n      return this.collabWindow;\n    }\n\n    getStats() {\n      const nodeGetStats = block => {\n        const stats = {\n          maxHeight: 0,\n          nodeCount: 0,\n          leafCount: 0,\n          removedLeafCount: 0,\n          liveCount: 0,\n          histo: []\n        };\n\n        for (let k = 0; k < MaxNodesInBlock; k++) {\n          stats.histo[k] = 0;\n        }\n\n        for (let i = 0; i < block.childCount; i++) {\n          const child = block.children[i];\n          let height = 1;\n\n          if (!child.isLeaf()) {\n            const childStats = nodeGetStats(child);\n            height = 1 + childStats.maxHeight;\n            stats.nodeCount += childStats.nodeCount;\n            stats.leafCount += childStats.leafCount;\n            stats.removedLeafCount += childStats.removedLeafCount;\n            stats.liveCount += childStats.liveCount;\n\n            for (let j = 0; j < MaxNodesInBlock; j++) {\n              stats.histo[j] += childStats.histo[j];\n            }\n          } else {\n            stats.leafCount++;\n            const segment = child;\n\n            if (segment.removedSeq !== undefined) {\n              stats.removedLeafCount++;\n            }\n          }\n\n          if (height > stats.maxHeight) {\n            stats.maxHeight = height;\n          }\n        }\n\n        stats.histo[block.childCount]++;\n        stats.nodeCount++;\n        stats.liveCount += block.childCount;\n        return stats;\n      };\n\n      const rootStats = nodeGetStats(this.root);\n      return rootStats;\n    }\n\n    getLength(refSeq, clientId) {\n      return this.blockLength(this.root, refSeq, clientId);\n    }\n    /**\n     * Returns the current length of the MergeTree for the local client.\n     */\n\n\n    get length() {\n      return this.root.cachedLength;\n    }\n\n    getPosition(node, refSeq, clientId) {\n      var _a;\n\n      let totalOffset = 0;\n      let parent = node.parent;\n      let prevParent;\n\n      while (parent) {\n        const children = parent.children;\n\n        for (let childIndex = 0; childIndex < parent.childCount; childIndex++) {\n          const child = children[childIndex];\n\n          if (prevParent && child === prevParent || child === node) {\n            break;\n          }\n\n          totalOffset += (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;\n        }\n\n        prevParent = parent;\n        parent = parent.parent;\n      }\n\n      return totalOffset;\n    }\n\n    getContainingSegment(pos, refSeq, clientId) {\n      let segment;\n      let offset;\n\n      const leaf = (leafSeg, segpos, _refSeq, _clientId, start) => {\n        segment = leafSeg;\n        offset = start;\n        return false;\n      };\n\n      this.searchBlock(this.root, pos, 0, refSeq, clientId, {\n        leaf\n      }, undefined);\n      return {\n        segment,\n        offset\n      };\n    }\n    /**\n     * @internal must only be used by client\n     * @param segoff - The segment and offset to slide from\n     * @returns The segment and offset to slide to\n     */\n\n\n    _getSlideToSegment(segoff) {\n      if (!segoff.segment || !isRemovedAndAcked(segoff.segment)) {\n        return segoff;\n      }\n\n      let slideToSegment;\n\n      const goFurtherToFindSlideToSegment = seg => {\n        if (seg.seq !== UnassignedSequenceNumber && !isRemovedAndAcked(seg)) {\n          slideToSegment = seg;\n          return false;\n        }\n\n        return true;\n      }; // Slide to the next farthest valid segment in the tree.\n\n\n      this.rightExcursion(segoff.segment, goFurtherToFindSlideToSegment);\n\n      if (slideToSegment) {\n        return {\n          segment: slideToSegment,\n          offset: 0\n        };\n      } // If no such segment is found, slide to the last valid segment.\n\n\n      this.leftExcursion(segoff.segment, goFurtherToFindSlideToSegment); // Workaround TypeScript issue (https://github.com/microsoft/TypeScript/issues/9998)\n\n      slideToSegment = slideToSegment;\n\n      if (slideToSegment) {\n        // If slid nearer then offset should be at the end of the segment\n        return {\n          segment: slideToSegment,\n          offset: slideToSegment.cachedLength - 1\n        };\n      }\n\n      return {\n        segment: undefined,\n        offset: 0\n      };\n    }\n    /**\n     * This method should only be called when the current client sequence number is\n     * max(remove segment sequence number, add reference sequence number).\n     * Otherwise eventual consistency is not guaranteed.\n     * See `packages\\dds\\merge-tree\\REFERENCEPOSITIONS.md`\n     */\n\n\n    slideReferences(segment, refsToSlide) {\n      var _a, _b, _c, _d, _e;\n\n      assert(isRemovedAndAcked(segment), 0x2f1\n      /* slideReferences from a segment which has not been removed and acked */\n      );\n      assert(!!segment.localRefs, 0x2f2\n      /* Ref not in the segment localRefs */\n      );\n\n      const newSegoff = this._getSlideToSegment({\n        segment,\n        offset: 0\n      });\n\n      const newSegment = newSegoff.segment;\n\n      if (newSegment && !newSegment.localRefs) {\n        newSegment.localRefs = new LocalReferenceCollection(newSegment);\n      }\n\n      for (const ref of refsToSlide) {\n        (_b = (_a = ref.callbacks) === null || _a === void 0 ? void 0 : _a.beforeSlide) === null || _b === void 0 ? void 0 : _b.call(_a);\n        const removedRef = segment.localRefs.removeLocalRef(ref);\n        assert(ref === removedRef, 0x2f3\n        /* Ref not in the segment localRefs */\n        );\n\n        if (!newSegment) {\n          // No valid segments (all nodes removed or not yet created)\n          ref.segment = undefined;\n          ref.offset = 0;\n        } else {\n          ref.segment = newSegment;\n          ref.offset = (_c = newSegoff.offset) !== null && _c !== void 0 ? _c : 0;\n          assert(!!newSegment.localRefs, 0x2f4\n          /* localRefs must be allocated */\n          );\n          newSegment.localRefs.addLocalRef(ref);\n        }\n\n        (_e = (_d = ref.callbacks) === null || _d === void 0 ? void 0 : _d.afterSlide) === null || _e === void 0 ? void 0 : _e.call(_d);\n      } // TODO is it required to update the path lengths?\n\n\n      if (newSegment) {\n        this.blockUpdatePathLengths(newSegment.parent, TreeMaintenanceSequenceNumber, LocalClientId);\n      }\n    }\n\n    updateSegmentRefsAfterMarkRemoved(segment, pending) {\n      if (!segment.localRefs || segment.localRefs.empty) {\n        return;\n      }\n\n      const refsToSlide = [];\n      const refsToStay = [];\n\n      for (const lref of segment.localRefs) {\n        if (refTypeIncludesFlag(lref, ReferenceType.StayOnRemove)) {\n          refsToStay.push(lref);\n        } else if (refTypeIncludesFlag(lref, ReferenceType.SlideOnRemove)) {\n          if (pending) {\n            refsToStay.push(lref);\n          } else {\n            refsToSlide.push(lref);\n          }\n        }\n      } // Rethink implementation of keeping and sliding refs once other reference\n      // changes are complete. This works but is fragile and possibly slow.\n\n\n      if (!pending) {\n        this.slideReferences(segment, refsToSlide);\n      }\n\n      segment.localRefs.clear();\n\n      for (const lref of refsToStay) {\n        lref.segment = segment;\n        segment.localRefs.addLocalRef(lref);\n      }\n    }\n\n    blockLength(node, refSeq, clientId) {\n      if (this.collabWindow.collaborating && clientId !== this.collabWindow.clientId) {\n        return node.partialLengths.getPartialLength(refSeq, clientId);\n      } else {\n        return node.cachedLength;\n      }\n    }\n\n    nodeLength(node, refSeq, clientId) {\n      if (!this.collabWindow.collaborating || this.collabWindow.clientId === clientId) {\n        // Local client sees all segments, even when collaborating\n        if (!node.isLeaf()) {\n          return node.cachedLength;\n        } else {\n          return this.localNetLength(node);\n        }\n      } else {\n        // Sequence number within window\n        if (!node.isLeaf()) {\n          return node.partialLengths.getPartialLength(refSeq, clientId);\n        } else {\n          const segment = node;\n          const removalInfo = toRemovalInfo(segment);\n\n          if (removalInfo !== undefined && removalInfo.removedSeq !== UnassignedSequenceNumber && removalInfo.removedSeq <= refSeq) {\n            // this segment is a tombstone eligible for zamboni\n            // so should never be considered, as it may not exist\n            // on other clients\n            return undefined;\n          }\n\n          if (segment.clientId === clientId || segment.seq !== UnassignedSequenceNumber && segment.seq <= refSeq) {\n            // Segment happened by reference sequence number or segment from requesting client\n            if (removalInfo !== undefined) {\n              if (removalInfo.removedClientIds.includes(clientId)) {\n                return 0;\n              } else {\n                return segment.cachedLength;\n              }\n            } else {\n              return segment.cachedLength;\n            }\n          } else {\n            // the segment was inserted and removed before the\n            // this context, so it will never exist for this\n            // context\n            if (removalInfo !== undefined && removalInfo.removedSeq !== UnassignedSequenceNumber) {\n              return undefined;\n            } // Segment invisible to client at reference sequence number/branch id/client id of op\n\n\n            return 0;\n          }\n        }\n      }\n    }\n\n    addMinSeqListener(minRequired, onMinGE) {\n      if (!this.minSeqListeners) {\n        this.minSeqListeners = new Heap([], minListenerComparer);\n      }\n\n      this.minSeqListeners.add({\n        minRequired,\n        onMinGE\n      });\n    }\n\n    notifyMinSeqListeners() {\n      if (this.minSeqListeners) {\n        while (this.minSeqListeners.count() > 0 && this.minSeqListeners.peek().minRequired <= this.collabWindow.minSeq) {\n          const minListener = this.minSeqListeners.get();\n          minListener.onMinGE(this.collabWindow.minSeq);\n        }\n      }\n    }\n\n    setMinSeq(minSeq) {\n      assert(minSeq <= this.collabWindow.currentSeq, 0x04e); // Only move forward\n\n      assert(this.collabWindow.minSeq <= minSeq, 0x04f\n      /* \"minSeq of collab window > target minSeq!\" */\n      );\n\n      if (minSeq > this.collabWindow.minSeq) {\n        this.collabWindow.minSeq = minSeq;\n\n        if (MergeTree.options.zamboniSegments) {\n          this.zamboniSegments();\n        }\n\n        this.notifyMinSeqListeners();\n      }\n    }\n\n    referencePositionToLocalPosition(refPos, refSeq = this.collabWindow.currentSeq, clientId = this.collabWindow.clientId) {\n      const seg = refPos.getSegment();\n\n      if (seg && seg.parent) {\n        const offset = !seg.removedSeq ? refPos.getOffset() : 0;\n        return offset + this.getPosition(seg, refSeq, clientId);\n      }\n\n      return LocalReference.DetachedPosition;\n    }\n\n    getStackContext(startPos, clientId, rangeLabels) {\n      const searchInfo = {\n        mergeTree: this,\n        stacks: createMap(),\n        rangeLabels\n      };\n      this.search(startPos, UniversalSequenceNumber, clientId, {\n        leaf: recordRangeLeaf,\n        shift: rangeShift\n      }, searchInfo);\n      return searchInfo.stacks;\n    } // TODO: filter function\n\n\n    findTile(startPos, clientId, tileLabel, posPrecedesTile = true) {\n      const searchInfo = {\n        mergeTree: this,\n        posPrecedesTile,\n        tileLabel\n      };\n\n      if (posPrecedesTile) {\n        this.search(startPos, UniversalSequenceNumber, clientId, {\n          leaf: recordTileStart,\n          shift: tileShift\n        }, searchInfo);\n      } else {\n        this.backwardSearch(startPos, UniversalSequenceNumber, clientId, {\n          leaf: recordTileStart,\n          shift: tileShift\n        }, searchInfo);\n      }\n\n      if (searchInfo.tile) {\n        let pos;\n\n        if (searchInfo.tile.isLeaf()) {\n          const marker = searchInfo.tile;\n          pos = this.getPosition(marker, UniversalSequenceNumber, clientId);\n        } else {\n          const localRef = searchInfo.tile;\n          pos = localRef.toPosition();\n        }\n\n        return {\n          tile: searchInfo.tile,\n          pos\n        };\n      }\n    }\n\n    search(pos, refSeq, clientId, actions, clientData) {\n      return this.searchBlock(this.root, pos, 0, refSeq, clientId, actions, clientData);\n    }\n\n    searchBlock(block, pos, segpos, refSeq, clientId, actions, clientData) {\n      var _a;\n\n      let _pos = pos;\n      let _segpos = segpos;\n      const children = block.children;\n\n      if (actions && actions.pre) {\n        actions.pre(block, _segpos, refSeq, clientId, undefined, undefined, clientData);\n      }\n\n      const contains = actions && actions.contains;\n\n      for (let childIndex = 0; childIndex < block.childCount; childIndex++) {\n        const child = children[childIndex];\n        const len = (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;\n\n        if (!contains && _pos < len || contains && contains(child, _pos, refSeq, clientId, undefined, undefined, clientData)) {\n          // Found entry containing pos\n          if (!child.isLeaf()) {\n            return this.searchBlock(child, _pos, _segpos, refSeq, clientId, actions, clientData);\n          } else {\n            if (actions && actions.leaf) {\n              actions.leaf(child, _segpos, refSeq, clientId, _pos, -1, clientData);\n            }\n\n            return child;\n          }\n        } else {\n          if (actions && actions.shift) {\n            actions.shift(child, _segpos, refSeq, clientId, _pos, undefined, clientData);\n          }\n\n          _pos -= len;\n          _segpos += len;\n        }\n      }\n\n      if (actions && actions.post) {\n        actions.post(block, _segpos, refSeq, clientId, undefined, undefined, clientData);\n      }\n    }\n\n    backwardSearch(pos, refSeq, clientId, actions, clientData) {\n      const len = this.getLength(refSeq, clientId);\n\n      if (pos > len) {\n        return undefined;\n      }\n\n      return this.backwardSearchBlock(this.root, pos, len, refSeq, clientId, actions, clientData);\n    }\n\n    backwardSearchBlock(block, pos, segEnd, refSeq, clientId, actions, clientData) {\n      var _a;\n\n      let _segEnd = segEnd;\n      const children = block.children;\n\n      if (actions && actions.pre) {\n        actions.pre(block, _segEnd, refSeq, clientId, undefined, undefined, clientData);\n      }\n\n      const contains = actions && actions.contains;\n\n      for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {\n        const child = children[childIndex];\n        const len = (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;\n        const segpos = _segEnd - len;\n\n        if (!contains && pos >= segpos || contains && contains(child, pos, refSeq, clientId, undefined, undefined, clientData)) {\n          // Found entry containing pos\n          if (!child.isLeaf()) {\n            return this.backwardSearchBlock(child, pos, _segEnd, refSeq, clientId, actions, clientData);\n          } else {\n            if (actions && actions.leaf) {\n              actions.leaf(child, segpos, refSeq, clientId, pos, -1, clientData);\n            }\n\n            return child;\n          }\n        } else {\n          if (actions && actions.shift) {\n            actions.shift(child, segpos, refSeq, clientId, pos, undefined, clientData);\n          }\n\n          _segEnd = segpos;\n        }\n      }\n\n      if (actions && actions.post) {\n        actions.post(block, _segEnd, refSeq, clientId, undefined, undefined, clientData);\n      }\n    }\n\n    updateRoot(splitNode) {\n      if (splitNode !== undefined) {\n        const newRoot = this.makeBlock(2);\n        newRoot.assignChild(this.root, 0, false);\n        newRoot.assignChild(splitNode, 1, false);\n        this.root = newRoot;\n        this.nodeUpdateOrdinals(this.root);\n        this.nodeUpdateLengthNewStructure(this.root);\n      }\n    }\n    /**\n     * Assign sequence number to existing segment; update partial lengths to reflect the change\n     * @param seq - sequence number given by server to pending segment\n     */\n\n\n    ackPendingSegment(opArgs) {\n      const seq = opArgs.sequencedMessage.sequenceNumber;\n      const pendingSegmentGroup = this.pendingSegments.dequeue();\n      const nodesToUpdate = [];\n      let overwrite = false;\n\n      if (pendingSegmentGroup !== undefined) {\n        const deltaSegments = [];\n        pendingSegmentGroup.segments.map(pendingSegment => {\n          const overlappingRemove = !pendingSegment.ack(pendingSegmentGroup, opArgs, this);\n          overwrite = overlappingRemove || overwrite;\n\n          if (!overlappingRemove && opArgs.op.type === MergeTreeDeltaType.REMOVE) {\n            this.updateSegmentRefsAfterMarkRemoved(pendingSegment, false);\n          }\n\n          if (MergeTree.options.zamboniSegments) {\n            this.addToLRUSet(pendingSegment, seq);\n          }\n\n          if (!nodesToUpdate.includes(pendingSegment.parent)) {\n            nodesToUpdate.push(pendingSegment.parent);\n          }\n\n          deltaSegments.push({\n            segment: pendingSegment\n          });\n        });\n\n        if (this.mergeTreeMaintenanceCallback) {\n          this.mergeTreeMaintenanceCallback({\n            deltaSegments,\n            operation: MergeTreeMaintenanceType.ACKNOWLEDGED\n          }, opArgs);\n        }\n\n        const clientId = this.collabWindow.clientId;\n\n        for (const node of nodesToUpdate) {\n          this.blockUpdatePathLengths(node, seq, clientId, overwrite); // NodeUpdatePathLengths(node, seq, clientId, true);\n        }\n      }\n\n      if (MergeTree.options.zamboniSegments) {\n        this.zamboniSegments();\n      }\n    }\n\n    addToPendingList(segment, segmentGroup, localSeq) {\n      let _segmentGroup = segmentGroup;\n\n      if (_segmentGroup === undefined) {\n        // TODO: review the cast\n        _segmentGroup = {\n          segments: [],\n          localSeq\n        };\n        this.pendingSegments.enqueue(_segmentGroup);\n      }\n\n      segment.segmentGroups.enqueue(_segmentGroup);\n      return _segmentGroup;\n    } // TODO: error checking\n\n\n    getMarkerFromId(id) {\n      return this.idToSegment.get(id);\n    }\n    /**\n     * Given a position specified relative to a marker id, lookup the marker\n     * and convert the position to a character position.\n     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.\n     * @param refseq - The reference sequence number at which to compute the position.\n     * @param clientId - The client id with which to compute the position.\n     */\n\n\n    posFromRelativePos(relativePos, refseq = this.collabWindow.currentSeq, clientId = this.collabWindow.clientId) {\n      let pos = -1;\n      let marker;\n\n      if (relativePos.id) {\n        marker = this.getMarkerFromId(relativePos.id);\n      }\n\n      if (marker) {\n        pos = this.getPosition(marker, refseq, clientId);\n\n        if (!relativePos.before) {\n          pos += marker.cachedLength;\n\n          if (relativePos.offset !== undefined) {\n            pos += relativePos.offset;\n          }\n        } else {\n          if (relativePos.offset !== undefined) {\n            pos -= relativePos.offset;\n          }\n        }\n      }\n\n      return pos;\n    }\n\n    insertSegments(pos, segments, refSeq, clientId, seq, opArgs) {\n      this.ensureIntervalBoundary(pos, refSeq, clientId);\n      const localSeq = seq === UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;\n      this.blockInsert(pos, refSeq, clientId, seq, localSeq, segments); // opArgs == undefined => loading snapshot or test code\n\n      if (this.mergeTreeDeltaCallback && opArgs !== undefined) {\n        this.mergeTreeDeltaCallback(opArgs, {\n          operation: MergeTreeDeltaType.INSERT,\n          deltaSegments: segments.map(segment => ({\n            segment\n          }))\n        });\n      }\n\n      if (this.collabWindow.collaborating && MergeTree.options.zamboniSegments && seq !== UnassignedSequenceNumber) {\n        this.zamboniSegments();\n      }\n    }\n\n    insertAtReferencePosition(referencePosition, insertSegment, opArgs) {\n      if (insertSegment.cachedLength === 0) {\n        return;\n      }\n\n      if (insertSegment.parent || insertSegment.removedSeq || insertSegment.seq !== UniversalSequenceNumber) {\n        throw new Error(\"Cannot insert segment that has already been inserted.\");\n      }\n\n      const rebalanceTree = segment => {\n        // Blocks should never be left full\n        // if the inserts makes the block full\n        // then we need to walk up the chain of parents\n        // and split the blocks until we find a block with\n        // room\n        let block = segment.parent;\n        let ordinalUpdateNode = block;\n\n        while (block !== undefined) {\n          if (block.childCount >= MaxNodesInBlock) {\n            const splitNode = this.split(block);\n\n            if (block === this.root) {\n              this.updateRoot(splitNode); // Update root already updates all it's children ordinals\n\n              ordinalUpdateNode = undefined;\n            } else {\n              this.insertChildNode(block.parent, splitNode, block.index + 1);\n              ordinalUpdateNode = splitNode.parent;\n              this.blockUpdateLength(block.parent, UnassignedSequenceNumber, clientId);\n            }\n          } else {\n            this.blockUpdateLength(block, UnassignedSequenceNumber, clientId);\n          }\n\n          block = block.parent;\n        } // Only update ordinals once, for all children,\n        // on the path\n\n\n        if (ordinalUpdateNode) {\n          this.nodeUpdateOrdinals(ordinalUpdateNode);\n        }\n      };\n\n      const clientId = this.collabWindow.clientId;\n      const refSegment = referencePosition.getSegment();\n      const refOffset = referencePosition.getOffset();\n      const refSegLen = this.nodeLength(refSegment, this.collabWindow.currentSeq, clientId);\n      let startSeg = refSegment; // if the change isn't at a boundary, we need to split the segment\n\n      if (refOffset !== 0 && refSegLen !== undefined && refSegLen !== 0) {\n        const splitSeg = this.splitLeafSegment(refSegment, refOffset);\n        assert(!!splitSeg.next, 0x050\n        /* \"Next segment changes are undefined!\" */\n        );\n        this.insertChildNode(refSegment.parent, splitSeg.next, refSegment.index + 1);\n        rebalanceTree(splitSeg.next);\n        startSeg = splitSeg.next;\n      } // walk back from the segment, to see if there is a previous tie break seg\n\n\n      this.leftExcursion(startSeg, backSeg => {\n        if (!backSeg.isLeaf()) {\n          return true;\n        }\n\n        const backLen = this.nodeLength(backSeg, this.collabWindow.currentSeq, clientId); // ignore removed segments\n\n        if (backLen === undefined) {\n          return true;\n        } // Find the nearest 0 length seg we can insert over, as all other inserts\n        // go near to far\n\n\n        if (backLen === 0) {\n          if (this.breakTie(0, backSeg, UnassignedSequenceNumber)) {\n            startSeg = backSeg;\n          }\n\n          return true;\n        }\n\n        return false;\n      });\n\n      if (this.collabWindow.collaborating) {\n        insertSegment.localSeq = ++this.collabWindow.localSeq;\n        insertSegment.seq = UnassignedSequenceNumber;\n      } else {\n        insertSegment.seq = UniversalSequenceNumber;\n      }\n\n      insertSegment.clientId = clientId;\n\n      if (Marker.is(insertSegment)) {\n        const markerId = insertSegment.getId();\n\n        if (markerId) {\n          this.mapIdToSegment(markerId, insertSegment);\n        }\n      }\n\n      this.insertChildNode(startSeg.parent, insertSegment, startSeg.index);\n      rebalanceTree(insertSegment);\n\n      if (this.mergeTreeDeltaCallback) {\n        this.mergeTreeDeltaCallback(opArgs, {\n          deltaSegments: [{\n            segment: insertSegment\n          }],\n          operation: MergeTreeDeltaType.INSERT\n        });\n      }\n\n      if (this.collabWindow.collaborating) {\n        this.addToPendingList(insertSegment, undefined, insertSegment.localSeq);\n      }\n    }\n    /**\n     * Resolves a remote client's position against the local sequence\n     * and returns the remote client's position relative to the local\n     * sequence. The client ref seq must be above the minimum sequence number\n     * or the return value will be undefined.\n     * Generally this method is used in conjunction with signals which provide\n     * point in time values for the below parameters, and is useful for things\n     * like displaying user position. It should not be used with persisted values\n     * as persisted values will quickly become invalid as the remoteClientRefSeq\n     * moves below the minimum sequence number\n     * @param remoteClientPosition - The remote client's position to resolve\n     * @param remoteClientRefSeq - The reference sequence number of the remote client\n     * @param remoteClientId - The client id of the remote client\n     */\n\n\n    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {\n      if (remoteClientRefSeq < this.collabWindow.minSeq) {\n        return undefined;\n      }\n\n      const segmentInfo = this.getContainingSegment(remoteClientPosition, remoteClientRefSeq, remoteClientId);\n      const segwindow = this.getCollabWindow();\n\n      if (segmentInfo && segmentInfo.segment) {\n        const segmentPosition = this.getPosition(segmentInfo.segment, segwindow.currentSeq, segwindow.clientId);\n        return segmentPosition + segmentInfo.offset;\n      } else {\n        if (remoteClientPosition === this.getLength(remoteClientRefSeq, remoteClientId)) {\n          return this.getLength(segwindow.currentSeq, segwindow.clientId);\n        }\n      }\n    }\n\n    insertChildNode(block, child, childIndex) {\n      assert(block.childCount < MaxNodesInBlock, 0x051\n      /* \"Too many children on merge block!\" */\n      );\n\n      for (let i = block.childCount; i > childIndex; i--) {\n        block.children[i] = block.children[i - 1];\n        block.children[i].index = i;\n      }\n\n      block.childCount++;\n      block.assignChild(child, childIndex, false);\n    }\n\n    blockInsert(pos, refSeq, clientId, seq, localSeq, newSegments) {\n      let segIsLocal = false;\n\n      const checkSegmentIsLocal = segment => {\n        if (segment.seq === UnassignedSequenceNumber) {\n          segIsLocal = true;\n        } // Only need to look at first segment that follows finished node\n\n\n        return false;\n      };\n\n      const continueFrom = node => {\n        segIsLocal = false;\n        this.rightExcursion(node, checkSegmentIsLocal);\n        return segIsLocal;\n      };\n\n      let segmentGroup;\n\n      const saveIfLocal = locSegment => {\n        // Save segment so can assign sequence number when acked by server\n        if (this.collabWindow.collaborating) {\n          if (locSegment.seq === UnassignedSequenceNumber && clientId === this.collabWindow.clientId) {\n            segmentGroup = this.addToPendingList(locSegment, segmentGroup, localSeq); // eslint-disable-next-line @typescript-eslint/brace-style\n          } // LocSegment.seq === 0 when coming from SharedSegmentSequence.loadBody()\n          // In all other cases this has to be true (checked by addToLRUSet):\n          // locSegment.seq > this.collabWindow.currentSeq\n          else if (locSegment.seq > this.collabWindow.minSeq && MergeTree.options.zamboniSegments) {\n            this.addToLRUSet(locSegment, locSegment.seq);\n          }\n        }\n      };\n\n      const onLeaf = (segment, _pos, context) => {\n        const segmentChanges = {};\n\n        if (segment) {\n          // Insert before segment\n          segmentChanges.replaceCurrent = context.candidateSegment;\n          segmentChanges.next = segment;\n        } else {\n          segmentChanges.next = context.candidateSegment;\n        }\n\n        return segmentChanges;\n      }; // TODO: build tree from segs and insert all at once\n\n\n      let insertPos = pos;\n\n      for (const newSegment of newSegments) {\n        segIsLocal = false;\n\n        if (newSegment.cachedLength > 0) {\n          newSegment.seq = seq;\n          newSegment.localSeq = localSeq;\n          newSegment.clientId = clientId;\n\n          if (Marker.is(newSegment)) {\n            const markerId = newSegment.getId();\n\n            if (markerId) {\n              this.mapIdToSegment(markerId, newSegment);\n            }\n          }\n\n          const splitNode = this.insertingWalk(this.root, insertPos, refSeq, clientId, seq, {\n            leaf: onLeaf,\n            candidateSegment: newSegment,\n            continuePredicate: continueFrom\n          });\n\n          if (newSegment.parent === undefined) {\n            throw new Error(`MergeTree insert failed: ${JSON.stringify({\n              currentSeq: this.collabWindow.currentSeq,\n              minSeq: this.collabWindow.minSeq,\n              segSeq: newSegment.seq\n            })}`);\n          }\n\n          this.updateRoot(splitNode);\n          saveIfLocal(newSegment);\n          insertPos += newSegment.cachedLength;\n        }\n      }\n    }\n\n    ensureIntervalBoundary(pos, refSeq, clientId) {\n      const splitNode = this.insertingWalk(this.root, pos, refSeq, clientId, TreeMaintenanceSequenceNumber, {\n        leaf: this.splitLeafSegment\n      });\n      this.updateRoot(splitNode);\n    } // Assume called only when pos == len\n\n\n    breakTie(pos, node, seq) {\n      var _a;\n\n      if (node.isLeaf()) {\n        if (pos === 0) {\n          // normalize the seq numbers\n          // if the new seg is local (UnassignedSequenceNumber) give it the highest possible\n          // seq for comparison, as it will get a seq higher than any other seq once sequences\n          // if the current seg is local (UnassignedSequenceNumber) give it the second highest\n          // possible seq, as the highest is reserved for the previous.\n          const newSeq = seq === UnassignedSequenceNumber ? Number.MAX_SAFE_INTEGER : seq;\n          const segSeq = node.seq === UnassignedSequenceNumber ? Number.MAX_SAFE_INTEGER - 1 : (_a = node.seq) !== null && _a !== void 0 ? _a : 0;\n          return newSeq > segSeq;\n        }\n\n        return false;\n      } else {\n        return true;\n      }\n    } // Visit segments starting from node's left siblings, then up to node's parent\n\n\n    leftExcursion(node, leafAction) {\n      let go = true;\n      let startNode = node;\n      let parent = startNode.parent;\n\n      while (parent) {\n        const children = parent.children;\n        let childIndex;\n\n        let _node;\n\n        let matchedStart = false;\n\n        for (childIndex = parent.childCount - 1; childIndex >= 0; childIndex--) {\n          _node = children[childIndex];\n\n          if (matchedStart) {\n            if (!_node.isLeaf()) {\n              const childBlock = _node;\n              go = this.nodeMapReverse(childBlock, leafAction, 0, UniversalSequenceNumber, this.collabWindow.clientId);\n            } else {\n              go = leafAction(_node, 0, UniversalSequenceNumber, this.collabWindow.clientId, 0, 0, undefined);\n            }\n\n            if (!go) {\n              return;\n            }\n          } else {\n            matchedStart = startNode === _node;\n          }\n        }\n\n        startNode = parent;\n        parent = parent.parent;\n      }\n    }\n    /**\n     * Visit segments starting from node's right siblings, then up to node's parent.\n     * All segments past `node` are visited, regardless of their visibility.\n     */\n\n\n    rightExcursion(node, leafAction) {\n      let go = true;\n      let startNode = node;\n      let parent = startNode.parent;\n\n      while (parent) {\n        const children = parent.children;\n        let childIndex;\n\n        let _node;\n\n        let matchedStart = false;\n\n        for (childIndex = 0; childIndex < parent.childCount; childIndex++) {\n          _node = children[childIndex];\n\n          if (matchedStart) {\n            if (!_node.isLeaf()) {\n              const childBlock = _node;\n              go = this.walkAllSegments(childBlock, leafAction);\n            } else {\n              go = leafAction(_node);\n            }\n\n            if (!go) {\n              return;\n            }\n          } else {\n            matchedStart = startNode === _node;\n          }\n        }\n\n        startNode = parent;\n        parent = parent.parent;\n      }\n    }\n\n    insertingWalk(block, pos, refSeq, clientId, seq, context) {\n      let _pos = pos;\n      const children = block.children;\n      let childIndex;\n      let child;\n      let newNode;\n      let fromSplit;\n\n      for (childIndex = 0; childIndex < block.childCount; childIndex++) {\n        child = children[childIndex];\n        const len = this.nodeLength(child, refSeq, clientId);\n\n        if (len === undefined) {\n          // if the seg len in undefined, the segment\n          // will be removed, so should just be skipped for now\n          continue;\n        }\n\n        if (_pos < len || _pos === len && this.breakTie(_pos, child, seq)) {\n          // Found entry containing pos\n          if (!child.isLeaf()) {\n            const childBlock = child; // Internal node\n\n            const splitNode = this.insertingWalk(childBlock, _pos, refSeq, clientId, seq, context);\n\n            if (splitNode === undefined) {\n              if (context.structureChange) {\n                this.nodeUpdateLengthNewStructure(block);\n              } else {\n                this.blockUpdateLength(block, seq, clientId);\n              }\n\n              return undefined;\n            } else if (splitNode === MergeTree.theUnfinishedNode) {\n              _pos -= len; // Act as if shifted segment\n\n              continue;\n            } else {\n              newNode = splitNode;\n              fromSplit = splitNode;\n              childIndex++; // Insert after\n            }\n          } else {\n            const segment = child;\n            const segmentChanges = context.leaf(segment, _pos, context);\n\n            if (segmentChanges.replaceCurrent) {\n              block.assignChild(segmentChanges.replaceCurrent, childIndex, false);\n              segmentChanges.replaceCurrent.ordinal = child.ordinal;\n            }\n\n            if (segmentChanges.next) {\n              newNode = segmentChanges.next;\n              childIndex++; // Insert after\n            } else {\n              // No change\n              if (context.structureChange) {\n                this.nodeUpdateLengthNewStructure(block);\n              }\n\n              return undefined;\n            }\n          }\n\n          break;\n        } else {\n          _pos -= len;\n        }\n      }\n\n      if (!newNode) {\n        if (_pos === 0) {\n          if (seq !== UnassignedSequenceNumber && context.continuePredicate && context.continuePredicate(block)) {\n            return MergeTree.theUnfinishedNode;\n          } else {\n            const segmentChanges = context.leaf(undefined, _pos, context);\n            newNode = segmentChanges.next; // Assert segmentChanges.replaceCurrent === undefined\n          }\n        }\n      }\n\n      if (newNode) {\n        for (let i = block.childCount; i > childIndex; i--) {\n          block.children[i] = block.children[i - 1];\n          block.children[i].index = i;\n        }\n\n        block.assignChild(newNode, childIndex, false);\n        block.childCount++;\n        block.setOrdinal(newNode, childIndex);\n\n        if (block.childCount < MaxNodesInBlock) {\n          if (fromSplit) {\n            this.nodeUpdateOrdinals(fromSplit);\n          }\n\n          if (context.structureChange) {\n            this.nodeUpdateLengthNewStructure(block);\n          } else {\n            this.blockUpdateLength(block, seq, clientId);\n          }\n\n          return undefined;\n        } else {\n          // Don't update ordinals because higher block will do it\n          return this.split(block);\n        }\n      } else {\n        return undefined;\n      }\n    }\n\n    split(node) {\n      const halfCount = MaxNodesInBlock / 2;\n      const newNode = this.makeBlock(halfCount);\n      node.childCount = halfCount; // Update ordinals to reflect lowered child count\n\n      this.nodeUpdateOrdinals(node);\n\n      for (let i = 0; i < halfCount; i++) {\n        newNode.assignChild(node.children[halfCount + i], i, false);\n        node.children[halfCount + i] = undefined;\n      }\n\n      this.nodeUpdateLengthNewStructure(node);\n      this.nodeUpdateLengthNewStructure(newNode);\n      return newNode;\n    }\n\n    nodeUpdateOrdinals(block) {\n      for (let i = 0; i < block.childCount; i++) {\n        const child = block.children[i];\n        block.setOrdinal(child, i);\n\n        if (!child.isLeaf()) {\n          this.nodeUpdateOrdinals(child);\n        }\n      }\n    }\n    /**\n     * Annotate a range with properties\n     * @param start - The inclusive start position of the range to annotate\n     * @param end - The exclusive end position of the range to annotate\n     * @param props - The properties to annotate the range with\n     * @param combiningOp - Optional. Specifies how to combine values for the property, such as \"incr\" for increment.\n     * @param refSeq - The reference sequence number to use to apply the annotate\n     * @param clientId - The id of the client making the annotate\n     * @param seq - The sequence number of the annotate operation\n     * @param opArgs - The op args for the annotate op. this is passed to the merge tree callback if there is one\n     */\n\n\n    annotateRange(start, end, props, combiningOp, refSeq, clientId, seq, opArgs) {\n      this.ensureIntervalBoundary(start, refSeq, clientId);\n      this.ensureIntervalBoundary(end, refSeq, clientId);\n      const deltaSegments = [];\n      const localSeq = seq === UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;\n      let segmentGroup;\n\n      const annotateSegment = segment => {\n        const propertyDeltas = segment.addProperties(props, combiningOp, seq, this.collabWindow);\n        deltaSegments.push({\n          segment,\n          propertyDeltas\n        });\n\n        if (this.collabWindow.collaborating) {\n          if (seq === UnassignedSequenceNumber) {\n            segmentGroup = this.addToPendingList(segment, segmentGroup, localSeq);\n          } else {\n            if (MergeTree.options.zamboniSegments) {\n              this.addToLRUSet(segment, seq);\n            }\n          }\n        }\n\n        return true;\n      };\n\n      this.mapRange({\n        leaf: annotateSegment\n      }, refSeq, clientId, undefined, start, end); // OpArgs == undefined => test code\n\n      if (this.mergeTreeDeltaCallback && deltaSegments.length > 0) {\n        this.mergeTreeDeltaCallback(opArgs, {\n          operation: MergeTreeDeltaType.ANNOTATE,\n          deltaSegments\n        });\n      }\n\n      if (this.collabWindow.collaborating && seq !== UnassignedSequenceNumber) {\n        if (MergeTree.options.zamboniSegments) {\n          this.zamboniSegments();\n        }\n      }\n    }\n\n    markRangeRemoved(start, end, refSeq, clientId, seq, overwrite = false, opArgs) {\n      let _overwrite = overwrite;\n      this.ensureIntervalBoundary(start, refSeq, clientId);\n      this.ensureIntervalBoundary(end, refSeq, clientId);\n      let segmentGroup;\n      const removedSegments = [];\n      const segmentsWithRefs = [];\n      const localSeq = seq === UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;\n\n      const markRemoved = (segment, pos, _start, _end) => {\n        const existingRemovalInfo = toRemovalInfo(segment);\n\n        if (existingRemovalInfo !== undefined) {\n          _overwrite = true;\n\n          if (existingRemovalInfo.removedSeq === UnassignedSequenceNumber) {\n            // we removed this locally, but someone else removed it first\n            // so put them at the head of the list\n            // the list isn't ordered, but we\n            // keep first removal at the head.\n            existingRemovalInfo.removedClientIds.unshift(clientId);\n            existingRemovalInfo.removedSeq = seq;\n            segment.localRemovedSeq = undefined;\n          } else {\n            // Do not replace earlier sequence number for remove\n            existingRemovalInfo.removedClientIds.push(clientId);\n          }\n        } else {\n          segment.removedClientIds = [clientId];\n          segment.removedSeq = seq;\n          segment.localRemovedSeq = localSeq;\n          removedSegments.push({\n            segment\n          });\n        }\n\n        if (segment.localRefs && !segment.localRefs.empty) {\n          segmentsWithRefs.push(segment);\n        } // Save segment so can assign removed sequence number when acked by server\n\n\n        if (this.collabWindow.collaborating) {\n          if (segment.removedSeq === UnassignedSequenceNumber && clientId === this.collabWindow.clientId) {\n            segmentGroup = this.addToPendingList(segment, segmentGroup, localSeq);\n          } else {\n            if (MergeTree.options.zamboniSegments) {\n              this.addToLRUSet(segment, seq);\n            }\n          }\n        }\n\n        return true;\n      };\n\n      const afterMarkRemoved = (node, pos, _start, _end) => {\n        if (_overwrite) {\n          this.nodeUpdateLengthNewStructure(node);\n        } else {\n          this.blockUpdateLength(node, seq, clientId);\n        }\n\n        return true;\n      };\n\n      this.mapRange({\n        leaf: markRemoved,\n        post: afterMarkRemoved\n      }, refSeq, clientId, undefined, start, end);\n      const pending = this.collabWindow.collaborating && clientId === this.collabWindow.clientId;\n\n      for (const segment of segmentsWithRefs) {\n        this.updateSegmentRefsAfterMarkRemoved(segment, pending);\n      } // opArgs == undefined => test code\n\n\n      if (this.mergeTreeDeltaCallback && removedSegments.length > 0) {\n        this.mergeTreeDeltaCallback(opArgs, {\n          operation: MergeTreeDeltaType.REMOVE,\n          deltaSegments: removedSegments\n        });\n      }\n\n      if (this.collabWindow.collaborating && seq !== UnassignedSequenceNumber) {\n        if (MergeTree.options.zamboniSegments) {\n          this.zamboniSegments();\n        }\n      }\n    }\n\n    nodeUpdateLengthNewStructure(node, recur = false) {\n      this.blockUpdate(node);\n\n      if (this.collabWindow.collaborating) {\n        node.partialLengths = PartialSequenceLengths.combine(this, node, this.collabWindow, recur);\n      }\n    }\n\n    removeLocalReferencePosition(lref) {\n      var _a;\n\n      const segment = lref.getSegment();\n\n      if (segment) {\n        const removedRefs = (_a = segment === null || segment === void 0 ? void 0 : segment.localRefs) === null || _a === void 0 ? void 0 : _a.removeLocalRef(lref);\n\n        if (removedRefs !== undefined) {\n          this.blockUpdatePathLengths(segment.parent, TreeMaintenanceSequenceNumber, LocalClientId);\n        }\n\n        return removedRefs;\n      }\n    }\n\n    createLocalReferencePosition(segment, offset, refType, properties, client) {\n      var _a;\n\n      if (isRemoved(segment)) {\n        if (!refTypeIncludesFlag(refType, ReferenceType.SlideOnRemove | ReferenceType.Transient)) {\n          throw new UsageError(\"Can only create SlideOnRemove or Transient local reference position on a removed segment\");\n        }\n      }\n\n      const localRefs = (_a = segment.localRefs) !== null && _a !== void 0 ? _a : new LocalReferenceCollection(segment);\n      segment.localRefs = localRefs;\n      const segRef = localRefs.createLocalRef(offset, refType, properties, client);\n      this.blockUpdatePathLengths(segment.parent, TreeMaintenanceSequenceNumber, LocalClientId);\n      return segRef;\n    }\n    /**\n     * @deprecated - use removeLocalReferencePosition\n     */\n\n\n    removeLocalReference(segment, lref) {\n      if (segment.localRefs) {\n        const removedRef = segment.localRefs.removeLocalRef(lref);\n\n        if (removedRef) {\n          this.blockUpdatePathLengths(segment.parent, TreeMaintenanceSequenceNumber, LocalClientId);\n        }\n      }\n    }\n    /**\n     * @deprecated - use createLocalReference\n     */\n\n\n    addLocalReference(lref) {\n      const segment = lref.segment;\n      let localRefs = segment.localRefs;\n\n      if (!localRefs) {\n        localRefs = new LocalReferenceCollection(segment);\n        segment.localRefs = localRefs;\n      }\n\n      localRefs.addLocalRef(lref);\n      this.blockUpdatePathLengths(segment.parent, TreeMaintenanceSequenceNumber, LocalClientId);\n    }\n\n    blockUpdate(block) {\n      var _a;\n\n      let len = 0;\n      const hierBlock = block.hierBlock();\n\n      if (hierBlock) {\n        hierBlock.rightmostTiles = createMap();\n        hierBlock.leftmostTiles = createMap();\n        hierBlock.rangeStacks = {};\n      }\n\n      for (let i = 0; i < block.childCount; i++) {\n        const child = block.children[i];\n        len += (_a = nodeTotalLength(this, child)) !== null && _a !== void 0 ? _a : 0;\n\n        if (hierBlock) {\n          hierBlock.addNodeReferences(this, child);\n        }\n\n        if (this.blockUpdateActions) {\n          this.blockUpdateActions.child(block, i);\n        }\n      }\n\n      block.cachedLength = len;\n    }\n\n    blockUpdatePathLengths(startBlock, seq, clientId, newStructure = false) {\n      let block = startBlock;\n\n      while (block !== undefined) {\n        if (newStructure) {\n          this.nodeUpdateLengthNewStructure(block);\n        } else {\n          this.blockUpdateLength(block, seq, clientId);\n        }\n\n        block = block.parent;\n      }\n    }\n\n    blockUpdateLength(node, seq, clientId) {\n      this.blockUpdate(node);\n\n      if (this.collabWindow.collaborating && seq !== UnassignedSequenceNumber && seq !== TreeMaintenanceSequenceNumber) {\n        if (node.partialLengths !== undefined && MergeTree.options.incrementalUpdate && clientId !== NonCollabClient) {\n          node.partialLengths.update(this, node, seq, clientId, this.collabWindow);\n        } else {\n          node.partialLengths = PartialSequenceLengths.combine(this, node, this.collabWindow);\n        }\n      }\n    }\n\n    map(actions, refSeq, clientId, accum) {\n      // TODO: optimize to avoid comparisons\n      this.nodeMap(this.root, actions, 0, refSeq, clientId, accum);\n    }\n\n    mapRange(actions, refSeq, clientId, accum, start, end, splitRange = false) {\n      if (splitRange) {\n        if (start) {\n          this.ensureIntervalBoundary(start, refSeq, clientId);\n        }\n\n        if (end) {\n          this.ensureIntervalBoundary(end, refSeq, clientId);\n        }\n      }\n\n      this.nodeMap(this.root, actions, 0, refSeq, clientId, accum, start, end);\n    }\n\n    incrementalBlockMap(stateStack) {\n      var _a;\n\n      while (!stateStack.empty()) {\n        // We already check the stack is not empty\n        const state = stateStack.top();\n\n        if (state.op !== IncrementalExecOp.Go) {\n          return;\n        }\n\n        if (state.childIndex === 0) {\n          if (state.start === undefined) {\n            state.start = 0;\n          }\n\n          if (state.end === undefined) {\n            state.end = this.blockLength(state.block, state.refSeq, state.clientId);\n          }\n\n          if (state.actions.pre) {\n            state.actions.pre(state);\n          }\n        }\n\n        if (state.op === IncrementalExecOp.Go && state.childIndex < state.block.childCount) {\n          const child = state.block.children[state.childIndex];\n          const len = (_a = this.nodeLength(child, state.refSeq, state.clientId)) !== null && _a !== void 0 ? _a : 0;\n\n          if (len > 0 && state.start < len && state.end > 0) {\n            if (!child.isLeaf()) {\n              const childState = new IncrementalMapState(child, state.actions, state.pos, state.refSeq, state.clientId, state.context, state.start, state.end, 0);\n              stateStack.push(childState);\n            } else {\n              state.actions.leaf(child, state);\n            }\n          }\n\n          state.pos += len;\n          state.start -= len;\n          state.end -= len;\n          state.childIndex++;\n        } else {\n          if (state.childIndex === state.block.childCount) {\n            if (state.op === IncrementalExecOp.Go && state.actions.post) {\n              state.actions.post(state);\n            }\n\n            stateStack.pop();\n          }\n        }\n      }\n    }\n\n    nodeMap(node, actions, pos, refSeq, clientId, accum, start, end) {\n      var _a;\n\n      let _start = start;\n      let _end = end;\n      let _pos = pos;\n\n      if (_start === undefined) {\n        _start = 0;\n      }\n\n      if (_end === undefined) {\n        _end = this.blockLength(node, refSeq, clientId);\n      }\n\n      let go = true;\n\n      if (actions.pre) {\n        go = actions.pre(node, _pos, refSeq, clientId, _start, _end, accum);\n\n        if (!go) {\n          // Cancel this node but not entire traversal\n          return true;\n        }\n      }\n\n      const children = node.children;\n\n      for (let childIndex = 0; childIndex < node.childCount; childIndex++) {\n        const child = children[childIndex];\n        const len = (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;\n\n        if (go && _end > 0 && len > 0 && _start < len) {\n          // Found entry containing pos\n          if (!child.isLeaf()) {\n            if (go) {\n              go = this.nodeMap(child, actions, _pos, refSeq, clientId, accum, _start, _end);\n            }\n          } else {\n            if (actions.leaf) {\n              go = actions.leaf(child, _pos, refSeq, clientId, _start, _end, accum);\n            }\n          }\n        }\n\n        if (!go) {\n          break;\n        }\n\n        if (actions.shift) {\n          actions.shift(child, _pos, refSeq, clientId, _start, _end, accum);\n        }\n\n        _pos += len;\n        _start -= len;\n        _end -= len;\n      }\n\n      if (go && actions.post) {\n        go = actions.post(node, _pos, refSeq, clientId, _start, _end, accum);\n      }\n\n      return go;\n    } // Invokes the leaf action for all segments.  Note that *all* segments are visited\n    // regardless of if they would be visible to the current `clientId` and `refSeq`.\n\n\n    walkAllSegments(block, action, accum) {\n      let go = true;\n      const children = block.children;\n\n      for (let childIndex = 0; go && childIndex < block.childCount; childIndex++) {\n        const child = children[childIndex];\n        go = child.isLeaf() ? action(child, accum) : this.walkAllSegments(child, action, accum);\n      }\n\n      return go;\n    } // Straight call every segment; goes until leaf action returns false\n\n\n    nodeMapReverse(block, leafAction, pos, refSeq, clientId) {\n      let go = true;\n      const children = block.children;\n\n      for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {\n        const child = children[childIndex];\n\n        if (go) {\n          // Found entry containing pos\n          if (!child.isLeaf()) {\n            if (go) {\n              go = this.nodeMapReverse(child, leafAction, pos, refSeq, clientId);\n            }\n          } else {\n            go = leafAction(child, pos, refSeq, clientId, 0, 0, undefined);\n          }\n        }\n\n        if (!go) {\n          break;\n        }\n      }\n\n      return go;\n    }\n\n  }\n\n  MergeTree.zamboniSegmentsMaxCount = 2;\n  MergeTree.options = {\n    incrementalUpdate: true,\n    insertAfterRemovedSegs: true,\n    zamboniSegments: true\n  };\n  MergeTree.theUnfinishedNode = {\n    childCount: -1\n  }; //# sourceMappingURL=mergeTree.js.map\n\n  return MergeTree;\n})();","map":null,"metadata":{},"sourceType":"module"}