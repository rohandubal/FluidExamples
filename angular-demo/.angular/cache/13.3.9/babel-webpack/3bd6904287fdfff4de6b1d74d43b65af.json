{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { Quorum } from \"./quorum\";\nexport function isSystemMessage(message) {\n  switch (message.type) {\n    case MessageType.ClientJoin:\n    case MessageType.ClientLeave:\n    case MessageType.Propose:\n    case MessageType.Reject:\n    case MessageType.NoOp:\n    case MessageType.NoClient:\n    case MessageType.Summarize:\n    case MessageType.SummaryAck:\n    case MessageType.SummaryNack:\n      return true;\n\n    default:\n      return false;\n  }\n}\n/**\n * Handles protocol specific ops.\n */\n\nexport class ProtocolOpHandler {\n  constructor(minimumSequenceNumber, sequenceNumber, term, members, proposals, values, sendProposal) {\n    this.minimumSequenceNumber = minimumSequenceNumber;\n    this.sequenceNumber = sequenceNumber;\n    this.term = term !== null && term !== void 0 ? term : 1;\n    this._quorum = new Quorum(members, proposals, values, sendProposal);\n  }\n\n  get quorum() {\n    return this._quorum;\n  }\n\n  get attributes() {\n    return {\n      minimumSequenceNumber: this.minimumSequenceNumber,\n      sequenceNumber: this.sequenceNumber,\n      term: this.term\n    };\n  }\n\n  setConnectionState(connected, clientId) {\n    this._quorum.setConnectionState(connected, clientId);\n  }\n\n  snapshot() {\n    return this._quorum.snapshot();\n  }\n\n  close() {\n    this._quorum.close();\n  }\n\n  processMessage(message, local) {\n    // verify it's moving sequentially\n    if (message.sequenceNumber !== this.sequenceNumber + 1) {\n      throw new Error(`Protocol state is not moving sequentially. ` + `Current is ${this.sequenceNumber}. Next is ${message.sequenceNumber}`);\n    } // Update tracked sequence numbers\n\n\n    this.sequenceNumber = message.sequenceNumber;\n    this.minimumSequenceNumber = message.minimumSequenceNumber;\n    let immediateNoOp = false;\n\n    switch (message.type) {\n      case MessageType.ClientJoin:\n        const systemJoinMessage = message;\n        const join = JSON.parse(systemJoinMessage.data);\n        const member = {\n          client: join.detail,\n          sequenceNumber: systemJoinMessage.sequenceNumber\n        };\n\n        this._quorum.addMember(join.clientId, member);\n\n        break;\n\n      case MessageType.ClientLeave:\n        const systemLeaveMessage = message;\n        const clientId = JSON.parse(systemLeaveMessage.data);\n\n        this._quorum.removeMember(clientId);\n\n        break;\n\n      case MessageType.Propose:\n        const proposal = message.contents;\n\n        this._quorum.addProposal(proposal.key, proposal.value, message.sequenceNumber, local, message.clientSequenceNumber); // On a quorum proposal, immediately send a response to expedite the approval.\n\n\n        immediateNoOp = true;\n        break;\n\n      case MessageType.Reject:\n        throw new Error(\"Quorum rejection is removed.\");\n\n      default:\n    } // Notify the quorum of the MSN from the message. We rely on it to handle duplicate values but may\n    // want to move that logic to this class.\n\n\n    this._quorum.updateMinimumSequenceNumber(message);\n\n    return {\n      immediateNoOp\n    };\n  }\n  /**\n   * Gets the scribe protocol state\n   */\n\n\n  getProtocolState() {\n    // return a new object every time\n    // this ensures future state changes will not affect outside callers\n    return Object.assign({\n      sequenceNumber: this.sequenceNumber,\n      minimumSequenceNumber: this.minimumSequenceNumber\n    }, this._quorum.snapshot());\n  }\n\n}\nexport class ProtocolOpHandlerWithClientValidation extends ProtocolOpHandler {\n  processMessage(message, local) {\n    const client = this._quorum.getMember(message.clientId); // Check and report if we're getting messages from a clientId that we previously\n    // flagged as shouldHaveLeft, or from a client that's not in the quorum but should be\n\n\n    if (message.clientId != null) {\n      if (client === undefined && message.type !== MessageType.ClientJoin) {\n        // pre-0.58 error message: messageClientIdMissingFromQuorum\n        throw new Error(\"Remote message's clientId is missing from the quorum\");\n      }\n\n      if ((client === null || client === void 0 ? void 0 : client.shouldHaveLeft) === true && message.type !== MessageType.NoOp) {\n        // pre-0.58 error message: messageClientIdShouldHaveLeft\n        throw new Error(\"Remote message's clientId already should have left\");\n      }\n    }\n\n    return super.processMessage(message, local);\n  }\n\n} //# sourceMappingURL=protocol.js.map","map":null,"metadata":{},"sourceType":"module"}