{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar _a;\n\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nimport { readAndParse } from \"@fluidframework/driver-utils\";\nimport { SharedObject } from \"@fluidframework/shared-object-base\";\nimport { SummaryTreeBuilder } from \"@fluidframework/runtime-utils\";\nimport { MapKernel } from \"./mapKernel\";\nimport { pkgVersion } from \"./packageVersion\";\nconst snapshotFileName = \"header\";\n/**\n * The factory that defines the map.\n * @sealed\n */\n\nexport class MapFactory {\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n   */\n  get type() {\n    return MapFactory.Type;\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n   */\n\n\n  get attributes() {\n    return MapFactory.Attributes;\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}\n   */\n\n\n  load(runtime, id, services, attributes) {\n    return _asyncToGenerator(function* () {\n      const map = new SharedMap(id, runtime, attributes);\n      yield map.load(services);\n      return map;\n    })();\n  }\n  /**\n   * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.create}\n   */\n\n\n  create(runtime, id) {\n    const map = new SharedMap(id, runtime, MapFactory.Attributes);\n    map.initializeLocal();\n    return map;\n  }\n\n}\n/**\n * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.\"type\"}\n */\n\nMapFactory.Type = \"https://graph.microsoft.com/types/map\";\n/**\n * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}\n */\n\nMapFactory.Attributes = {\n  type: MapFactory.Type,\n  snapshotFormatVersion: \"0.2\",\n  packageVersion: pkgVersion\n};\n/**\n * The SharedMap distributed data structure can be used to store key-value pairs. It provides the same API for setting\n * and retrieving values that JavaScript developers are accustomed to with the\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map | Map} built-in object.\n * However, the keys of a SharedMap must be strings.\n */\n\nexport class SharedMap extends SharedObject {\n  /**\n   * Do not call the constructor. Instead, you should use the {@link SharedMap.create | create method}.\n   *\n   * @param id - String identifier.\n   * @param runtime - Data store runtime.\n   * @param attributes - The attributes for the map.\n   */\n  constructor(id, runtime, attributes) {\n    super(id, runtime, attributes, \"fluid_map_\");\n    /**\n     * String representation for the class.\n     */\n\n    this[_a] = \"SharedMap\";\n    this.kernel = new MapKernel(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), () => this.isAttached(), this);\n  }\n  /**\n   * Create a new shared map.\n   * @param runtime - The data store runtime that the new shared map belongs to.\n   * @param id - Optional name of the shared map.\n   * @returns Newly created shared map.\n   *\n   * @example\n   * To create a `SharedMap`, call the static create method:\n   *\n   * ```typescript\n   * const myMap = SharedMap.create(this.runtime, id);\n   * ```\n   */\n\n\n  static create(runtime, id) {\n    return runtime.createChannel(id, MapFactory.Type);\n  }\n  /**\n   * Get a factory for SharedMap to register with the data store.\n   * @returns A factory that creates SharedMaps and loads them from storage.\n   */\n\n\n  static getFactory() {\n    return new MapFactory();\n  }\n  /**\n   * Get an iterator over the keys in this map.\n   * @returns The iterator\n   */\n\n\n  keys() {\n    return this.kernel.keys();\n  }\n  /**\n   * Get an iterator over the entries in this map.\n   * @returns The iterator\n   */\n\n\n  entries() {\n    return this.kernel.entries();\n  }\n  /**\n   * Get an iterator over the values in this map.\n   * @returns The iterator\n   */\n\n\n  values() {\n    return this.kernel.values();\n  }\n  /**\n   * Get an iterator over the entries in this map.\n   * @returns The iterator\n   */\n\n\n  [(_a = Symbol.toStringTag, Symbol.iterator)]() {\n    return this.kernel.entries();\n  }\n  /**\n   * The number of key/value pairs stored in the map.\n   */\n\n\n  get size() {\n    return this.kernel.size;\n  }\n  /**\n   * Executes the given callback on each entry in the map.\n   * @param callbackFn - Callback function\n   */\n\n\n  forEach(callbackFn) {\n    this.kernel.forEach(callbackFn);\n  }\n  /**\n   * {@inheritDoc ISharedMap.get}\n   */\n\n\n  get(key) {\n    return this.kernel.get(key);\n  }\n  /**\n   * Check if a key exists in the map.\n   * @param key - The key to check\n   * @returns True if the key exists, false otherwise\n   */\n\n\n  has(key) {\n    return this.kernel.has(key);\n  }\n  /**\n   * {@inheritDoc ISharedMap.set}\n   */\n\n\n  set(key, value) {\n    this.kernel.set(key, value);\n    return this;\n  }\n  /**\n   * Delete a key from the map.\n   * @param key - Key to delete\n   * @returns True if the key existed and was deleted, false if it did not exist\n   */\n\n\n  delete(key) {\n    return this.kernel.delete(key);\n  }\n  /**\n   * Clear all data from the map.\n   */\n\n\n  clear() {\n    this.kernel.clear();\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.summarizeCore}\n   * @internal\n   */\n\n\n  summarizeCore(serializer, telemetryContext) {\n    let currentSize = 0;\n    let counter = 0;\n    let headerBlob = {};\n    const blobs = [];\n    const builder = new SummaryTreeBuilder();\n    const data = this.kernel.getSerializedStorage(serializer); // If single property exceeds this size, it goes into its own blob\n\n    const MinValueSizeSeparateSnapshotBlob = 8 * 1024; // Maximum blob size for multiple map properties\n    // Should be bigger than MinValueSizeSeparateSnapshotBlob\n\n    const MaxSnapshotBlobSize = 16 * 1024; // Partitioning algorithm:\n    // 1) Split large (over MinValueSizeSeparateSnapshotBlob = 8K) properties into their own blobs.\n    //    Naming (across snapshots) of such blob does not have to be stable across snapshots,\n    //    As de-duping process (in driver) should not care about paths, only content.\n    // 2) Split remaining properties into blobs of MaxSnapshotBlobSize (16K) size.\n    //    This process does not produce stable partitioning. This means\n    //    modification (including addition / deletion) of property can shift properties across blobs\n    //    and result in non-incremental snapshot.\n    //    This can be improved in the future, without being format breaking change, as loading sequence\n    //    loads all blobs at once and partitioning schema has no impact on that process.\n\n    for (const key of Object.keys(data)) {\n      const value = data[key];\n\n      if (value.value && value.value.length >= MinValueSizeSeparateSnapshotBlob) {\n        const blobName = `blob${counter}`;\n        counter++;\n        blobs.push(blobName);\n        const content = {\n          [key]: {\n            type: value.type,\n            value: JSON.parse(value.value)\n          }\n        };\n        builder.addBlob(blobName, JSON.stringify(content));\n      } else {\n        currentSize += value.type.length + 21; // Approximation cost of property header\n\n        if (value.value) {\n          currentSize += value.value.length;\n        }\n\n        if (currentSize > MaxSnapshotBlobSize) {\n          const blobName = `blob${counter}`;\n          counter++;\n          blobs.push(blobName);\n          builder.addBlob(blobName, JSON.stringify(headerBlob));\n          headerBlob = {};\n          currentSize = 0;\n        }\n\n        headerBlob[key] = {\n          type: value.type,\n          value: value.value === undefined ? undefined : JSON.parse(value.value)\n        };\n      }\n    }\n\n    const header = {\n      blobs,\n      content: headerBlob\n    };\n    builder.addBlob(snapshotFileName, JSON.stringify(header));\n    return builder.getSummaryTree();\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}\n   * @internal\n   */\n\n\n  loadCore(storage) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const json = yield readAndParse(storage, snapshotFileName);\n      const newFormat = json;\n\n      if (Array.isArray(newFormat.blobs)) {\n        _this.kernel.populateFromSerializable(newFormat.content);\n\n        yield Promise.all(newFormat.blobs.map( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (value) {\n            const content = yield readAndParse(storage, value);\n\n            _this.kernel.populateFromSerializable(content);\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()));\n      } else {\n        _this.kernel.populateFromSerializable(json);\n      }\n    })();\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.onDisconnect}\n   * @internal\n   */\n\n\n  onDisconnect() {}\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.reSubmitCore}\n   * @internal\n   */\n\n\n  reSubmitCore(content, localOpMetadata) {\n    this.kernel.trySubmitMessage(content, localOpMetadata);\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObjectCore.applyStashedOp}\n   * @internal\n   */\n\n\n  applyStashedOp(content) {\n    this.kernel.tryProcessMessage(content, false, undefined);\n    return this.kernel.tryGetStashedOpLocalMetadata(content);\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.processCore}\n   * @internal\n   */\n\n\n  processCore(message, local, localOpMetadata) {\n    if (message.type === MessageType.Operation) {\n      this.kernel.tryProcessMessage(message.contents, local, localOpMetadata);\n    }\n  }\n  /**\n   * {@inheritDoc @fluidframework/shared-object-base#SharedObject.rollback}\n   * @internal\n  */\n\n\n  rollback(content, localOpMetadata) {\n    this.kernel.rollback(content, localOpMetadata);\n  }\n\n} //# sourceMappingURL=map.js.map","map":null,"metadata":{},"sourceType":"module"}