{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { delay, performance } from \"@fluidframework/common-utils\";\nimport { DriverErrorType } from \"@fluidframework/driver-definitions\";\nimport { canRetryOnError, getRetryDelayFromError } from \"./network\";\nimport { pkgVersion } from \"./packageVersion\";\nimport { NonRetryableError } from \".\";\nexport function runWithRetry(_x, _x2, _x3, _x4) {\n  return _runWithRetry.apply(this, arguments);\n} //# sourceMappingURL=runWithRetry.js.map\n\nfunction _runWithRetry() {\n  _runWithRetry = _asyncToGenerator(function* (api, fetchCallName, logger, progress) {\n    var _a, _b;\n\n    let result;\n    let success = false;\n    let retryAfterMs = 1000; // has to be positive!\n\n    let numRetries = 0;\n    const startTime = performance.now();\n    let lastError;\n\n    do {\n      try {\n        result = yield api(progress.cancel);\n        success = true;\n      } catch (err) {\n        // If it is not retriable, then just throw the error.\n        if (!canRetryOnError(err)) {\n          logger.sendTelemetryEvent({\n            eventName: `${fetchCallName}_cancel`,\n            retry: numRetries,\n            duration: performance.now() - startTime,\n            fetchCallName\n          }, err);\n          throw err;\n        }\n\n        if (((_a = progress.cancel) === null || _a === void 0 ? void 0 : _a.aborted) === true) {\n          logger.sendTelemetryEvent({\n            eventName: `${fetchCallName}_runWithRetryAborted`,\n            retry: numRetries,\n            duration: performance.now() - startTime,\n            fetchCallName\n          }, err);\n          throw new NonRetryableError(\"runWithRetry was Aborted\", DriverErrorType.genericError, {\n            driverVersion: pkgVersion,\n            fetchCallName\n          });\n        }\n\n        numRetries++;\n        lastError = err; // If the error is throttling error, then wait for the specified time before retrying.\n        // If the waitTime is not specified, then we start with retrying immediately to max of 8s.\n\n        retryAfterMs = (_b = getRetryDelayFromError(err)) !== null && _b !== void 0 ? _b : Math.min(retryAfterMs * 2, 8000);\n\n        if (progress.onRetry) {\n          progress.onRetry(retryAfterMs, err);\n        }\n\n        yield delay(retryAfterMs);\n      }\n    } while (!success);\n\n    if (numRetries > 0) {\n      logger.sendTelemetryEvent({\n        eventName: `${fetchCallName}_lastError`,\n        retry: numRetries,\n        duration: performance.now() - startTime,\n        fetchCallName\n      }, lastError);\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    return result;\n  });\n  return _runWithRetry.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}