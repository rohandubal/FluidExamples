{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BindState, AttachState } from \"@fluidframework/container-definitions\";\nimport { assert, Deferred, LazyPromise, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { readAndParse } from \"@fluidframework/driver-utils\";\nimport { BlobTreeEntry } from \"@fluidframework/protocol-base\";\nimport { channelsTreeName, gcBlobKey } from \"@fluidframework/runtime-definitions\";\nimport { addBlobToSummary, convertSummaryTreeToITree } from \"@fluidframework/runtime-utils\";\nimport { ChildLogger, LoggingError, TelemetryDataTag, ThresholdCounter } from \"@fluidframework/telemetry-utils\";\nimport { DataProcessingError } from \"@fluidframework/container-utils\";\nimport { dataStoreAttributesBlobName, hasIsolatedChannels, wrapSummaryInChannelsTree, getAttributesFormatVersion, getFluidDataStoreAttributes } from \"./summaryFormat\";\n\nfunction createAttributes(pkg, isRootDataStore, disableIsolatedChannels) {\n  const stringifiedPkg = JSON.stringify(pkg);\n  return disableIsolatedChannels ? {\n    pkg: stringifiedPkg,\n    snapshotFormatVersion: \"0.1\",\n    isRootDataStore\n  } : {\n    pkg: stringifiedPkg,\n    summaryFormatVersion: 2,\n    isRootDataStore\n  };\n}\n\nexport function createAttributesBlob(pkg, isRootDataStore, disableIsolatedChannels) {\n  const attributes = createAttributes(pkg, isRootDataStore, disableIsolatedChannels);\n  return new BlobTreeEntry(dataStoreAttributesBlobName, JSON.stringify(attributes));\n}\n/**\n * Represents the context for the store. This context is passed to the store runtime.\n */\n\nexport let FluidDataStoreContext = /*#__PURE__*/(() => {\n  class FluidDataStoreContext extends TypedEventEmitter {\n    constructor(props, existing, bindState, isLocalDataStore, makeLocallyVisibleFn) {\n      var _this;\n\n      super();\n      _this = this;\n      this.existing = existing;\n      this.bindState = bindState;\n      this.isLocalDataStore = isLocalDataStore;\n      this.makeLocallyVisibleFn = makeLocallyVisibleFn;\n      this._disposed = false;\n      this.detachedRuntimeCreation = false;\n      this.loaded = false;\n      this.pending = [];\n      this._isInMemoryRoot = false;\n      this._containerRuntime = props.runtime;\n      this.id = props.id;\n      this.storage = props.storage;\n      this.scope = props.scope;\n      this.writeGCDataAtRoot = props.writeGCDataAtRoot;\n      this.disableIsolatedChannels = props.disableIsolatedChannels;\n      this.pkg = props.pkg; // URIs use slashes as delimiters. Handles use URIs.\n      // Thus having slashes in types almost guarantees trouble down the road!\n\n      assert(!this.id.includes(\"/\"), 0x13a\n      /* Data store ID contains slash */\n      );\n      this._attachState = this.containerRuntime.attachState !== AttachState.Detached && this.existing ? this.containerRuntime.attachState : AttachState.Detached;\n\n      this.bindToContext = () => {\n        assert(this.bindState === BindState.NotBound, 0x13b\n        /* \"datastore context is already in bound state\" */\n        );\n        this.bindState = BindState.Binding;\n        assert(this.channel !== undefined, 0x13c\n        /* \"undefined channel on datastore context\" */\n        );\n        this.makeLocallyVisible();\n        this.bindState = BindState.Bound;\n      };\n\n      const thisSummarizeInternal = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (fullTree, trackState, telemetryContext) {\n          return _this.summarizeInternal(fullTree, trackState, telemetryContext);\n        });\n\n        return function thisSummarizeInternal(_x, _x2, _x3) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      this.summarizerNode = props.createSummarizerNodeFn(thisSummarizeInternal, /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (fullGC) {\n          return _this.getGCDataInternal(fullGC);\n        });\n\n        return function (_x4) {\n          return _ref2.apply(this, arguments);\n        };\n      }(), /*#__PURE__*/_asyncToGenerator(function* () {\n        return _this.getBaseGCDetails();\n      }));\n      this.subLogger = ChildLogger.create(this.logger, \"FluidDataStoreContext\");\n      this.thresholdOpsCounter = new ThresholdCounter(FluidDataStoreContext.pendingOpsCountThreshold, this.subLogger);\n    }\n\n    get packagePath() {\n      assert(this.pkg !== undefined, 0x139\n      /* \"Undefined package path\" */\n      );\n      return this.pkg;\n    }\n\n    get options() {\n      return this._containerRuntime.options;\n    }\n\n    get clientId() {\n      return this._containerRuntime.clientId;\n    }\n\n    get clientDetails() {\n      return this._containerRuntime.clientDetails;\n    }\n\n    get logger() {\n      return this._containerRuntime.logger;\n    }\n\n    get deltaManager() {\n      return this._containerRuntime.deltaManager;\n    }\n\n    get connected() {\n      return this._containerRuntime.connected;\n    }\n\n    get IFluidHandleContext() {\n      return this._containerRuntime.IFluidHandleContext;\n    }\n\n    get containerRuntime() {\n      return this._containerRuntime;\n    }\n\n    get isLoaded() {\n      return this.loaded;\n    }\n\n    get baseSnapshot() {\n      return this._baseSnapshot;\n    }\n\n    get disposed() {\n      return this._disposed;\n    }\n\n    get attachState() {\n      return this._attachState;\n    }\n\n    get IFluidDataStoreRegistry() {\n      return this.registry;\n    }\n    /**\n     * A datastore is considered as root if it\n     * 1. is root in memory - see isInMemoryRoot\n     * 2. is root as part of the base snapshot that the datastore loaded from\n     * @returns whether a datastore is root\n     */\n\n\n    isRoot() {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        return _this2.isInMemoryRoot() || (yield _this2.getInitialSnapshotDetails()).isRootDataStore;\n      })();\n    }\n    /**\n     * There are 3 states where isInMemoryRoot needs to be true\n     * 1. when a datastore becomes aliased. This can happen for both remote and local datastores\n     * 2. when a datastore is created locally as root\n     * 3. when a datastore is created locally as root and is rehydrated\n     * @returns whether a datastore is root in memory\n     */\n\n\n    isInMemoryRoot() {\n      return this._isInMemoryRoot;\n    }\n\n    dispose() {\n      if (this._disposed) {\n        return;\n      }\n\n      this._disposed = true; // Dispose any pending runtime after it gets fulfilled\n      // Errors are logged where this.channelDeferred is consumed/generated (realizeCore(), bindRuntime())\n\n      if (this.channelDeferred) {\n        this.channelDeferred.promise.then(runtime => {\n          runtime.dispose();\n        }).catch(error => {});\n      }\n    }\n\n    rejectDeferredRealize(reason, packageName) {\n      throw new LoggingError(reason, {\n        packageName: {\n          value: packageName,\n          tag: TelemetryDataTag.PackageData\n        }\n      });\n    }\n\n    realize() {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        assert(!_this3.detachedRuntimeCreation, 0x13d\n        /* \"Detached runtime creation on realize()\" */\n        );\n\n        if (!_this3.channelDeferred) {\n          _this3.channelDeferred = new Deferred();\n\n          _this3.realizeCore(_this3.existing).catch(error => {\n            var _a;\n\n            const errorWrapped = DataProcessingError.wrapIfUnrecognized(error, \"realizeFluidDataStoreContext\");\n            errorWrapped.addTelemetryProperties({\n              fluidDataStoreId: {\n                value: _this3.id,\n                tag: \"PackageData\"\n              }\n            });\n            (_a = _this3.channelDeferred) === null || _a === void 0 ? void 0 : _a.reject(errorWrapped);\n\n            _this3.logger.sendErrorEvent({\n              eventName: \"RealizeError\"\n            }, errorWrapped);\n          });\n        }\n\n        return _this3.channelDeferred.promise;\n      })();\n    }\n\n    factoryFromPackagePath(packages) {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        assert(_this4.pkg === packages, 0x13e\n        /* \"Unexpected package path\" */\n        );\n\n        if (packages === undefined) {\n          _this4.rejectDeferredRealize(\"packages is undefined\");\n        }\n\n        let entry;\n        let registry = _this4._containerRuntime.IFluidDataStoreRegistry;\n        let lastPkg;\n\n        for (const pkg of packages) {\n          if (!registry) {\n            _this4.rejectDeferredRealize(\"No registry for package\", lastPkg);\n          }\n\n          lastPkg = pkg;\n          entry = yield registry.get(pkg);\n\n          if (!entry) {\n            _this4.rejectDeferredRealize(\"Registry does not contain entry for the package\", pkg);\n          }\n\n          registry = entry.IFluidDataStoreRegistry;\n        }\n\n        const factory = entry === null || entry === void 0 ? void 0 : entry.IFluidDataStoreFactory;\n\n        if (factory === undefined) {\n          _this4.rejectDeferredRealize(\"Can't find factory for package\", lastPkg);\n        }\n\n        return {\n          factory,\n          registry\n        };\n      })();\n    }\n\n    realizeCore(existing) {\n      var _this5 = this;\n\n      return _asyncToGenerator(function* () {\n        const details = yield _this5.getInitialSnapshotDetails(); // Base snapshot is the baseline where pending ops are applied to.\n        // It is important that this be in sync with the pending ops, and also\n        // that it is set here, before bindRuntime is called.\n\n        _this5._baseSnapshot = details.snapshot;\n        const packages = details.pkg;\n        const {\n          factory,\n          registry\n        } = yield _this5.factoryFromPackagePath(packages);\n        assert(_this5.registry === undefined, 0x13f\n        /* \"datastore context registry is already set\" */\n        );\n        _this5.registry = registry;\n        const channel = yield factory.instantiateDataStore(_this5, existing);\n        assert(channel !== undefined, 0x140\n        /* \"undefined channel on datastore context\" */\n        );\n\n        _this5.bindRuntime(channel);\n      })();\n    }\n    /**\n     * Notifies this object about changes in the connection state.\n     * @param value - New connection state.\n     * @param clientId - ID of the client. It's old ID when in disconnected state and\n     * it's new client ID when we are connecting or connected.\n     */\n\n\n    setConnectionState(connected, clientId) {\n      this.verifyNotClosed(); // Connection events are ignored if the store is not yet loaded\n\n      if (!this.loaded) {\n        return;\n      }\n\n      assert(this.connected === connected, 0x141\n      /* \"Unexpected connected state\" */\n      ); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      this.channel.setConnectionState(connected, clientId);\n    }\n\n    process(messageArg, local, localOpMetadata) {\n      var _a;\n\n      this.verifyNotClosed();\n      const innerContents = messageArg.contents;\n      const message = Object.assign(Object.assign({}, messageArg), {\n        type: innerContents.type,\n        contents: innerContents.content\n      });\n      this.summarizerNode.recordChange(message);\n\n      if (this.loaded) {\n        return (_a = this.channel) === null || _a === void 0 ? void 0 : _a.process(message, local, localOpMetadata);\n      } else {\n        assert(!local, 0x142\n        /* \"local store channel is not loaded\" */\n        );\n        assert(this.pending !== undefined, 0x23d\n        /* \"pending is undefined\" */\n        );\n        this.pending.push(message);\n        this.thresholdOpsCounter.sendIfMultiple(\"StorePendingOps\", this.pending.length);\n      }\n    }\n\n    processSignal(message, local) {\n      var _a;\n\n      this.verifyNotClosed(); // Signals are ignored if the store is not yet loaded\n\n      if (!this.loaded) {\n        return;\n      }\n\n      (_a = this.channel) === null || _a === void 0 ? void 0 : _a.processSignal(message, local);\n    }\n\n    getQuorum() {\n      return this._containerRuntime.getQuorum();\n    }\n\n    getAudience() {\n      return this._containerRuntime.getAudience();\n    }\n    /**\n     * Returns a summary at the current sequence number.\n     * @param fullTree - true to bypass optimizations and force a full summary tree\n     * @param trackState - This tells whether we should track state from this summary.\n     * @param telemetryContext - summary data passed through the layers for telemetry purposes\n     */\n\n\n    summarize(fullTree = false, trackState = true, telemetryContext) {\n      var _this6 = this;\n\n      return _asyncToGenerator(function* () {\n        return _this6.summarizerNode.summarize(fullTree, trackState, telemetryContext);\n      })();\n    }\n\n    summarizeInternal(fullTree, trackState, telemetryContext) {\n      var _this7 = this;\n\n      return _asyncToGenerator(function* () {\n        yield _this7.realize(); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const summarizeResult = yield _this7.channel.summarize(fullTree, trackState, telemetryContext);\n        let pathPartsForChildren;\n\n        if (!_this7.disableIsolatedChannels) {\n          // Wrap dds summaries in .channels subtree.\n          wrapSummaryInChannelsTree(summarizeResult);\n          pathPartsForChildren = [channelsTreeName];\n        } // Add data store's attributes to the summary.\n\n\n        const {\n          pkg\n        } = yield _this7.getInitialSnapshotDetails();\n        const isRoot = yield _this7.isRoot();\n        const attributes = createAttributes(pkg, isRoot, _this7.disableIsolatedChannels);\n        addBlobToSummary(summarizeResult, dataStoreAttributesBlobName, JSON.stringify(attributes)); // Add GC data to the summary if it's not written at the root.\n\n        if (!_this7.writeGCDataAtRoot) {\n          addBlobToSummary(summarizeResult, gcBlobKey, JSON.stringify(_this7.summarizerNode.getGCSummaryDetails()));\n        } // If we are not referenced, mark the summary tree as unreferenced. Also, update unreferenced blob\n        // size in the summary stats with the blobs size of this data store.\n\n\n        if (!_this7.summarizerNode.isReferenced()) {\n          summarizeResult.summary.unreferenced = true;\n          summarizeResult.stats.unreferencedBlobSize = summarizeResult.stats.totalBlobSize;\n        }\n\n        return Object.assign(Object.assign({}, summarizeResult), {\n          id: _this7.id,\n          pathPartsForChildren\n        });\n      })();\n    }\n    /**\n     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this data store\n     * including any of its child channel contexts. Each node has a set of outbound routes to other GC nodes in the\n     * document.\n     * If there is no new data in this data store since the last summary, previous GC data is used.\n     * If there is new data, the GC data is generated again (by calling getGCDataInternal).\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n\n\n    getGCData(fullGC = false) {\n      var _this8 = this;\n\n      return _asyncToGenerator(function* () {\n        return _this8.summarizerNode.getGCData(fullGC);\n      })();\n    }\n    /**\n     * Generates data used for garbage collection. This is called when there is new data since last summary. It\n     * realizes the data store and calls into each channel context to get its GC data.\n     * @param fullGC - true to bypass optimizations and force full generation of GC data.\n     */\n\n\n    getGCDataInternal(fullGC = false) {\n      var _this9 = this;\n\n      return _asyncToGenerator(function* () {\n        yield _this9.realize();\n        assert(_this9.channel !== undefined, 0x143\n        /* \"Channel should not be undefined when running GC\" */\n        );\n        return _this9.channel.getGCData(fullGC);\n      })();\n    }\n    /**\n     * After GC has run, called to notify the data store of routes used in it. These are used for the following:\n     * 1. To identify if this data store is being referenced in the document or not.\n     * 2. To determine if it needs to re-summarize in case used routes changed since last summary.\n     * 3. These are added to the summary generated by the data store.\n     * 4. To notify child contexts of their used routes. This is done immediately if the data store is loaded. Else,\n     *    it is done when realizing the data store.\n     * 5. To update the timestamp when this data store or any children are marked as unreferenced.\n     * @param usedRoutes - The routes that are used in this data store.\n     * @param gcTimestamp - The time when GC was run that generated these used routes. If any node becomes unreferenced\n     * as part of this GC run, this should be used to update the time when it happens.\n     */\n\n\n    updateUsedRoutes(usedRoutes, gcTimestamp) {\n      // Update the used routes in this data store's summarizer node.\n      this.summarizerNode.updateUsedRoutes(usedRoutes, gcTimestamp);\n      /**\n       * If the data store has not been realized yet, we need this used state to update the used state of the channel\n       * when it realizes. It's safe to keep only the last used state because if something changes because of this GC\n       * run, the data store will be immediately realized as part of the summary that follows GC. For example, if a\n       * child's reference state changes, the gcTimestamp has to be used to update its unreferencedTimestamp. Since\n       * it will result in a change in this data store's used routes, it will be realized to regenerate its summary.\n       */\n\n      this.lastUsedState = {\n        usedRoutes,\n        gcTimestamp\n      }; // If we are loaded, call the channel so it can update the used routes of the child contexts.\n      // If we are not loaded, we will update this when we are realized.\n\n      if (this.loaded) {\n        this.updateChannelUsedRoutes();\n      }\n    }\n    /**\n     * Called when a new outbound reference is added to another node. This is used by garbage collection to identify\n     * all references added in the system.\n     * @param srcHandle - The handle of the node that added the reference.\n     * @param outboundHandle - The handle of the outbound node that is referenced.\n     */\n\n\n    addedGCOutboundReference(srcHandle, outboundHandle) {\n      this._containerRuntime.addedGCOutboundReference(srcHandle, outboundHandle);\n    }\n    /**\n     * Updates the used routes of the channel and its child contexts. The channel must be loaded before calling this.\n     * It is called in these two scenarios:\n     * 1. When the used routes of the data store is updated and the data store is loaded.\n     * 2. When the data store is realized. This updates the channel's used routes as per last GC run.\n     */\n\n\n    updateChannelUsedRoutes() {\n      assert(this.loaded, 0x144\n      /* \"Channel should be loaded when updating used routes\" */\n      );\n      assert(this.channel !== undefined, 0x145\n      /* \"Channel should be present when data store is loaded\" */\n      ); // If there is no lastUsedState, GC has not run up until this point.\n\n      if (this.lastUsedState === undefined) {\n        return;\n      } // Remove the route to this data store, if it exists.\n\n\n      const usedChannelRoutes = this.lastUsedState.usedRoutes.filter(id => {\n        return id !== \"/\" && id !== \"\";\n      });\n      this.channel.updateUsedRoutes(usedChannelRoutes, this.lastUsedState.gcTimestamp);\n    }\n    /**\n     * @deprecated 0.18.Should call request on the runtime directly\n     */\n\n\n    request(request) {\n      var _this10 = this;\n\n      return _asyncToGenerator(function* () {\n        const runtime = yield _this10.realize();\n        return runtime.request(request);\n      })();\n    }\n\n    submitMessage(type, content, localOpMetadata) {\n      this.verifyNotClosed();\n      assert(!!this.channel, 0x146\n      /* \"Channel must exist when submitting message\" */\n      );\n      const fluidDataStoreContent = {\n        content,\n        type\n      };\n\n      this._containerRuntime.submitDataStoreOp(this.id, fluidDataStoreContent, localOpMetadata);\n    }\n    /**\n     * This is called from a SharedSummaryBlock that does not generate ops but only wants to be part of the summary.\n     * It indicates that there is data in the object that needs to be summarized.\n     * We will update the latestSequenceNumber of the summary tracker of this\n     * store and of the object's channel.\n     *\n     * @param address - The address of the channel that is dirty.\n     *\n     */\n\n\n    setChannelDirty(address) {\n      this.verifyNotClosed(); // Get the latest sequence number.\n\n      const latestSequenceNumber = this.deltaManager.lastSequenceNumber;\n      this.summarizerNode.invalidate(latestSequenceNumber);\n      const channelSummarizerNode = this.summarizerNode.getChild(address);\n\n      if (channelSummarizerNode) {\n        channelSummarizerNode.invalidate(latestSequenceNumber); // TODO: lazy load problem?\n      }\n    }\n\n    submitSignal(type, content) {\n      this.verifyNotClosed();\n      assert(!!this.channel, 0x147\n      /* \"Channel must exist on submitting signal\" */\n      );\n      return this._containerRuntime.submitDataStoreSignal(this.id, type, content);\n    }\n    /**\n     * This is called by the data store channel when it becomes locally visible indicating that it is ready to become\n     * globally visible now.\n     */\n\n\n    makeLocallyVisible() {\n      assert(this.channel !== undefined, 0x2cf\n      /* \"undefined channel on datastore context\" */\n      );\n      this.makeLocallyVisibleFn();\n    }\n\n    bindRuntime(channel) {\n      var _a;\n\n      if (this.channel) {\n        throw new Error(\"Runtime already bound\");\n      }\n\n      try {\n        assert(!this.detachedRuntimeCreation, 0x148\n        /* \"Detached runtime creation on runtime bind\" */\n        );\n        assert(this.channelDeferred !== undefined, 0x149\n        /* \"Undefined channel deferral\" */\n        );\n        assert(this.pkg !== undefined, 0x14a\n        /* \"Undefined package path\" */\n        ); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const pending = this.pending; // Apply all pending ops\n\n        for (const op of pending) {\n          channel.process(op, false, undefined\n          /* localOpMetadata */\n          );\n        }\n\n        this.thresholdOpsCounter.send(\"ProcessPendingOps\", pending.length);\n        this.pending = undefined; // And now mark the runtime active\n\n        this.loaded = true;\n        this.channel = channel; // Freeze the package path to ensure that someone doesn't modify it when it is\n        // returned in packagePath().\n\n        Object.freeze(this.pkg);\n        /**\n         * Update the used routes of the channel. If GC has run before this data store was realized, we will have\n         * the used routes saved. So, this will ensure that all the child contexts have up-to-date used routes as\n         * per the last time GC was run.\n         * Also, this data store may have been realized during summarize. In that case, the child contexts need to\n         * have their used routes updated to determine if its needs to summarize again and to add it to the summary.\n         */\n\n        this.updateChannelUsedRoutes(); // And notify the pending promise it is now available\n\n        this.channelDeferred.resolve(this.channel);\n      } catch (error) {\n        (_a = this.channelDeferred) === null || _a === void 0 ? void 0 : _a.reject(error);\n        this.logger.sendErrorEvent({\n          eventName: \"BindRuntimeError\",\n          fluidDataStoreId: {\n            value: this.id,\n            tag: \"PackageData\"\n          }\n        }, error);\n      }\n    }\n\n    getAbsoluteUrl(relativeUrl) {\n      var _this11 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this11.attachState !== AttachState.Attached) {\n          return undefined;\n        }\n\n        return _this11._containerRuntime.getAbsoluteUrl(relativeUrl);\n      })();\n    }\n    /**\n     * @deprecated - Sets the datastore as root, for aliasing purposes: #7948\n     * This method should not be used outside of the aliasing context.\n     * It will be removed, as the source of truth for this flag will be the aliasing blob.\n     */\n\n\n    setInMemoryRoot() {\n      this._isInMemoryRoot = true;\n    }\n\n    reSubmit(contents, localOpMetadata) {\n      assert(!!this.channel, 0x14b\n      /* \"Channel must exist when resubmitting ops\" */\n      );\n      const innerContents = contents;\n      this.channel.reSubmit(innerContents.type, innerContents.content, localOpMetadata);\n    }\n\n    rollback(contents, localOpMetadata) {\n      if (!this.channel) {\n        throw new Error(\"Channel must exist when rolling back ops\");\n      }\n\n      if (!this.channel.rollback) {\n        throw new Error(\"Channel doesn't support rollback\");\n      }\n\n      const innerContents = contents;\n      this.channel.rollback(innerContents.type, innerContents.content, localOpMetadata);\n    }\n\n    applyStashedOp(contents) {\n      var _this12 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this12.channel) {\n          yield _this12.realize();\n        }\n\n        assert(!!_this12.channel, 0x14c\n        /* \"Channel must exist when rebasing ops\" */\n        );\n        const innerContents = contents;\n        return _this12.channel.applyStashedOp(innerContents.content);\n      })();\n    }\n\n    verifyNotClosed() {\n      if (this._disposed) {\n        throw new Error(\"Context is closed\");\n      }\n    }\n\n    getCreateChildSummarizerNodeFn(id, createParam) {\n      return (summarizeInternal, getGCDataFn, getBaseGCDetailsFn) => this.summarizerNode.createChild(summarizeInternal, id, createParam, // DDS will not create failure summaries\n      {\n        throwOnFailure: true\n      }, getGCDataFn, getBaseGCDetailsFn);\n    }\n\n    uploadBlob(blob) {\n      var _this13 = this;\n\n      return _asyncToGenerator(function* () {\n        return _this13.containerRuntime.uploadBlob(blob);\n      })();\n    }\n\n  }\n\n  FluidDataStoreContext.pendingOpsCountThreshold = 1000;\n  return FluidDataStoreContext;\n})();\nexport class RemoteFluidDataStoreContext extends FluidDataStoreContext {\n  constructor(props) {\n    var _this14;\n\n    super(props, true\n    /* existing */\n    , BindState.Bound, false\n    /* isLocalDataStore */\n    , () => {\n      throw new Error(\"Already attached\");\n    });\n    _this14 = this;\n    this.initialSnapshotDetailsP = new LazyPromise( /*#__PURE__*/_asyncToGenerator(function* () {\n      var _a, _b;\n\n      let tree;\n      let isRootDataStore = true;\n\n      if (typeof _this14.initSnapshotValue === \"string\") {\n        const commit = (yield _this14.storage.getVersions(_this14.initSnapshotValue, 1))[0];\n        tree = (_a = yield _this14.storage.getSnapshotTree(commit)) !== null && _a !== void 0 ? _a : undefined;\n      } else {\n        tree = _this14.initSnapshotValue;\n      }\n\n      const localReadAndParse = /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* (id) {\n          return readAndParse(_this14.storage, id);\n        });\n\n        return function localReadAndParse(_x5) {\n          return _ref5.apply(this, arguments);\n        };\n      }();\n\n      if (tree) {\n        const loadedSummary = yield _this14.summarizerNode.loadBaseSummary(tree, localReadAndParse);\n        tree = loadedSummary.baseSummary; // Prepend outstanding ops to pending queue of ops to process.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        _this14.pending = loadedSummary.outstandingOps.concat(_this14.pending);\n      }\n\n      if (!!tree && tree.blobs[dataStoreAttributesBlobName] !== undefined) {\n        // Need to get through snapshot and use that to populate extraBlobs\n        const attributes = yield localReadAndParse(tree.blobs[dataStoreAttributesBlobName]);\n        let pkgFromSnapshot; // Use the snapshotFormatVersion to determine how the pkg is encoded in the snapshot.\n        // For snapshotFormatVersion = \"0.1\" (1) or above, pkg is jsonified, otherwise it is just a string.\n\n        const formatVersion = getAttributesFormatVersion(attributes);\n\n        if (formatVersion < 1) {\n          if (attributes.pkg.startsWith(\"[\\\"\") && attributes.pkg.endsWith(\"\\\"]\")) {\n            pkgFromSnapshot = JSON.parse(attributes.pkg);\n          } else {\n            pkgFromSnapshot = [attributes.pkg];\n          }\n        } else {\n          pkgFromSnapshot = JSON.parse(attributes.pkg);\n        }\n\n        _this14.pkg = pkgFromSnapshot;\n        /**\n         * If there is no isRootDataStore in the attributes blob, set it to true. This will ensure that\n         * data stores in older documents are not garbage collected incorrectly. This may lead to additional\n         * roots in the document but they won't break.\n         */\n\n        isRootDataStore = (_b = attributes.isRootDataStore) !== null && _b !== void 0 ? _b : true;\n\n        if (hasIsolatedChannels(attributes)) {\n          tree = tree.trees[channelsTreeName];\n          assert(tree !== undefined, 0x1fe\n          /* \"isolated channels subtree should exist in remote datastore snapshot\" */\n          );\n        }\n      }\n\n      return {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        pkg: _this14.pkg,\n        isRootDataStore,\n        snapshot: tree\n      };\n    }));\n    this.initSnapshotValue = props.snapshotTree;\n    this.baseGCDetailsP = new LazyPromise( /*#__PURE__*/_asyncToGenerator(function* () {\n      var _a;\n\n      return (_a = yield props.getBaseGCDetails()) !== null && _a !== void 0 ? _a : {};\n    }));\n  }\n\n  getInitialSnapshotDetails() {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this15.initialSnapshotDetailsP;\n    })();\n  }\n  /**\n   * @deprecated - Renamed to getBaseGCDetails.\n   */\n\n\n  getInitialGCSummaryDetails() {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this16.getBaseGCDetails();\n    })();\n  }\n\n  getBaseGCDetails() {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this17.baseGCDetailsP;\n    })();\n  }\n\n  generateAttachMessage() {\n    throw new Error(\"Cannot attach remote store\");\n  }\n\n}\n/**\n * Base class for detached & attached context classes\n */\n\nexport class LocalFluidDataStoreContextBase extends FluidDataStoreContext {\n  constructor(props) {\n    super(props, props.snapshotTree !== undefined ? true : false\n    /* existing */\n    , props.snapshotTree ? BindState.Bound : BindState.NotBound, true\n    /* isLocalDataStore */\n    , props.makeLocallyVisibleFn);\n    this.snapshotTree = props.snapshotTree;\n\n    if (props.isRootDataStore === true) {\n      this.setInMemoryRoot();\n    }\n\n    this.createProps = props.createProps;\n    this.attachListeners();\n  }\n\n  attachListeners() {\n    this.once(\"attaching\", () => {\n      assert(this.attachState === AttachState.Detached, 0x14d\n      /* \"Should move from detached to attaching\" */\n      );\n      this._attachState = AttachState.Attaching;\n    });\n    this.once(\"attached\", () => {\n      assert(this.attachState === AttachState.Attaching, 0x14e\n      /* \"Should move from attaching to attached\" */\n      );\n      this._attachState = AttachState.Attached;\n    });\n  }\n\n  generateAttachMessage() {\n    assert(this.channel !== undefined, 0x14f\n    /* \"There should be a channel when generating attach message\" */\n    );\n    assert(this.pkg !== undefined, 0x150\n    /* \"pkg should be available in local data store context\" */\n    );\n    const summarizeResult = this.channel.getAttachSummary();\n\n    if (!this.disableIsolatedChannels) {\n      // Wrap dds summaries in .channels subtree.\n      wrapSummaryInChannelsTree(summarizeResult);\n    } // Add data store's attributes to the summary.\n\n\n    const attributes = createAttributes(this.pkg, this.isInMemoryRoot(), this.disableIsolatedChannels);\n    addBlobToSummary(summarizeResult, dataStoreAttributesBlobName, JSON.stringify(attributes)); // Attach message needs the summary in ITree format. Convert the ISummaryTree into an ITree.\n\n    const snapshot = convertSummaryTreeToITree(summarizeResult.summary);\n    const message = {\n      id: this.id,\n      snapshot,\n      type: this.pkg[this.pkg.length - 1]\n    };\n    return message;\n  }\n\n  getInitialSnapshotDetails() {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      let snapshot = _this18.snapshotTree;\n      let attributes;\n      let isRootDataStore = false;\n\n      if (snapshot !== undefined) {\n        // Get the dataStore attributes.\n        // Note: storage can be undefined in special case while detached.\n        attributes = yield getFluidDataStoreAttributes(_this18.storage, snapshot);\n\n        if (hasIsolatedChannels(attributes)) {\n          snapshot = snapshot.trees[channelsTreeName];\n          assert(snapshot !== undefined, 0x1ff\n          /* \"isolated channels subtree should exist in local datastore snapshot\" */\n          );\n        }\n\n        if (_this18.pkg === undefined) {\n          _this18.pkg = JSON.parse(attributes.pkg); // If there is no isRootDataStore in the attributes blob, set it to true. This ensures that data\n          // stores in older documents are not garbage collected incorrectly. This may lead to additional\n          // roots in the document but they won't break.\n\n          if ((_a = attributes.isRootDataStore) !== null && _a !== void 0 ? _a : true) {\n            isRootDataStore = true;\n\n            _this18.setInMemoryRoot();\n          }\n        }\n      }\n\n      assert(_this18.pkg !== undefined, 0x152\n      /* \"pkg should be available in local data store\" */\n      );\n      return {\n        pkg: _this18.pkg,\n        isRootDataStore,\n        snapshot\n      };\n    })();\n  }\n  /**\n   * @deprecated - Renamed to getBaseGCDetails.\n   */\n\n\n  getInitialGCSummaryDetails() {\n    return _asyncToGenerator(function* () {\n      // Local data store does not have initial summary.\n      return {};\n    })();\n  }\n\n  getBaseGCDetails() {\n    return _asyncToGenerator(function* () {\n      // Local data store does not have initial summary.\n      return {};\n    })();\n  }\n\n}\n/**\n * context implementation for \"attached\" data store runtime.\n * Various workflows (snapshot creation, requests) result in .realize() being called\n * on context, resulting in instantiation and attachment of runtime.\n * Runtime is created using data store factory that is associated with this context.\n */\n\nexport class LocalFluidDataStoreContext extends LocalFluidDataStoreContextBase {\n  constructor(props) {\n    super(props);\n  }\n\n}\n/**\n * Detached context. Data Store runtime will be attached to it by attachRuntime() call\n * Before attachment happens, this context is not associated with particular type of runtime\n * or factory, i.e. it's package path is undefined.\n * Attachment process provides all missing parts - package path, data store runtime, and data store factory\n */\n\nexport class LocalDetachedFluidDataStoreContext extends LocalFluidDataStoreContextBase {\n  constructor(props) {\n    super(props);\n    this.detachedRuntimeCreation = true;\n  }\n\n  attachRuntime(registry, dataStoreChannel) {\n    var _superprop_getBindRuntime = () => super.bindRuntime,\n        _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      assert(_this19.detachedRuntimeCreation, 0x154\n      /* \"runtime creation is already attached\" */\n      );\n      assert(_this19.channelDeferred === undefined, 0x155\n      /* \"channel deferral is already set\" */\n      );\n      const factory = registry.IFluidDataStoreFactory;\n      const entry = yield _this19.factoryFromPackagePath(_this19.pkg);\n      assert(entry.factory === factory, 0x156\n      /* \"Unexpected factory for package path\" */\n      );\n      assert(_this19.registry === undefined, 0x157\n      /* \"datastore registry already attached\" */\n      );\n      _this19.registry = entry.registry;\n      _this19.detachedRuntimeCreation = false;\n      _this19.channelDeferred = new Deferred();\n\n      _superprop_getBindRuntime().call(_this19, dataStoreChannel);\n\n      if (yield _this19.isRoot()) {\n        // back-compat 0.59.1000 - makeVisibleAndAttachGraph was added in this version to IFluidDataStoreChannel.\n        // For older versions, we still have to call bindToContext.\n        if (dataStoreChannel.makeVisibleAndAttachGraph !== undefined) {\n          dataStoreChannel.makeVisibleAndAttachGraph();\n        } else {\n          dataStoreChannel.bindToContext();\n        }\n      }\n    })();\n  }\n\n  getInitialSnapshotDetails() {\n    var _superprop_getGetInitialSnapshotDetails = () => super.getInitialSnapshotDetails,\n        _this20 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this20.detachedRuntimeCreation) {\n        throw new Error(\"Detached Fluid Data Store context can't be realized! Please attach runtime first!\");\n      }\n\n      return _superprop_getGetInitialSnapshotDetails().call(_this20);\n    })();\n  }\n\n} //# sourceMappingURL=dataStoreContext.js.map","map":null,"metadata":{},"sourceType":"module"}