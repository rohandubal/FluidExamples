{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { assert, LazyPromise, Timer } from \"@fluidframework/common-utils\";\nimport { ClientSessionExpiredError, DataProcessingError, UsageError } from \"@fluidframework/container-utils\";\nimport { cloneGCData, concatGarbageCollectionStates, concatGarbageCollectionData, runGarbageCollection, unpackChildNodesGCDetails } from \"@fluidframework/garbage-collector\";\nimport { SummaryType } from \"@fluidframework/protocol-definitions\";\nimport { gcBlobKey } from \"@fluidframework/runtime-definitions\";\nimport { mergeStats, SummaryTreeBuilder } from \"@fluidframework/runtime-utils\";\nimport { ChildLogger, loggerToMonitoringContext, PerformanceEvent, TelemetryDataTag } from \"@fluidframework/telemetry-utils\";\nimport { RuntimeHeaders } from \"./containerRuntime\";\nimport { getSummaryForDatastores } from \"./dataStores\";\nimport { getGCVersion, metadataBlobName, dataStoreAttributesBlobName } from \"./summaryFormat\";\n/** This is the current version of garbage collection. */\n\nconst GCVersion = 1; // The key for the GC tree in summary.\n\nexport const gcTreeKey = \"gc\"; // They prefix for GC blobs in the GC tree in summary.\n\nexport const gcBlobPrefix = \"__gc\"; // Feature gate key to turn GC on / off.\n\nconst runGCKey = \"Fluid.GarbageCollection.RunGC\"; // Feature gate key to turn GC sweep on / off.\n\nconst runSweepKey = \"Fluid.GarbageCollection.RunSweep\"; // Feature gate key to turn GC test mode on / off.\n\nconst gcTestModeKey = \"Fluid.GarbageCollection.GCTestMode\"; // Feature gate key to write GC data at the root of the summary tree.\n\nconst writeAtRootKey = \"Fluid.GarbageCollection.WriteDataAtRoot\"; // Feature gate key to expire a session after a set period of time.\n\nexport const runSessionExpiryKey = \"Fluid.GarbageCollection.RunSessionExpiry\"; // Feature gate key to disable expiring session after a set period of time, even if expiry value is present\n\nexport const disableSessionExpiryKey = \"Fluid.GarbageCollection.DisableSessionExpiry\"; // Feature gate key to write the gc blob as a handle if the data is the same.\n\nexport const trackGCStateKey = \"Fluid.GarbageCollection.TrackGCState\"; // Feature gate key to turn GC sweep log off.\n\nconst disableSweepLogKey = \"Fluid.GarbageCollection.DisableSweepLog\"; // One day in milliseconds.\n\nexport const oneDayMs = 1 * 24 * 60 * 60 * 1000;\nconst defaultInactiveTimeoutMs = 7 * oneDayMs; // 7 days\n\nexport const defaultSessionExpiryDurationMs = 30 * oneDayMs; // 30 days\n\n/** The types of GC nodes in the GC reference graph. */\n\nexport const GCNodeType = {\n  // Nodes that are for data stores.\n  DataStore: \"DataStore\",\n  // Nodes that are within a data store. For example, DDS nodes.\n  SubDataStore: \"SubDataStore\",\n  // Nodes that are for attachment blobs, i.e., blobs uploaded via BlobManager.\n  Blob: \"Blob\",\n  // Nodes that are neither of the above. For example, root node.\n  Other: \"Other\"\n};\n/** The state of node that is unreferenced. */\n\nconst UnreferencedState = {\n  /** The node is active, i.e., it can become referenced again. */\n  Active: \"Active\",\n\n  /** The node is inactive, i.e., it should not become referenced. */\n  Inactive: \"Inactive\",\n\n  /** The node is ready to be deleted by the sweep phase. */\n  SweepReady: \"SweepReady\"\n};\n/**\n * Helper class that tracks the state of an unreferenced node such as the time it was unreferenced and if it can\n * be deleted by the sweep phase.\n */\n\nclass UnreferencedStateTracker {\n  constructor(unreferencedTimestampMs,\n  /** The time after which node transitions to Inactive state. */\n  inactiveTimeoutMs,\n  /** The time after which node transitions to SweepReady state; undefined if session expiry is disabled. */\n  sweepTimeoutMs,\n  /** The current reference timestamp; undefined if no ops have ever been processed which can happen in tests. */\n  currentReferenceTimestampMs) {\n    this.unreferencedTimestampMs = unreferencedTimestampMs;\n    this.inactiveTimeoutMs = inactiveTimeoutMs;\n    this.sweepTimeoutMs = sweepTimeoutMs;\n    this._state = UnreferencedState.Active; // If there is no current reference timestamp, don't track the node's unreferenced state. This will happen\n    // later when updateTracking is called with a reference timestamp.\n\n    if (currentReferenceTimestampMs !== undefined) {\n      this.updateTracking(currentReferenceTimestampMs);\n    }\n  }\n\n  get state() {\n    return this._state;\n  }\n  /* Updates the unreferenced state based on the provided timestamp. */\n\n\n  updateTracking(currentReferenceTimestampMs) {\n    const unreferencedDurationMs = currentReferenceTimestampMs - this.unreferencedTimestampMs; // If the node has been unreferenced for sweep timeout amount of time, update the state to SweepReady.\n\n    if (this.sweepTimeoutMs !== undefined && unreferencedDurationMs >= this.sweepTimeoutMs) {\n      this._state = UnreferencedState.SweepReady;\n      this.clearTimers();\n      return;\n    } // If the node has been unreferenced for inactive timeoutMs amount of time, update the state to inactive.\n    // Also, start a timer for the sweep timeout.\n\n\n    if (unreferencedDurationMs >= this.inactiveTimeoutMs) {\n      this._state = UnreferencedState.Inactive;\n      this.clearTimers();\n\n      if (this.sweepTimeoutMs !== undefined) {\n        setLongTimeout(this.sweepTimeoutMs - unreferencedDurationMs, () => {\n          this._state = UnreferencedState.SweepReady;\n        }, timer => {\n          this.sweepTimer = timer;\n        });\n      }\n\n      return;\n    } // The node is still active. Start the inactive timer for the remaining duration.\n\n\n    const remainingDurationMs = this.inactiveTimeoutMs - unreferencedDurationMs;\n\n    if (this.inactiveTimer === undefined) {\n      const inactiveTimeoutHandler = () => {\n        this._state = UnreferencedState.Inactive; // After the node becomes inactive, start the sweep timer after which the node will be ready for sweep.\n\n        if (this.sweepTimeoutMs !== undefined) {\n          setLongTimeout(this.sweepTimeoutMs - this.inactiveTimeoutMs, () => {\n            this._state = UnreferencedState.SweepReady;\n          }, timer => {\n            this.sweepTimer = timer;\n          });\n        }\n      };\n\n      this.inactiveTimer = new Timer(remainingDurationMs, () => inactiveTimeoutHandler());\n    }\n\n    this.inactiveTimer.restart(remainingDurationMs);\n  }\n\n  clearTimers() {\n    var _a;\n\n    (_a = this.inactiveTimer) === null || _a === void 0 ? void 0 : _a.clear();\n\n    if (this.sweepTimer !== undefined) {\n      clearTimeout(this.sweepTimer);\n    }\n  }\n  /** Stop tracking this node. Reset the unreferenced timers and state, if any. */\n\n\n  stopTracking() {\n    this.clearTimers();\n    this._state = UnreferencedState.Active;\n  }\n\n}\n/**\n * The garbage collector for the container runtime. It consolidates the garbage collection functionality and maintains\n * its state across summaries.\n *\n * Node - represented as nodeId, it's a node on the GC graph\n * Outbound Route - a path from one node to another node, think `nodeA` -\\> `nodeB`\n * Graph - all nodes with their respective routes\n *             GC Graph\n *\n *               Node\n *        NodeId = \"datastore1\"\n *           /             \\\\\n *    OutboundRoute   OutboundRoute\n *         /                 \\\\\n *       Node               Node\n *  NodeId = \"dds1\"     NodeId = \"dds2\"\n */\n\n\nexport class GarbageCollector {\n  constructor(createParams) {\n    var _this = this;\n\n    var _a, _b, _c, _d, _e, _f, _g;\n    /**\n     * Tells whether the GC data should be written to the root of the summary tree.\n     */\n\n\n    this._writeDataAtRoot = true;\n    /**\n     * Tells whether the initial GC state needs to be reset. This can happen under 2 conditions:\n     * 1. The base snapshot contains GC state but GC is disabled. This will happen the first time GC is disabled after\n     *    it was enabled before. GC state needs to be removed from summary and all nodes should be marked referenced.\n     * 2. The base snapshot does not have GC state but GC is enabled. This will happen the very first time GC runs on\n     *    a document and the first time GC is enabled after is was disabled before.\n     *\n     * Note that the state needs reset only for the very first time summary is generated by this client. After that, the\n     * state will be up-to-date and this flag will be reset.\n    */\n\n    this.initialStateNeedsReset = false; // The current GC version that this container is running.\n\n    this.currentGCVersion = GCVersion; // Keeps a list of references (edges in the GC graph) between GC runs. Each entry has a node id and a list of\n    // outbound routes from that node.\n\n    this.newReferencesSinceLastRun = new Map(); // Map of node ids to their unreferenced state tracker.\n\n    this.unreferencedNodesState = new Map(); // Keeps track of unreferenced events that are logged for a node. This is used to limit the log generation to one\n    // per event per node.\n\n    this.loggedUnreferencedEvents = new Set(); // Queue for unreferenced events that should be logged the next time GC runs.\n\n    this.pendingEventsQueue = []; // The number of times GC has successfully completed on this instance of GarbageCollector.\n\n    this.completedRuns = 0;\n    this.runtime = createParams.runtime;\n    this.isSummarizerClient = createParams.isSummarizerClient;\n    this.gcOptions = createParams.gcOptions;\n    this.getNodePackagePath = createParams.getNodePackagePath;\n    this.getLastSummaryTimestampMs = createParams.getLastSummaryTimestampMs;\n    const baseSnapshot = createParams.baseSnapshot;\n    const metadata = createParams.metadata;\n    const readAndParseBlob = createParams.readAndParseBlob;\n    this.mc = loggerToMonitoringContext(ChildLogger.create(createParams.baseLogger, \"GarbageCollector\", {\n      all: {\n        completedGCRuns: () => this.completedRuns\n      }\n    }));\n    let prevSummaryGCVersion;\n    /**\n     * The following GC state is enabled during container creation and cannot be changed throughout its lifetime:\n     * 1. Whether running GC mark phase is allowed or not.\n     * 2. Whether running GC sweep phase is allowed or not.\n     * 3. Whether GC session expiry is enabled or not.\n     * For existing containers, we get this information from the metadata blob of its summary.\n     */\n\n    if (createParams.existing) {\n      prevSummaryGCVersion = getGCVersion(metadata); // Existing documents which did not have metadata blob or had GC disabled have version as 0. For all\n      // other existing documents, GC is enabled.\n\n      this.gcEnabled = prevSummaryGCVersion > 0;\n      this.sweepEnabled = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.sweepEnabled) !== null && _a !== void 0 ? _a : false;\n      this.sessionExpiryTimeoutMs = metadata === null || metadata === void 0 ? void 0 : metadata.sessionExpiryTimeoutMs;\n    } else {\n      // Sweep should not be enabled without enabling GC mark phase. We could silently disable sweep in this\n      // scenario but explicitly failing makes it clearer and promotes correct usage.\n      if (this.gcOptions.sweepAllowed && this.gcOptions.gcAllowed === false) {\n        throw new UsageError(\"GC sweep phase cannot be enabled without enabling GC mark phase\");\n      } // For new documents, GC is enabled by default. It can be explicitly disabled by setting the gcAllowed\n      // flag in GC options to false.\n\n\n      this.gcEnabled = this.gcOptions.gcAllowed !== false; // The sweep phase has to be explicitly enabled by setting the sweepAllowed flag in GC options to true.\n\n      this.sweepEnabled = this.gcOptions.sweepAllowed === true; // Set the Session Expiry only if the flag is enabled or the test option is set.\n\n      if (this.mc.config.getBoolean(runSessionExpiryKey) && this.gcEnabled) {\n        this.sessionExpiryTimeoutMs = defaultSessionExpiryDurationMs;\n      }\n    } // If session expiry is enabled, we need to close the container when the session expiry timeout expires.\n\n\n    if (this.sessionExpiryTimeoutMs !== undefined && this.mc.config.getBoolean(disableSessionExpiryKey) !== true) {\n      // If Test Override config is set, override Session Expiry timeout.\n      const overrideSessionExpiryTimeoutMs = this.mc.config.getNumber(\"Fluid.GarbageCollection.TestOverride.SessionExpiryMs\");\n      const timeoutMs = overrideSessionExpiryTimeoutMs !== null && overrideSessionExpiryTimeoutMs !== void 0 ? overrideSessionExpiryTimeoutMs : this.sessionExpiryTimeoutMs;\n      setLongTimeout(timeoutMs, () => {\n        this.runtime.closeFn(new ClientSessionExpiredError(`Client session expired.`, timeoutMs));\n      }, timer => {\n        this.sessionExpiryTimer = timer;\n      });\n      /**\n       * Sweep timeout is the time after which unreferenced content can be swept.\n       * Sweep timeout = session expiry timeout + snapshot cache expiry timeout + one day buffer. The buffer is\n       * added to account for any clock skew. We use server timestamps throughout so the skew should be minimal\n       * but make it one day to be safe.\n       */\n\n      if (createParams.snapshotCacheExpiryMs !== undefined) {\n        this.sweepTimeoutMs = this.sessionExpiryTimeoutMs + createParams.snapshotCacheExpiryMs + oneDayMs;\n      }\n    } // For existing document, the latest summary is the one that we loaded from. So, use its GC version as the\n    // latest tracked GC version. For new documents, we will be writing the first summary with the current version.\n\n\n    this.latestSummaryGCVersion = prevSummaryGCVersion !== null && prevSummaryGCVersion !== void 0 ? prevSummaryGCVersion : this.currentGCVersion;\n    /**\n     * Whether GC should run or not. The following conditions have to be met to run sweep:\n     * 1. GC should be enabled for this container.\n     * 2. GC should not be disabled via disableGC GC option.\n     * These conditions can be overridden via runGCKey feature flag.\n     */\n\n    this.shouldRunGC = (_b = this.mc.config.getBoolean(runGCKey)) !== null && _b !== void 0 ? _b : // GC must be enabled for the document.\n    this.gcEnabled // GC must not be disabled via GC options.\n    && !this.gcOptions.disableGC;\n    /**\n     * Whether sweep should run or not. The following conditions have to be met to run sweep:\n     * 1. Overall GC or mark phase must be enabled (this.shouldRunGC).\n     * 2. Sweep timeout should be available. Without this, we wouldn't know when an object should be deleted.\n     * 3. Sweep should be enabled for this container (this.sweepEnabled). This can be overridden via runSweep\n     *    feature flag.\n     */\n\n    this.shouldRunSweep = this.shouldRunGC && this.sweepTimeoutMs !== undefined && ((_c = this.mc.config.getBoolean(runSweepKey)) !== null && _c !== void 0 ? _c : this.sweepEnabled);\n    this.trackGCState = this.mc.config.getBoolean(trackGCStateKey) === true; // Override inactive timeout if test config or gc options to override it is set.\n\n    this.inactiveTimeoutMs = (_e = (_d = this.mc.config.getNumber(\"Fluid.GarbageCollection.TestOverride.InactiveTimeoutMs\")) !== null && _d !== void 0 ? _d : this.gcOptions.inactiveTimeoutMs) !== null && _e !== void 0 ? _e : defaultInactiveTimeoutMs; // Inactive timeout must be greater than sweep timeout since a node goes from active -> inactive -> sweep ready.\n\n    if (this.sweepTimeoutMs !== undefined && this.inactiveTimeoutMs > this.sweepTimeoutMs) {\n      throw new UsageError(\"inactive timeout should not be greated than the sweep timeout\");\n    } // Whether we are running in test mode. In this mode, unreferenced nodes are immediately deleted.\n\n\n    this.testMode = (_f = this.mc.config.getBoolean(gcTestModeKey)) !== null && _f !== void 0 ? _f : this.gcOptions.runGCInTestMode === true; // GC state is written into root of the summary tree by default. Can be overridden via feature flag for now.\n\n    this._writeDataAtRoot = (_g = this.mc.config.getBoolean(writeAtRootKey)) !== null && _g !== void 0 ? _g : true;\n\n    if (this._writeDataAtRoot) {\n      // The GC state needs to be reset if the base snapshot contains GC tree and GC is disabled or it doesn't\n      // contain GC tree and GC is enabled.\n      const gcTreePresent = (baseSnapshot === null || baseSnapshot === void 0 ? void 0 : baseSnapshot.trees[gcTreeKey]) !== undefined;\n      this.initialStateNeedsReset = gcTreePresent !== this.shouldRunGC;\n    } // Get the GC state from the GC blob in the base snapshot. Use LazyPromise because we only want to do\n    // this once since it involves fetching blobs from storage which is expensive.\n\n\n    const baseSummaryStateP = new LazyPromise( /*#__PURE__*/_asyncToGenerator(function* () {\n      var _a;\n\n      if (baseSnapshot === undefined) {\n        return undefined;\n      } // For newer documents, GC data should be present in the GC tree in the root of the snapshot.\n\n\n      const gcSnapshotTree = baseSnapshot.trees[gcTreeKey];\n\n      if (gcSnapshotTree !== undefined) {\n        // If the GC tree is written at root, we should also do the same.\n        _this._writeDataAtRoot = true;\n        const baseGCState = yield getGCStateFromSnapshot(gcSnapshotTree, readAndParseBlob);\n\n        if (_this.trackGCState) {\n          _this.latestSerializedSummaryState = JSON.stringify(generateSortedGCState(baseGCState));\n        }\n\n        return baseGCState;\n      } // back-compat - Older documents will have the GC blobs in each data store's summary tree. Get them and\n      // consolidate into IGarbageCollectionState format.\n      // Add a node for the root node that is not present in older snapshot format.\n\n\n      const gcState = {\n        gcNodes: {\n          \"/\": {\n            outboundRoutes: []\n          }\n        }\n      };\n      const dataStoreSnapshotTree = getSummaryForDatastores(baseSnapshot, metadata);\n      assert(dataStoreSnapshotTree !== undefined, 0x2a8\n      /* \"Expected data store snapshot tree in base snapshot\" */\n      );\n\n      for (const [dsId, dsSnapshotTree] of Object.entries(dataStoreSnapshotTree.trees)) {\n        const blobId = dsSnapshotTree.blobs[gcBlobKey];\n\n        if (blobId === undefined) {\n          continue;\n        }\n\n        const gcSummaryDetails = yield readAndParseBlob(blobId); // If there are no nodes for this data store, skip it.\n\n        if (((_a = gcSummaryDetails.gcData) === null || _a === void 0 ? void 0 : _a.gcNodes) === undefined) {\n          continue;\n        }\n\n        const dsRootId = `/${dsId}`; // Since we used to write GC data at data store level, we won't have an entry for the root (\"/\").\n        // Construct that entry by adding root data store ids to its outbound routes.\n\n        const initialSnapshotDetails = yield readAndParseBlob(dsSnapshotTree.blobs[dataStoreAttributesBlobName]);\n\n        if (initialSnapshotDetails.isRootDataStore) {\n          gcState.gcNodes[\"/\"].outboundRoutes.push(dsRootId);\n        }\n\n        for (const [id, outboundRoutes] of Object.entries(gcSummaryDetails.gcData.gcNodes)) {\n          // Prefix the data store id to the GC node ids to make them relative to the root from being\n          // relative to the data store. Similar to how its done in DataStore::getGCData.\n          const rootId = id === \"/\" ? dsRootId : `${dsRootId}${id}`;\n          gcState.gcNodes[rootId] = {\n            outboundRoutes: Array.from(outboundRoutes)\n          };\n        }\n\n        assert(gcState.gcNodes[dsRootId] !== undefined, 0x2a9\n        /* GC nodes for data store not in GC blob */\n        );\n        gcState.gcNodes[dsRootId].unreferencedTimestampMs = gcSummaryDetails.unrefTimestamp;\n      } // If there is only one node (root node just added above), either GC is disabled or we are loading from the\n      // very first summary generated by detached container. In both cases, GC was not run - return undefined.\n\n\n      return Object.keys(gcState.gcNodes).length === 1 ? undefined : gcState;\n    }));\n    /**\n     * Set up the initializer which initializes the base GC state from the base snapshot. Note that the reference\n     * timestamp maybe from old ops which were not summarized and stored in the file. So, the unreferenced state\n     * may be out of date. This is fine because the state is updated every time GC runs based on the time then.\n     */\n\n    this.initializeBaseStateP = new LazyPromise( /*#__PURE__*/_asyncToGenerator(function* () {\n      const currentReferenceTimestampMs = _this.runtime.getCurrentReferenceTimestampMs();\n\n      const baseState = yield baseSummaryStateP;\n\n      if (baseState === undefined) {\n        return;\n      }\n\n      const gcNodes = {};\n\n      for (const [nodeId, nodeData] of Object.entries(baseState.gcNodes)) {\n        if (nodeData.unreferencedTimestampMs !== undefined) {\n          _this.unreferencedNodesState.set(nodeId, new UnreferencedStateTracker(nodeData.unreferencedTimestampMs, _this.inactiveTimeoutMs, _this.sweepTimeoutMs, currentReferenceTimestampMs));\n        }\n\n        gcNodes[nodeId] = Array.from(nodeData.outboundRoutes);\n      }\n\n      _this.previousGCDataFromLastRun = {\n        gcNodes\n      };\n    })); // Get the GC details for each node from the GC state in the base summary. This is returned in getBaseGCDetails\n    // which the caller uses to initialize each node's GC state.\n\n    this.baseGCDetailsP = new LazyPromise( /*#__PURE__*/_asyncToGenerator(function* () {\n      const baseState = yield baseSummaryStateP;\n\n      if (baseState === undefined) {\n        return new Map();\n      }\n\n      const gcNodes = {};\n\n      for (const [nodeId, nodeData] of Object.entries(baseState.gcNodes)) {\n        gcNodes[nodeId] = Array.from(nodeData.outboundRoutes);\n      } // Run GC on the nodes in the base summary to get the routes used in each node in the container.\n      // This is an optimization for space (vs performance) wherein we don't need to store the used routes of\n      // each node in the summary.\n\n\n      const usedRoutes = runGarbageCollection(gcNodes, [\"/\"]).referencedNodeIds;\n      const baseGCDetailsMap = unpackChildNodesGCDetails({\n        gcData: {\n          gcNodes\n        },\n        usedRoutes\n      }); // Currently, the nodes may write the GC data. So, we need to update it's base GC details with the\n      // unreferenced timestamp. Once we start writing the GC data here, we won't need to do this anymore.\n\n      for (const [nodeId, nodeData] of Object.entries(baseState.gcNodes)) {\n        if (nodeData.unreferencedTimestampMs !== undefined) {\n          const dataStoreGCDetails = baseGCDetailsMap.get(nodeId.slice(1));\n\n          if (dataStoreGCDetails !== undefined) {\n            dataStoreGCDetails.unrefTimestamp = nodeData.unreferencedTimestampMs;\n          }\n        }\n      }\n\n      return baseGCDetailsMap;\n    })); // Log all the GC options and the state determined by the garbage collector. This is interesting only for the\n    // summarizer client since it is the only one that runs GC. It also helps keep the telemetry less noisy.\n\n    const gcConfigProps = JSON.stringify(Object.assign({\n      gcEnabled: this.gcEnabled,\n      sweepEnabled: this.sweepEnabled,\n      runGC: this.shouldRunGC,\n      runSweep: this.shouldRunSweep,\n      writeAtRoot: this._writeDataAtRoot,\n      testMode: this.testMode,\n      sessionExpiry: this.sessionExpiryTimeoutMs,\n      inactiveTimeout: this.inactiveTimeoutMs,\n      existing: createParams.existing,\n      trackGCState: this.trackGCState\n    }, this.gcOptions));\n\n    if (this.isSummarizerClient) {\n      this.mc.logger.sendTelemetryEvent({\n        eventName: \"GarbageCollectorLoaded\",\n        gcConfigs: gcConfigProps\n      });\n    } // Initialize the base state that is used to detect when inactive objects are used.\n\n\n    if (this.shouldRunGC) {\n      this.initializeBaseStateP.catch(error => {\n        const dpe = DataProcessingError.wrapIfUnrecognized(error, \"FailedToInitializeGC\");\n        dpe.addTelemetryProperties({\n          gcConfigs: gcConfigProps\n        });\n        throw dpe;\n      });\n    }\n  }\n\n  static create(createParams) {\n    return new GarbageCollector(createParams);\n  }\n  /**\n   * Tells whether the GC state needs to be reset in the next summary. We need to do this if:\n   * 1. GC was enabled and is now disabled. The GC state needs to be removed and everything becomes referenced.\n   * 2. GC was disabled and is now enabled. The GC state needs to be regenerated and added to summary.\n   * 3. The GC version in the latest summary is different from the current GC version. This can happen if:\n   *    3.1. The summary this client loaded with has data from a different GC version.\n   *    3.2. This client's latest summary was updated from a snapshot that has a different GC version.\n   */\n\n\n  get summaryStateNeedsReset() {\n    return this.initialStateNeedsReset || this.shouldRunGC && this.latestSummaryGCVersion !== this.currentGCVersion;\n  }\n\n  get writeDataAtRoot() {\n    return this._writeDataAtRoot;\n  }\n  /**\n   * Runs garbage collection and updates the reference / used state of the nodes in the container.\n   * @returns the number of data stores that have been marked as unreferenced.\n   */\n\n\n  collectGarbage(options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        fullGC = _this2.gcOptions.runFullGC === true || _this2.summaryStateNeedsReset\n      } = options;\n      const logger = options.logger ? ChildLogger.create(options.logger, undefined, {\n        all: {\n          completedGCRuns: () => _this2.completedRuns\n        }\n      }) : _this2.mc.logger;\n      return PerformanceEvent.timedExecAsync(logger, {\n        eventName: \"GarbageCollection\"\n      }, /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (event) {\n          yield _this2.runPreGCSteps(); // Get the runtime's GC data and run GC on the reference graph in it.\n\n          const gcData = yield _this2.runtime.getGCData(fullGC);\n          const gcResult = runGarbageCollection(gcData.gcNodes, [\"/\"]);\n          const gcStats = yield _this2.runPostGCSteps(gcData, gcResult, logger);\n          event.end(Object.assign({}, gcStats));\n          _this2.completedRuns++;\n          return gcStats;\n        });\n\n        return function (_x) {\n          return _ref4.apply(this, arguments);\n        };\n      }(), {\n        end: true,\n        cancel: \"error\"\n      });\n    })();\n  }\n\n  runPreGCSteps() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // Ensure that base state has been initialized.\n      yield _this3.initializeBaseStateP; // Let the runtime update its pending state before GC runs.\n\n      yield _this3.runtime.updateStateBeforeGC();\n    })();\n  }\n\n  runPostGCSteps(gcData, gcResult, logger) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // Generate statistics from the current run. This is done before updating the current state because it\n      // generates some of its data based on previous state of the system.\n      const gcStats = _this4.generateStats(gcResult); // Update the state since the last GC run. There can be nodes that were referenced between the last and\n      // the current run. We need to identify than and update their unreferenced state if needed.\n\n\n      _this4.updateStateSinceLastRun(gcData, logger); // Update the current state and update the runtime of all routes or ids that used as per the GC run.\n\n\n      const currentReferenceTimestampMs = _this4.runtime.getCurrentReferenceTimestampMs();\n\n      _this4.updateCurrentState(gcData, gcResult, currentReferenceTimestampMs);\n\n      _this4.runtime.updateUsedRoutes(gcResult.referencedNodeIds, currentReferenceTimestampMs); // Log events for objects that are ready to be deleted by sweep. When we have sweep enabled, we will\n      // delete these objects here instead.\n\n\n      _this4.logSweepEvents(logger, currentReferenceTimestampMs); // If we are running in GC test mode, delete objects for unused routes. This enables testing scenarios\n      // involving access to deleted data.\n\n\n      if (_this4.testMode) {\n        _this4.runtime.deleteUnusedRoutes(gcResult.deletedNodeIds);\n      } // Log pending unreferenced events such as a node being used after inactive. This is done after GC runs and\n      // updates its state so that we don't send false positives based on intermediate state. For example, we may get\n      // reference to an unreferenced node from another unreferenced node which means the node wasn't revived.\n\n\n      yield _this4.logUnreferencedEvents(logger);\n      return gcStats;\n    })();\n  }\n  /**\n   * Summarizes the GC data and returns it as a summary tree.\n   * We current write the entire GC state in a single blob. This can be modified later to write multiple\n   * blobs. All the blob keys should start with `gcBlobPrefix`.\n   */\n\n\n  summarize(fullTree, trackState, telemetryContext) {\n    var _a;\n\n    if (!this.shouldRunGC || this.previousGCDataFromLastRun === undefined) {\n      return;\n    }\n\n    const gcState = {\n      gcNodes: {}\n    };\n\n    for (const [nodeId, outboundRoutes] of Object.entries(this.previousGCDataFromLastRun.gcNodes)) {\n      gcState.gcNodes[nodeId] = {\n        outboundRoutes,\n        unreferencedTimestampMs: (_a = this.unreferencedNodesState.get(nodeId)) === null || _a === void 0 ? void 0 : _a.unreferencedTimestampMs\n      };\n    }\n\n    const newSerializedSummaryState = JSON.stringify(generateSortedGCState(gcState));\n    /**\n     * As an optimization if the GC tree hasn't changed and we're tracking the gc state, return a tree handle\n     * instead of returning the whole GC tree. If there are changes, then we want to return the whole tree.\n     */\n\n    if (this.trackGCState) {\n      this.pendingSerializedSummaryState = newSerializedSummaryState;\n\n      if (this.latestSerializedSummaryState !== undefined && this.latestSerializedSummaryState === newSerializedSummaryState && !fullTree && trackState) {\n        const stats = mergeStats();\n        stats.handleNodeCount++;\n        return {\n          summary: {\n            type: SummaryType.Handle,\n            handle: `/${gcTreeKey}`,\n            handleType: SummaryType.Tree\n          },\n          stats\n        };\n      }\n    }\n\n    const builder = new SummaryTreeBuilder();\n    builder.addBlob(`${gcBlobPrefix}_root`, newSerializedSummaryState);\n    return builder.getSummaryTree();\n  }\n\n  getMetadata() {\n    return {\n      /**\n       * If GC is enabled, the GC data is written using the current GC version and that is the gcFeature that goes\n       * into the metadata blob. If GC is disabled, the gcFeature is 0.\n       */\n      gcFeature: this.gcEnabled ? this.currentGCVersion : 0,\n      sessionExpiryTimeoutMs: this.sessionExpiryTimeoutMs,\n      sweepEnabled: this.sweepEnabled\n    };\n  }\n  /**\n   * Returns a map of node ids to their base GC details generated from the base summary. This is used by the caller\n   * to initialize the GC state of the nodes.\n   */\n\n\n  getBaseGCDetails() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this5.baseGCDetailsP;\n    })();\n  }\n  /**\n   * Called when the latest summary of the system has been refreshed. This will be used to update the state of the\n   * latest summary tracked.\n   */\n\n\n  latestSummaryStateRefreshed(result, readAndParseBlob) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this6.shouldRunGC || !result.latestSummaryUpdated) {\n        return;\n      } // If the summary was tracked by this client, it was the one that generated the summary in the first place.\n      // Basically, it was written in the current GC version.\n\n\n      if (result.wasSummaryTracked) {\n        _this6.latestSummaryGCVersion = _this6.currentGCVersion;\n        _this6.initialStateNeedsReset = false;\n\n        if (_this6.trackGCState) {\n          _this6.latestSerializedSummaryState = _this6.pendingSerializedSummaryState;\n          _this6.pendingSerializedSummaryState = undefined;\n        }\n\n        return;\n      } // If the summary was not tracked by this client, update latest GC version and blob from the snapshot in the\n      // result as that is now the latest summary.\n\n\n      const snapshot = result.snapshot;\n      const metadataBlobId = snapshot.blobs[metadataBlobName];\n\n      if (metadataBlobId) {\n        const metadata = yield readAndParseBlob(metadataBlobId);\n        _this6.latestSummaryGCVersion = getGCVersion(metadata);\n      }\n\n      const gcSnapshotTree = snapshot.trees[gcTreeKey];\n\n      if (gcSnapshotTree !== undefined && _this6.trackGCState) {\n        const latestGCState = yield getGCStateFromSnapshot(gcSnapshotTree, readAndParseBlob);\n        _this6.latestSerializedSummaryState = JSON.stringify(generateSortedGCState(latestGCState));\n      } else {\n        _this6.latestSerializedSummaryState = undefined;\n      }\n\n      _this6.pendingSerializedSummaryState = undefined;\n    })();\n  }\n  /**\n   * Called when a node with the given id is updated. If the node is inactive, log an error.\n   * @param nodePath - The id of the node that changed.\n   * @param reason - Whether the node was loaded or changed.\n   * @param timestampMs - The timestamp when the node changed.\n   * @param packagePath - The package path of the node. This may not be available if the node hasn't been loaded yet.\n   * @param requestHeaders - If the node was loaded via request path, the headers in the request.\n   */\n\n\n  nodeUpdated(nodePath, reason, timestampMs, packagePath, requestHeaders) {\n    if (!this.shouldRunGC) {\n      return;\n    }\n\n    const nodeStateTracker = this.unreferencedNodesState.get(nodePath);\n\n    if (nodeStateTracker && nodeStateTracker.state !== UnreferencedState.Active) {\n      this.inactiveNodeUsed(reason, nodePath, nodeStateTracker, undefined\n      /* fromNodeId */\n      , packagePath, timestampMs, requestHeaders);\n    }\n  }\n  /**\n   * Called when an outbound reference is added to a node. This is used to identify all nodes that have been\n   * referenced between summaries so that their unreferenced timestamp can be reset.\n   *\n   * @param fromNodePath - The node from which the reference is added.\n   * @param toNodePath - The node to which the reference is added.\n   */\n\n\n  addedOutboundReference(fromNodePath, toNodePath) {\n    var _a;\n\n    if (!this.shouldRunGC) {\n      return;\n    }\n\n    const outboundRoutes = (_a = this.newReferencesSinceLastRun.get(fromNodePath)) !== null && _a !== void 0 ? _a : [];\n    outboundRoutes.push(toNodePath);\n    this.newReferencesSinceLastRun.set(fromNodePath, outboundRoutes);\n    const nodeStateTracker = this.unreferencedNodesState.get(toNodePath);\n\n    if (nodeStateTracker && nodeStateTracker.state !== UnreferencedState.Active) {\n      this.inactiveNodeUsed(\"Revived\", toNodePath, nodeStateTracker, fromNodePath);\n    }\n  }\n\n  dispose() {\n    if (this.sessionExpiryTimer !== undefined) {\n      clearTimeout(this.sessionExpiryTimer);\n      this.sessionExpiryTimer = undefined;\n    }\n  }\n  /**\n   * Updates the state of the system as per the current GC run. It does the following:\n   * 1. Sets up the current GC state as per the gcData.\n   * 2. Starts tracking for nodes that have become unreferenced in this run.\n   * 3. Clears tracking for nodes that were unreferenced but became referenced in this run.\n   * @param gcData - The data representing the reference graph on which GC is run.\n   * @param gcResult - The result of the GC run on the gcData.\n   * @param currentReferenceTimestampMs - The timestamp to be used for unreferenced nodes' timestamp.\n   */\n\n\n  updateCurrentState(gcData, gcResult, currentReferenceTimestampMs) {\n    this.previousGCDataFromLastRun = cloneGCData(gcData);\n    this.newReferencesSinceLastRun.clear(); // Iterate through the referenced nodes and stop tracking if they were unreferenced before.\n\n    for (const nodeId of gcResult.referencedNodeIds) {\n      const nodeStateTracker = this.unreferencedNodesState.get(nodeId);\n\n      if (nodeStateTracker !== undefined) {\n        // Stop tracking so as to clear out any running timers.\n        nodeStateTracker.stopTracking(); // Delete the node as we don't need to track it any more.\n\n        this.unreferencedNodesState.delete(nodeId);\n      }\n    }\n    /**\n     * If there is no current reference time, skip tracking when a node becomes unreferenced. This would happen\n     * if no ops have been processed ever and we still try to run GC. If so, there is nothing interesting to track\n     * anyway.\n     */\n\n\n    if (currentReferenceTimestampMs === undefined) {\n      return;\n    }\n    /**\n     * If a node became unreferenced in this run, start tracking it.\n     * If a node was already unreferenced, update its tracking information. Since the current reference time is\n     * from the ops seen, this will ensure that we keep updating the unreferenced state as time moves forward.\n     */\n\n\n    for (const nodeId of gcResult.deletedNodeIds) {\n      const nodeStateTracker = this.unreferencedNodesState.get(nodeId);\n\n      if (nodeStateTracker === undefined) {\n        this.unreferencedNodesState.set(nodeId, new UnreferencedStateTracker(currentReferenceTimestampMs, this.inactiveTimeoutMs, this.sweepTimeoutMs, currentReferenceTimestampMs));\n      } else {\n        nodeStateTracker.updateTracking(currentReferenceTimestampMs);\n      }\n    }\n  }\n  /**\n   * Since GC runs periodically, the GC data that is generated only tells us the state of the world at that point in\n   * time. It's possible that nodes transition from `unreferenced -> referenced -> unreferenced` between two runs. The\n   * unreferenced timestamp of such nodes needs to be reset as they may have been accessed when they were referenced.\n   *\n   * This function identifies nodes that were referenced since last run and removes their unreferenced state, if any.\n   * If these nodes are currently unreferenced, they will be assigned new unreferenced state by the current run.\n   */\n\n\n  updateStateSinceLastRun(currentGCData, logger) {\n    // If we haven't run GC before there is nothing to do.\n    if (this.previousGCDataFromLastRun === undefined) {\n      return;\n    } // Find any references that haven't been identified correctly.\n\n\n    const missingExplicitReferences = this.findMissingExplicitReferences(currentGCData, this.previousGCDataFromLastRun, this.newReferencesSinceLastRun);\n\n    if (this.writeDataAtRoot && missingExplicitReferences.length > 0) {\n      missingExplicitReferences.forEach(missingExplicitReference => {\n        const event = {\n          eventName: \"gcUnknownOutboundReferences\",\n          gcNodeId: missingExplicitReference[0],\n          gcRoutes: JSON.stringify(missingExplicitReference[1])\n        };\n        logger.sendPerformanceEvent(event);\n      });\n    } // No references were added since the last run so we don't have to update reference states of any unreferenced\n    // nodes\n\n\n    if (this.newReferencesSinceLastRun.size === 0) {\n      return;\n    }\n    /**\n     * Generate a super set of the GC data that contains the nodes and edges from last run, plus any new node and\n     * edges that have been added since then. To do this, combine the GC data from the last run and the current\n     * run, and then add the references since last run.\n     *\n     * Note on why we need to combine the data from previous run, current run and all references in between -\n     * 1. We need data from last run because some of its references may have been deleted since then. If those\n     *    references added new outbound references before getting deleted, we need to detect them.\n     * 2. We need new outbound references since last run because some of them may have been deleted later. If those\n     *    references added new outbound references before getting deleted, we need to detect them.\n     * 3. We need data from the current run because currently we may not detect when DDSes are referenced:\n     *    - We don't require DDSes handles to be stored in a referenced DDS. For this, we need GC at DDS level\n     *      which is tracked by https://github.com/microsoft/FluidFramework/issues/8470.\n     *    - A new data store may have \"root\" DDSes already created and we don't detect them today.\n     */\n\n\n    const gcDataSuperSet = concatGarbageCollectionData(this.previousGCDataFromLastRun, currentGCData);\n    this.newReferencesSinceLastRun.forEach((outboundRoutes, sourceNodeId) => {\n      if (gcDataSuperSet.gcNodes[sourceNodeId] === undefined) {\n        gcDataSuperSet.gcNodes[sourceNodeId] = outboundRoutes;\n      } else {\n        gcDataSuperSet.gcNodes[sourceNodeId].push(...outboundRoutes);\n      }\n    });\n    /**\n     * Run GC on the above reference graph to find all nodes that are referenced. For each one, if they are\n     * unreferenced, stop tracking them and remove from unreferenced list.\n     * Some of these nodes may be unreferenced now and if so, the current run will add unreferenced state for them.\n     */\n\n    const gcResult = runGarbageCollection(gcDataSuperSet.gcNodes, [\"/\"]);\n\n    for (const nodeId of gcResult.referencedNodeIds) {\n      const nodeStateTracker = this.unreferencedNodesState.get(nodeId);\n\n      if (nodeStateTracker !== undefined) {\n        // Stop tracking so as to clear out any running timers.\n        nodeStateTracker.stopTracking(); // Delete the node as we don't need to track it any more.\n\n        this.unreferencedNodesState.delete(nodeId);\n      }\n    }\n  }\n  /**\n   * Finds all new references or outbound routes in the current graph that haven't been explicitly notified to GC.\n   * The principle is that every new reference or outbound route must be notified to GC via the\n   * addedOutboundReference method. It it hasn't, its a bug and we want to identify these scenarios.\n   *\n   * In more simple terms:\n   * Missing Explicit References = Current References - Previous References - Explicitly Added References;\n   *\n   * @param currentGCData - The GC data (reference graph) from the current GC run.\n   * @param previousGCData - The GC data (reference graph) from the previous GC run.\n   * @param explicitReferences - New references added explicity between the previous and the current run.\n   * @returns - a list of missing explicit references\n   */\n\n\n  findMissingExplicitReferences(currentGCData, previousGCData, explicitReferences) {\n    assert(previousGCData !== undefined, 0x2b7);\n    const currentGraph = Object.entries(currentGCData.gcNodes);\n    const missingExplicitReferences = [];\n    currentGraph.forEach(([nodeId, currentOutboundRoutes]) => {\n      var _a, _b;\n\n      const previousRoutes = (_a = previousGCData.gcNodes[nodeId]) !== null && _a !== void 0 ? _a : [];\n      const explicitRoutes = (_b = explicitReferences.get(nodeId)) !== null && _b !== void 0 ? _b : [];\n      const missingExplicitRoutes = [];\n      currentOutboundRoutes.forEach(route => {\n        const isBlobOrDataStoreRoute = this.runtime.getNodeType(route) === GCNodeType.Blob || this.runtime.getNodeType(route) === GCNodeType.DataStore; // Ignore implicitly added DDS routes to their parent datastores\n\n        const notRouteFromDDSToParentDataStore = !nodeId.startsWith(route);\n\n        if (isBlobOrDataStoreRoute && notRouteFromDDSToParentDataStore && !previousRoutes.includes(route) && !explicitRoutes.includes(route)) {\n          missingExplicitRoutes.push(route);\n        }\n      });\n\n      if (missingExplicitRoutes.length > 0) {\n        missingExplicitReferences.push([nodeId, missingExplicitRoutes]);\n      }\n    }); // Ideally missingExplicitReferences should always have a size 0\n\n    return missingExplicitReferences;\n  }\n  /**\n   * Generates the stats of a garbage collection run from the given results of the run.\n   * @param gcResult - The result of a GC run.\n   * @returns the GC stats of the GC run.\n   */\n\n\n  generateStats(gcResult) {\n    const gcStats = {\n      nodeCount: 0,\n      dataStoreCount: 0,\n      attachmentBlobCount: 0,\n      unrefNodeCount: 0,\n      unrefDataStoreCount: 0,\n      unrefAttachmentBlobCount: 0,\n      updatedNodeCount: 0,\n      updatedDataStoreCount: 0,\n      updatedAttachmentBlobCount: 0\n    };\n\n    const updateNodeStats = (nodeId, referenced) => {\n      gcStats.nodeCount++; // If there is no previous GC data, every node's state is generated and is considered as updated.\n      // Otherwise, find out if any node went from referenced to unreferenced or vice-versa.\n\n      const stateUpdated = this.previousGCDataFromLastRun === undefined || this.unreferencedNodesState.has(nodeId) === referenced;\n\n      if (stateUpdated) {\n        gcStats.updatedNodeCount++;\n      }\n\n      if (!referenced) {\n        gcStats.unrefNodeCount++;\n      }\n\n      if (this.runtime.getNodeType(nodeId) === GCNodeType.DataStore) {\n        gcStats.dataStoreCount++;\n\n        if (stateUpdated) {\n          gcStats.updatedDataStoreCount++;\n        }\n\n        if (!referenced) {\n          gcStats.unrefDataStoreCount++;\n        }\n      }\n\n      if (this.runtime.getNodeType(nodeId) === GCNodeType.Blob) {\n        gcStats.attachmentBlobCount++;\n\n        if (stateUpdated) {\n          gcStats.updatedAttachmentBlobCount++;\n        }\n\n        if (!referenced) {\n          gcStats.unrefAttachmentBlobCount++;\n        }\n      }\n    };\n\n    for (const nodeId of gcResult.referencedNodeIds) {\n      updateNodeStats(nodeId, true\n      /* referenced */\n      );\n    }\n\n    for (const nodeId of gcResult.deletedNodeIds) {\n      updateNodeStats(nodeId, false\n      /* referenced */\n      );\n    }\n\n    return gcStats;\n  }\n  /**\n   * For nodes that are ready to sweep, log an event for now. Until we start running sweep which deletes objects,\n   * this will give us a view into how much deleted content a container has.\n   */\n\n\n  logSweepEvents(logger, currentReferenceTimestampMs) {\n    if (this.mc.config.getBoolean(disableSweepLogKey) === true || currentReferenceTimestampMs === undefined || this.sweepTimeoutMs === undefined) {\n      return;\n    }\n\n    this.unreferencedNodesState.forEach((nodeStateTracker, nodeId) => {\n      if (nodeStateTracker.state !== UnreferencedState.SweepReady) {\n        return;\n      }\n\n      const nodeType = this.runtime.getNodeType(nodeId);\n\n      if (nodeType !== GCNodeType.DataStore && nodeType !== GCNodeType.Blob) {\n        return;\n      } // Log deleted event for each node only once to reduce noise in telemetry.\n\n\n      const uniqueEventId = `Deleted-${nodeId}`;\n\n      if (this.loggedUnreferencedEvents.has(uniqueEventId)) {\n        return;\n      }\n\n      this.loggedUnreferencedEvents.add(uniqueEventId);\n      logger.sendTelemetryEvent({\n        eventName: \"GCObjectDeleted\",\n        id: nodeId,\n        type: nodeType,\n        age: currentReferenceTimestampMs - nodeStateTracker.unreferencedTimestampMs,\n        timeout: this.sweepTimeoutMs,\n        completedGCRuns: this.completedRuns,\n        lastSummaryTime: this.getLastSummaryTimestampMs()\n      });\n    });\n  }\n  /**\n   * Called when an inactive node is used after. Queue up an event that will be logged next time GC runs.\n   */\n\n\n  inactiveNodeUsed(usageType, nodeId, nodeStateTracker, fromNodeId, packagePath, currentReferenceTimestampMs = this.runtime.getCurrentReferenceTimestampMs(), requestHeaders) {\n    // If there is no reference timestamp to work with, no ops have been processed after creation. If so, skip\n    // logging as nothing interesting would have happened worth logging.\n    // If the node is active, skip logging.\n    if (currentReferenceTimestampMs === undefined || nodeStateTracker.state === UnreferencedState.Active) {\n      return;\n    } // For non-summarizer clients, only log \"Loaded\" type events since these objects may not be loaded in the\n    // summarizer clients if they are based off of user actions (such as scrolling to content for these objects).\n\n\n    if (!this.isSummarizerClient && usageType !== \"Loaded\") {\n      return;\n    } // We only care about data stores and attachment blobs for this telemetry since GC only marks these objects\n    // as unreferenced. Also, if an inactive DDS is used, the corresponding data store store will also be used.\n\n\n    const nodeType = this.runtime.getNodeType(nodeId);\n\n    if (nodeType !== GCNodeType.DataStore && nodeType !== GCNodeType.Blob) {\n      return;\n    }\n\n    const state = nodeStateTracker.state;\n    const uniqueEventId = `${state}-${nodeId}-${usageType}`;\n\n    if (this.loggedUnreferencedEvents.has(uniqueEventId)) {\n      return;\n    }\n\n    this.loggedUnreferencedEvents.add(uniqueEventId);\n    const propsToLog = {\n      id: nodeId,\n      type: nodeType,\n      unrefTime: nodeStateTracker.unreferencedTimestampMs,\n      age: currentReferenceTimestampMs - nodeStateTracker.unreferencedTimestampMs,\n      timeout: nodeStateTracker.state === UnreferencedState.Inactive ? this.inactiveTimeoutMs : this.sweepTimeoutMs,\n      completedGCRuns: this.completedRuns,\n      lastSummaryTime: this.getLastSummaryTimestampMs(),\n      externalRequest: requestHeaders === null || requestHeaders === void 0 ? void 0 : requestHeaders[RuntimeHeaders.externalRequest],\n      viaHandle: requestHeaders === null || requestHeaders === void 0 ? void 0 : requestHeaders[RuntimeHeaders.viaHandle],\n      fromId: fromNodeId\n    }; // For summarizer client, queue the event so it is logged the next time GC runs if the event is still valid.\n    // For non-summarizer client, log the event now since GC won't run on it. This may result in false positives\n    // but it's a good signal nonetheless and we can consume it with a grain of salt.\n\n    if (this.isSummarizerClient) {\n      this.pendingEventsQueue.push(Object.assign(Object.assign({}, propsToLog), {\n        usageType,\n        state\n      }));\n    } else {\n      this.mc.logger.sendErrorEvent(Object.assign(Object.assign({}, propsToLog), {\n        eventName: `${state}Object_${usageType}`,\n        pkg: packagePath ? {\n          value: packagePath.join(\"/\"),\n          tag: TelemetryDataTag.CodeArtifact\n        } : undefined\n      }));\n    }\n  }\n\n  logUnreferencedEvents(logger) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      for (const eventProps of _this7.pendingEventsQueue) {\n        const {\n          usageType,\n          state\n        } = eventProps,\n              propsToLog = __rest(eventProps, [\"usageType\", \"state\"]);\n        /**\n         * Revived event is logged only if the node is active. If the node is not active, the reference to it was\n         * from another unreferenced node and this scenario is not interesting to log.\n         * Loaded and Changed events are logged only if the node is not active. If the node is active, it was\n         * revived and a Revived event will be logged for it.\n         */\n\n\n        const nodeStateTracker = _this7.unreferencedNodesState.get(eventProps.id);\n\n        const active = nodeStateTracker === undefined || nodeStateTracker.state === UnreferencedState.Active;\n\n        if (usageType === \"Revived\" === active) {\n          const pkg = yield _this7.getNodePackagePath(eventProps.id);\n          const fromPkg = eventProps.fromId ? yield _this7.getNodePackagePath(eventProps.fromId) : undefined;\n          logger.sendErrorEvent(Object.assign(Object.assign({}, propsToLog), {\n            eventName: `${state}Object_${usageType}`,\n            pkg: pkg ? {\n              value: pkg.join(\"/\"),\n              tag: TelemetryDataTag.CodeArtifact\n            } : undefined,\n            fromPkg: fromPkg ? {\n              value: fromPkg.join(\"/\"),\n              tag: TelemetryDataTag.CodeArtifact\n            } : undefined\n          }));\n        }\n      }\n\n      _this7.pendingEventsQueue = [];\n    })();\n  }\n\n}\n/**\n * Gets the garbage collection state from the given snapshot tree. The GC state may be written into multiple blobs.\n * Merge the GC state from all such blobs and return the merged GC state.\n */\n\nfunction getGCStateFromSnapshot(_x2, _x3) {\n  return _getGCStateFromSnapshot.apply(this, arguments);\n}\n\nfunction _getGCStateFromSnapshot() {\n  _getGCStateFromSnapshot = _asyncToGenerator(function* (gcSnapshotTree, readAndParseBlob) {\n    let rootGCState = {\n      gcNodes: {}\n    };\n\n    for (const key of Object.keys(gcSnapshotTree.blobs)) {\n      // Skip blobs that do not start with the GC prefix.\n      if (!key.startsWith(gcBlobPrefix)) {\n        continue;\n      }\n\n      const blobId = gcSnapshotTree.blobs[key];\n\n      if (blobId === undefined) {\n        continue;\n      }\n\n      const gcState = yield readAndParseBlob(blobId);\n      assert(gcState !== undefined, 0x2ad\n      /* \"GC blob missing from snapshot\" */\n      ); // Merge the GC state of this blob into the root GC state.\n\n      rootGCState = concatGarbageCollectionStates(rootGCState, gcState);\n    }\n\n    return rootGCState;\n  });\n  return _getGCStateFromSnapshot.apply(this, arguments);\n}\n\nfunction generateSortedGCState(gcState) {\n  const sortableArray = Object.entries(gcState.gcNodes);\n  sortableArray.sort(([a], [b]) => a.localeCompare(b));\n  const sortedGCState = {\n    gcNodes: {}\n  };\n\n  for (const [nodeId, nodeData] of sortableArray) {\n    nodeData.outboundRoutes.sort();\n    sortedGCState.gcNodes[nodeId] = nodeData;\n  }\n\n  return sortedGCState;\n}\n/**\n * setLongTimeout is used for timeouts longer than setTimeout's ~24.8 day max\n * @param timeoutMs - the total time the timeout needs to last in ms\n * @param timeoutFn - the function to execute when the timer ends\n * @param setTimerFn - the function used to update your timer variable\n */\n\n\nfunction setLongTimeout(timeoutMs, timeoutFn, setTimerFn) {\n  // The setTimeout max is 24.8 days before looping occurs.\n  const maxTimeout = 2147483647;\n  let timer;\n\n  if (timeoutMs > maxTimeout) {\n    const newTimeoutMs = timeoutMs - maxTimeout;\n    timer = setTimeout(() => setLongTimeout(newTimeoutMs, timeoutFn, setTimerFn), maxTimeout);\n  } else {\n    timer = setTimeout(() => timeoutFn(), timeoutMs);\n  }\n\n  setTimerFn(timer);\n} //# sourceMappingURL=garbageCollection.js.map","map":null,"metadata":{},"sourceType":"module"}