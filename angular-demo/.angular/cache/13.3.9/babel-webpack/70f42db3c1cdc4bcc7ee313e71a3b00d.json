{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { parse } from \"url\";\nimport { assert } from \"@fluidframework/common-utils\";\nimport { DriverHeader } from \"@fluidframework/driver-definitions\";\nimport Axios from \"axios\";\n/**\n * As the name implies this is not secure and should not be used in production. It simply makes the example easier\n * to get up and running.\n *\n * In our example we run a simple web server via webpack-dev-server. This defines a URL format of the form\n * http://localhost:8080/<documentId>/<path>.\n *\n * We then need to map that to a Fluid based URL. These are of the form\n * fluid://orderingUrl/<tenantId>/<documentId>/<path>.\n *\n * The tenantId/documentId pair defines the 'full' document ID the service makes use of. The path is then an optional\n * part of the URL that the document interprets and maps to a data store. It's exactly similar to how a web service\n * works or a router inside of a single page app framework.\n */\n\nexport class InsecureUrlResolver {\n  constructor(hostUrl, ordererUrl, storageUrl, tenantId, bearer, isForNodeTest = false) {\n    this.hostUrl = hostUrl;\n    this.ordererUrl = ordererUrl;\n    this.storageUrl = storageUrl;\n    this.tenantId = tenantId;\n    this.bearer = bearer;\n    this.isForNodeTest = isForNodeTest;\n    this.cache = new Map();\n  }\n\n  resolve(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a; // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\n\n      if ((_a = request.headers) === null || _a === void 0 ? void 0 : _a[DriverHeader.createNew]) {\n        const [, queryString] = request.url.split(\"?\");\n        const searchParams = new URLSearchParams(queryString);\n        const fileName = searchParams.get(\"fileName\");\n        return _this.resolveHelper(fileName);\n      }\n\n      const parsedUrl = new URL(request.url); // If hosts match then we use the local tenant information. Otherwise we make a REST call out to the hosting\n      // service using our bearer token.\n\n      if (_this.isForNodeTest) {\n        const [, documentId, tmpRelativePath] = parsedUrl.pathname.substr(1).split(\"/\");\n        const relativePath = tmpRelativePath === undefined ? \"\" : tmpRelativePath;\n        return _this.resolveHelper(documentId, relativePath, parsedUrl.search);\n      } else if (parsedUrl.host === window.location.host) {\n        const fullPath = parsedUrl.pathname.substr(1);\n        const documentId = fullPath.split(\"/\")[0];\n        const documentRelativePath = fullPath.slice(documentId.length);\n        return _this.resolveHelper(documentId, documentRelativePath);\n      } else {\n        const maybeResolvedUrl = _this.cache.get(request.url);\n\n        if (maybeResolvedUrl) {\n          return maybeResolvedUrl;\n        }\n\n        const headers = {\n          Authorization: `Bearer ${_this.bearer}`\n        };\n        const resolvedP = Axios.post(`${_this.hostUrl}/api/v1/load`, {\n          url: request.url\n        }, {\n          headers\n        });\n\n        _this.cache.set(request.url, resolvedP.then(resolved => resolved.data));\n\n        return _this.cache.get(request.url);\n      }\n    })();\n  }\n\n  resolveHelper(documentId, documentRelativePath = \"\", queryParams = \"\") {\n    const encodedTenantId = encodeURIComponent(this.tenantId);\n    const host = new URL(this.ordererUrl).host; // when the document ID is not provided we need to resolve a special create new document URL.\n    // the actual container ID will be generated by the driver.\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\n    if (!documentId) {\n      const createNewResponse = {\n        endpoints: {\n          deltaStorageUrl: `${this.ordererUrl}/deltas/${encodedTenantId}/new`,\n          ordererUrl: this.ordererUrl,\n          storageUrl: `${this.storageUrl}/repos/${encodedTenantId}`\n        },\n        // document ID is ignored by the driver for new container requests\n        id: \"\",\n        tokens: {},\n        type: \"fluid\",\n        url: `fluid://${host}/${encodedTenantId}/new`\n      };\n      return createNewResponse;\n    }\n\n    const encodedDocId = encodeURIComponent(documentId);\n    const relativePath = !documentRelativePath || documentRelativePath.startsWith(\"/\") ? documentRelativePath : `/${documentRelativePath}`;\n    const documentUrl = `fluid://${host}/${encodedTenantId}/${encodedDocId}${relativePath}${queryParams}`;\n    const deltaStorageUrl = `${this.ordererUrl}/deltas/${encodedTenantId}/${encodedDocId}`;\n    const storageUrl = `${this.storageUrl}/repos/${encodedTenantId}`;\n    const response = {\n      endpoints: {\n        deltaStorageUrl,\n        ordererUrl: this.ordererUrl,\n        storageUrl\n      },\n      id: documentId,\n      tokens: {},\n      type: \"fluid\",\n      url: documentUrl\n    };\n    return response;\n  }\n\n  getAbsoluteUrl(resolvedUrl, relativeUrl) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      const fluidResolvedUrl = resolvedUrl;\n      const parsedUrl = parse(fluidResolvedUrl.url);\n      const [,, documentId] = (_b = (_a = parsedUrl.pathname) === null || _a === void 0 ? void 0 : _a.split(\"/\")) !== null && _b !== void 0 ? _b : []; // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\n      assert(!!documentId, 0x273\n      /* \"Invalid document id from parsed URL\" */\n      );\n      let url = relativeUrl;\n\n      if (url.startsWith(\"/\")) {\n        url = url.substr(1);\n      }\n\n      return `${_this2.hostUrl}/${encodeURIComponent(_this2.tenantId)}/${encodeURIComponent(documentId)}/${url}`;\n    })();\n  }\n\n  createCreateNewRequest(fileName) {\n    const createNewRequest = {\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      url: fileName ? `${this.hostUrl}?fileName=${fileName}` : this.hostUrl,\n      headers: {\n        [DriverHeader.createNew]: true\n      }\n    };\n    return createNewRequest;\n  }\n\n} //# sourceMappingURL=insecureUrlResolver.js.map","map":null,"metadata":{},"sourceType":"module"}