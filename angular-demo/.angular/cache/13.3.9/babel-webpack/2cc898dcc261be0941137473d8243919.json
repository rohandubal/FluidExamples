{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport { fromUtf8ToBase64 } from \"@fluidframework/common-utils\";\nimport { getAuthorizationTokenFromCredentials, RestLessClient, RestWrapper } from \"@fluidframework/server-services-client\";\nimport fetch from \"cross-fetch\";\nimport safeStringify from \"json-stringify-safe\";\nimport { v4 as uuid } from \"uuid\";\nimport { throwR11sNetworkError } from \"./errorUtils\";\nimport { pkgVersion as driverVersion } from \"./packageVersion\";\n\nconst axiosRequestConfigToFetchRequestConfig = requestConfig => {\n  var _a, _b;\n\n  const requestInfo = requestConfig.baseURL !== undefined ? `${requestConfig.baseURL}${(_a = requestConfig.url) !== null && _a !== void 0 ? _a : \"\"}` : (_b = requestConfig.url) !== null && _b !== void 0 ? _b : \"\";\n  const requestInit = {\n    method: requestConfig.method,\n    // NOTE: I believe that although the Axios type permits non-string values in the header, here we are\n    // guaranteed the requestConfig only has string values in its header.\n    headers: requestConfig.headers,\n    body: requestConfig.data\n  };\n  return [requestInfo, requestInit];\n};\n\nexport class RouterliciousRestWrapper extends RestWrapper {\n  constructor(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString = {}) {\n    super(baseurl, defaultQueryString);\n    this.rateLimiter = rateLimiter;\n    this.getAuthorizationHeader = getAuthorizationHeader;\n    this.useRestLess = useRestLess;\n    this.restLess = new RestLessClient();\n  }\n\n  load() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this.authorizationHeader = yield _this.getAuthorizationHeader();\n    })();\n  }\n\n  request(requestConfig, statusCode, canRetry = true) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const config = Object.assign(Object.assign({}, requestConfig), {\n        headers: _this2.generateHeaders(requestConfig.headers)\n      });\n      const translatedConfig = _this2.useRestLess ? _this2.restLess.translate(config) : config;\n      const fetchRequestConfig = axiosRequestConfigToFetchRequestConfig(translatedConfig);\n      const response = yield _this2.rateLimiter.schedule( /*#__PURE__*/_asyncToGenerator(function* () {\n        return fetch(...fetchRequestConfig).catch( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (error) {\n            // Browser Fetch throws a TypeError on network error, `node-fetch` throws a FetchError\n            const isNetworkError = [\"TypeError\", \"FetchError\"].includes(error === null || error === void 0 ? void 0 : error.name);\n            throwR11sNetworkError(isNetworkError ? `NetworkError: ${error.message}` : safeStringify(error));\n          });\n\n          return function (_x) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n      }));\n      const responseBody = ((_a = response.headers.get(\"content-type\")) === null || _a === void 0 ? void 0 : _a.includes(\"application/json\")) ? yield response.json() : yield response.text(); // Success\n\n      if (response.ok || response.status === statusCode) {\n        const result = responseBody;\n        return result;\n      } // Failure\n\n\n      if (response.status === 401 && canRetry) {\n        // Refresh Authorization header and retry once\n        _this2.authorizationHeader = yield _this2.getAuthorizationHeader(true\n        /* refreshToken */\n        );\n        return _this2.request(config, statusCode, false);\n      }\n\n      if (response.status === 429 && (responseBody === null || responseBody === void 0 ? void 0 : responseBody.retryAfter) > 0) {\n        // Retry based on retryAfter[Seconds]\n        return new Promise((resolve, reject) => setTimeout(() => {\n          _this2.request(config, statusCode).then(resolve).catch(reject);\n        }, responseBody.retryAfter * 1000));\n      }\n\n      const responseSummary = responseBody !== undefined ? typeof responseBody === \"string\" ? responseBody : safeStringify(responseBody) : response.statusText;\n      throwR11sNetworkError(`R11s fetch error: ${responseSummary}`, response.status, responseBody === null || responseBody === void 0 ? void 0 : responseBody.retryAfter);\n    })();\n  }\n\n  generateHeaders(requestHeaders) {\n    const correlationId = (requestHeaders === null || requestHeaders === void 0 ? void 0 : requestHeaders[\"x-correlation-id\"]) || uuid();\n    return Object.assign(Object.assign({}, requestHeaders), {\n      // TODO: replace header names with CorrelationIdHeaderName and DriverVersionHeaderName from services-client\n      // NOTE: Can correlationId actually be number | true?\n      \"x-correlation-id\": correlationId,\n      \"x-driver-version\": driverVersion,\n      // NOTE: If this.authorizationHeader is undefined, should \"Authorization\" be removed entirely?\n      \"Authorization\": this.authorizationHeader\n    });\n  }\n\n}\nexport class RouterliciousStorageRestWrapper extends RouterliciousRestWrapper {\n  constructor(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString = {}) {\n    super(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString);\n  }\n\n  static load(tenantId, documentId, tokenProvider, logger, rateLimiter, useRestLess, baseurl) {\n    return _asyncToGenerator(function* () {\n      const defaultQueryString = {\n        token: `${fromUtf8ToBase64(tenantId)}`\n      };\n\n      const getAuthorizationHeader = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (refreshToken) {\n          // Craft credentials using tenant id and token\n          const storageToken = yield tokenProvider.fetchStorageToken(tenantId, documentId, refreshToken);\n          const credentials = {\n            password: storageToken.jwt,\n            user: tenantId\n          };\n          return getAuthorizationTokenFromCredentials(credentials);\n        });\n\n        return function getAuthorizationHeader(_x2) {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n\n      const restWrapper = new RouterliciousStorageRestWrapper(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString);\n\n      try {\n        yield restWrapper.load();\n      } catch (e) {\n        logger.sendErrorEvent({\n          eventName: \"R11sRestWrapperLoadFailure\"\n        }, e);\n        yield restWrapper.load();\n      }\n\n      return restWrapper;\n    })();\n  }\n\n}\nexport class RouterliciousOrdererRestWrapper extends RouterliciousRestWrapper {\n  constructor(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString = {}) {\n    super(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString);\n  }\n\n  static load(tenantId, documentId, tokenProvider, logger, rateLimiter, useRestLess, baseurl) {\n    return _asyncToGenerator(function* () {\n      const getAuthorizationHeader = /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (refreshToken) {\n          const ordererToken = yield tokenProvider.fetchOrdererToken(tenantId, documentId, refreshToken);\n          return `Basic ${ordererToken.jwt}`;\n        });\n\n        return function getAuthorizationHeader(_x3) {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n\n      const restWrapper = new RouterliciousOrdererRestWrapper(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl);\n\n      try {\n        yield restWrapper.load();\n      } catch (e) {\n        logger.sendErrorEvent({\n          eventName: \"R11sRestWrapperLoadFailure\"\n        }, e);\n        yield restWrapper.load();\n      }\n\n      return restWrapper;\n    })();\n  }\n\n} //# sourceMappingURL=restWrapper.js.map","map":null,"metadata":{},"sourceType":"module"}