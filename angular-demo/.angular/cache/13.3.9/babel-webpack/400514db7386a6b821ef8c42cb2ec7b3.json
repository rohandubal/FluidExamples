{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, Lazy } from \"@fluidframework/common-utils\";\nimport { DataProcessingError } from \"@fluidframework/container-utils\";\nimport { FlushMode } from \"@fluidframework/runtime-definitions\";\nimport { wrapError } from \"@fluidframework/telemetry-utils\";\nimport Deque from \"double-ended-queue\";\n/**\n * PendingStateManager is responsible for maintaining the messages that have not been sent or have not yet been\n * acknowledged by the server. It also maintains the batch information for both automatically and manually flushed\n * batches along with the messages.\n * When the Container reconnects, it replays the pending states, which includes setting the FlushMode, manual flushing\n * of messages and triggering resubmission of unacked ops.\n *\n * It verifies that all the ops are acked, are received in the right order and batch information is correct.\n */\n\nexport class PendingStateManager {\n  constructor(stateHandler, initialFlushMode, initialLocalState) {\n    var _a;\n\n    this.stateHandler = stateHandler;\n    this.pendingStates = new Deque();\n    this.disposeOnce = new Lazy(() => {\n      this.initialStates.clear();\n      this.pendingStates.clear();\n    }); // Maintains the count of messages that are currently unacked.\n\n    this._pendingMessagesCount = 0; // Indicates whether we are processing a batch.\n\n    this.isProcessingBatch = false;\n\n    this.dispose = () => this.disposeOnce.value;\n\n    this.initialStates = new Deque((_a = initialLocalState === null || initialLocalState === void 0 ? void 0 : initialLocalState.pendingStates) !== null && _a !== void 0 ? _a : []);\n    this.flushModeForNextMessage = initialFlushMode;\n    this.onFlushModeUpdated(initialFlushMode);\n  }\n\n  get pendingMessagesCount() {\n    return this._pendingMessagesCount;\n  }\n  /**\n   * Called to check if there are any pending messages in the pending state queue.\n   * @returns A boolean indicating whether there are messages or not.\n   */\n\n\n  hasPendingMessages() {\n    return this._pendingMessagesCount !== 0 || !this.initialStates.isEmpty();\n  }\n\n  getLocalState() {\n    assert(this.initialStates.isEmpty(), 0x2e9\n    /* \"Must call getLocalState() after applying initial states\" */\n    );\n\n    if (this.hasPendingMessages()) {\n      return {\n        pendingStates: this.pendingStates.toArray().map( // delete localOpMetadata since it may not be serializable\n        // and will be regenerated by applyStashedOp()\n        state => state.type === \"message\" ? Object.assign(Object.assign({}, state), {\n          localOpMetadata: undefined\n        }) : state)\n      };\n    }\n  }\n\n  get disposed() {\n    return this.disposeOnce.evaluated;\n  }\n  /**\n   * Called when a message is submitted locally. Adds the message and the associated details to the pending state\n   * queue.\n   * @param type - The container message type.\n   * @param clientSequenceNumber - The clientSequenceNumber associated with the message.\n   * @param content - The message content.\n   * @param localOpMetadata - The local metadata associated with the message.\n   */\n\n\n  onSubmitMessage(type, clientSequenceNumber, referenceSequenceNumber, content, localOpMetadata, opMetadata) {\n    const pendingMessage = {\n      type: \"message\",\n      messageType: type,\n      clientSequenceNumber,\n      referenceSequenceNumber,\n      content,\n      localOpMetadata,\n      opMetadata\n    };\n    this.pendingStates.push(pendingMessage);\n    this._pendingMessagesCount++;\n  }\n  /**\n   * Called when the FlushMode is updated. Adds the FlushMode to the pending state queue.\n   * @param flushMode - The flushMode that was updated.\n   */\n\n\n  onFlushModeUpdated(flushMode) {\n    this.pendingStates.push({\n      type: \"flushMode\",\n      flushMode\n    });\n  }\n  /**\n   * Called when flush() is called on the ContainerRuntime to manually flush messages.\n   */\n\n\n  onFlush() {\n    // If the FlushMode is Immediate, we don't need to track an explicit flush call because every message is\n    // automatically flushed. So, flush is a no-op.\n    if (this.stateHandler.flushMode() === FlushMode.Immediate) {\n      return;\n    } // If the previous state is not a message, flush is a no-op.\n\n\n    const previousState = this.pendingStates.peekBack();\n\n    if ((previousState === null || previousState === void 0 ? void 0 : previousState.type) !== \"message\") {\n      return;\n    } // An explicit flush is interesting and is tracked only if there are messages sent in TurnBased mode.\n\n\n    this.pendingStates.push({\n      type: \"flush\"\n    });\n  }\n  /**\n   * Applies stashed ops at their reference sequence number so they are ready to be ACKed or resubmitted\n   * @param seqNum - Sequence number at which to apply ops. Will apply all ops if seqNum is undefined.\n   */\n\n\n  applyStashedOpsAt(seqNum) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // apply stashed ops at sequence number\n      while (!_this.initialStates.isEmpty()) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const nextState = _this.initialStates.peekFront();\n\n        if (nextState.type === \"message\") {\n          if (seqNum !== undefined) {\n            if (nextState.referenceSequenceNumber > seqNum) {\n              break; // nothing left to do at this sequence number\n            } else if (nextState.referenceSequenceNumber < seqNum) {\n              throw new Error(\"loaded from snapshot too recent to apply stashed ops\");\n            }\n          } // applyStashedOp will cause the DDS to behave as if it has sent the op but not actually send it\n\n\n          const localOpMetadata = yield _this.stateHandler.applyStashedOp(nextState.messageType, nextState.content);\n          nextState.localOpMetadata = localOpMetadata;\n        } // then we push onto pendingStates which will cause PendingStateManager to resubmit when we connect\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n        _this.pendingStates.push(_this.initialStates.shift());\n      }\n    })();\n  }\n  /**\n   * Processes a local message once its ack'd by the server. It verifies that there was no data corruption and that\n   * the batch information was preserved for batch messages.\n   * @param message - The message that got ack'd and needs to be processed.\n   */\n\n\n  processPendingLocalMessage(message) {\n    // Pre-processing part - This may be the start of a batch.\n    this.maybeProcessBatchBegin(message); // Get the next state from the pending queue and verify that it is of type \"message\".\n\n    const pendingState = this.peekNextPendingState();\n    assert(pendingState.type === \"message\", 0x169\n    /* \"No pending message found for this remote message\" */\n    );\n    this.pendingStates.shift(); // Processing part - Verify that there has been no data corruption.\n    // The clientSequenceNumber of the incoming message must match that of the pending message.\n\n    if (pendingState.clientSequenceNumber !== message.clientSequenceNumber) {\n      // Close the container because this could indicate data corruption.\n      const error = DataProcessingError.create(\"pending local message clientSequenceNumber mismatch\", \"unexpectedAckReceived\", message, {\n        expectedClientSequenceNumber: pendingState.clientSequenceNumber\n      });\n      this.stateHandler.close(error);\n      return;\n    }\n\n    this._pendingMessagesCount--; // Post-processing part - If we are processing a batch then this could be the last message in the batch.\n\n    this.maybeProcessBatchEnd(message);\n    return pendingState.localOpMetadata;\n  }\n  /**\n   * This message could be the first message in batch. If so, set batch state marking the beginning of a batch.\n   * @param message - The message that is being processed.\n   */\n\n\n  maybeProcessBatchBegin(message) {\n    // Tracks the last FlushMode that was set before this message was sent.\n    let pendingFlushMode; // Tracks whether a flush was called before this message was sent.\n\n    let pendingFlush = false;\n    /**\n     * We are checking if the next message is the start of a batch. It can happen in the following scenarios:\n     * 1. The FlushMode was set to TurnBased before this message was sent.\n     * 2. The FlushMode was already TurnBased and a flush was called before this message was sent. This essentially\n     *    means that the flush marked the end of a previous batch and beginning of a new batch.\n     *\n     * Keep reading pending states from the queue until we encounter a message. It's possible that the FlushMode was\n     * updated a bunch of times without sending any messages.\n     */\n\n    let nextPendingState = this.peekNextPendingState();\n\n    while (nextPendingState.type !== \"message\") {\n      if (nextPendingState.type === \"flushMode\") {\n        pendingFlushMode = nextPendingState.flushMode;\n      }\n\n      if (nextPendingState.type === \"flush\") {\n        pendingFlush = true;\n      }\n\n      this.pendingStates.shift();\n      nextPendingState = this.peekNextPendingState();\n    }\n\n    if (pendingFlushMode !== undefined) {\n      this.flushModeForNextMessage = pendingFlushMode;\n    } // If the FlushMode was set to Immediate before this message was sent, this message won't be a batch message\n    // because in Immediate mode, every message is flushed individually.\n\n\n    if (pendingFlushMode === FlushMode.Immediate) {\n      return;\n    }\n    /**\n     * This message is the first in a batch if before it was sent either the FlushMode was set to TurnBased or there\n     * was an explicit flush call. Note that a flush call is tracked only in TurnBased mode and it indicates the end\n     * of one batch and beginning of another.\n     */\n\n\n    if (pendingFlushMode === FlushMode.TurnBased || pendingFlush) {\n      // We should not already be processing a batch and there should be no pending batch begin message.\n      assert(!this.isProcessingBatch && this.pendingBatchBeginMessage === undefined, 0x16b\n      /* \"The pending batch state indicates we are already processing a batch\" */\n      ); // Set the pending batch state indicating we have started processing a batch.\n\n      this.pendingBatchBeginMessage = message;\n      this.isProcessingBatch = true;\n    }\n  }\n  /**\n   * This message could be the last message in batch. If so, clear batch state since the batch is complete.\n   * @param message - The message that is being processed.\n   */\n\n\n  maybeProcessBatchEnd(message) {\n    var _a, _b;\n\n    if (!this.isProcessingBatch) {\n      return;\n    }\n\n    const nextPendingState = this.peekNextPendingState();\n\n    if (nextPendingState.type === \"message\") {\n      return;\n    }\n    /**\n     * We are in the middle of processing a batch. The batch ends when we see an explicit flush. We should never see\n     * a FlushMode before flush. This is true because we track batches only when FlushMode is TurnBased and in this\n     * mode, a batch ends either by calling flush or by changing the mode to Immediate which also triggers a flush.\n     */\n\n\n    assert(nextPendingState.type !== \"flushMode\", 0x2bd\n    /* \"We should not see a pending FlushMode until we see a flush when processing a batch\" */\n    ); // There should be a pending batch begin message.\n\n    assert(this.pendingBatchBeginMessage !== undefined, 0x16d\n    /* \"There is no pending batch begin message\" */\n    ); // Get the batch begin metadata from the first message in the batch.\n\n    const batchBeginMetadata = (_a = this.pendingBatchBeginMessage.metadata) === null || _a === void 0 ? void 0 : _a.batch; // There could be just a single message in the batch. If so, it should not have any batch metadata. If there\n    // are multiple messages in the batch, verify that we got the correct batch begin and end metadata.\n\n    if (this.pendingBatchBeginMessage === message) {\n      assert(batchBeginMetadata === undefined, 0x16e\n      /* \"Batch with single message should not have batch metadata\" */\n      );\n    } else {\n      // Get the batch metadata from the last message in the batch.\n      const batchEndMetadata = (_b = message.metadata) === null || _b === void 0 ? void 0 : _b.batch;\n      assert(batchBeginMetadata === true, 0x16f\n      /* \"Did not receive batch begin metadata\" */\n      );\n      assert(batchEndMetadata === false, 0x170\n      /* \"Did not receive batch end metadata\" */\n      );\n    } // Clear the pending batch state now that we have processed the entire batch.\n\n\n    this.pendingBatchBeginMessage = undefined;\n    this.isProcessingBatch = false;\n  }\n  /**\n   * Capture the pending state at this point\n   */\n\n\n  checkpoint() {\n    const checkpointHead = this.pendingStates.peekBack();\n    return {\n      rollback: () => {\n        try {\n          while (this.pendingStates.peekBack() !== checkpointHead) {\n            this.rollbackNextPendingState();\n          }\n        } catch (err) {\n          const error = wrapError(err, message => {\n            return DataProcessingError.create(`RollbackError: ${message}`, \"checkpointRollback\", undefined);\n          });\n          this.stateHandler.close(error);\n          throw error;\n        }\n      }\n    };\n  }\n  /**\n   * Returns the next pending state from the pending state queue.\n   */\n\n\n  peekNextPendingState() {\n    const nextPendingState = this.pendingStates.peekFront();\n    assert(!!nextPendingState, 0x171\n    /* \"No pending state found for the remote message\" */\n    );\n    return nextPendingState;\n  }\n  /**\n   * Undo the last pending state\n   */\n\n\n  rollbackNextPendingState() {\n    const pendingStatesCount = this.pendingStates.length;\n\n    if (pendingStatesCount === 0) {\n      return;\n    }\n\n    this._pendingMessagesCount--; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n    const pendingState = this.pendingStates.pop();\n\n    switch (pendingState.type) {\n      case \"message\":\n        this.stateHandler.rollback(pendingState.messageType, pendingState.content, pendingState.localOpMetadata);\n        break;\n\n      default:\n        throw new Error(`Can't rollback state ${pendingState.type}`);\n    }\n  }\n  /**\n   * Called when the Container's connection state changes. If the Container gets connected, it replays all the pending\n   * states in its queue. This includes setting the FlushMode and triggering resubmission of unacked ops.\n   */\n\n\n  replayPendingStates() {\n    assert(this.stateHandler.connected(), 0x172\n    /* \"The connection state is not consistent with the runtime\" */\n    ); // This assert suggests we are about to send same ops twice, which will result in data loss.\n\n    assert(this.clientId !== this.stateHandler.clientId(), 0x173\n    /* \"replayPendingStates called twice for same clientId!\" */\n    );\n    this.clientId = this.stateHandler.clientId();\n    assert(this.initialStates.isEmpty(), 0x174\n    /* \"initial states should be empty before replaying pending\" */\n    );\n    let pendingStatesCount = this.pendingStates.length;\n\n    if (pendingStatesCount === 0) {\n      return;\n    } // Reset the pending message count because all these messages will be removed from the queue.\n\n\n    this._pendingMessagesCount = 0; // Save the current FlushMode so that we can revert it back after replaying the states.\n\n    const savedFlushMode = this.stateHandler.flushMode(); // Set the flush mode for the next message. This step is important because the flush mode may have been changed\n    // after the next pending message was sent.\n\n    this.stateHandler.setFlushMode(this.flushModeForNextMessage); // Process exactly `pendingStatesCount` items in the queue as it represents the number of states that were\n    // pending when we connected. This is important because the `reSubmitFn` might add more items in the queue\n    // which must not be replayed.\n\n    while (pendingStatesCount > 0) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const pendingState = this.pendingStates.shift();\n\n      switch (pendingState.type) {\n        case \"message\":\n          this.stateHandler.reSubmit(pendingState.messageType, pendingState.content, pendingState.localOpMetadata, pendingState.opMetadata);\n          break;\n\n        case \"flushMode\":\n          this.stateHandler.setFlushMode(pendingState.flushMode);\n          break;\n\n        case \"flush\":\n          this.stateHandler.flush();\n          break;\n\n        default:\n          break;\n      }\n\n      pendingStatesCount--;\n    } // Revert the FlushMode.\n\n\n    this.stateHandler.setFlushMode(savedFlushMode);\n  }\n\n} //# sourceMappingURL=pendingStateManager.js.map","map":null,"metadata":{},"sourceType":"module"}