{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { DataCorruptionError, extractSafePropertiesFromMessage } from \"@fluidframework/container-utils\";\nimport { FluidObjectHandle } from \"@fluidframework/datastore\";\nimport { channelsTreeName, CreateSummarizerNodeSource } from \"@fluidframework/runtime-definitions\";\nimport { convertSnapshotTreeToSummaryTree, convertToSummaryTree, create404Response, responseToException, SummaryTreeBuilder } from \"@fluidframework/runtime-utils\";\nimport { ChildLogger, LoggingError, TelemetryDataTag } from \"@fluidframework/telemetry-utils\";\nimport { AttachState } from \"@fluidframework/container-definitions\";\nimport { BlobCacheStorageService, buildSnapshotTree } from \"@fluidframework/driver-utils\";\nimport { assert, Lazy, LazyPromise } from \"@fluidframework/common-utils\";\nimport { v4 as uuid } from \"uuid\";\nimport { GCDataBuilder, unpackChildNodesUsedRoutes } from \"@fluidframework/garbage-collector\";\nimport { DataStoreContexts } from \"./dataStoreContexts\";\nimport { RemoteFluidDataStoreContext, LocalFluidDataStoreContext, createAttributesBlob, LocalDetachedFluidDataStoreContext } from \"./dataStoreContext\";\nimport { nonDataStorePaths, rootHasIsolatedChannels } from \"./summaryFormat\";\nimport { isDataStoreAliasMessage } from \"./dataStore\";\nimport { GCNodeType } from \"./garbageCollection\";\n/**\n * This class encapsulates data store handling. Currently it is only used by the container runtime,\n * but eventually could be hosted on any channel once we formalize the channel api boundary.\n */\n\nexport class DataStores {\n  constructor(baseSnapshot, runtime, submitAttachFn, getCreateChildSummarizerNodeFn, deleteChildSummarizerNodeFn, baseLogger, getBaseGCDetails, gcNodeUpdated, aliasMap, writeGCDataAtRoot, contexts = new DataStoreContexts(baseLogger)) {\n    this.baseSnapshot = baseSnapshot;\n    this.runtime = runtime;\n    this.submitAttachFn = submitAttachFn;\n    this.getCreateChildSummarizerNodeFn = getCreateChildSummarizerNodeFn;\n    this.deleteChildSummarizerNodeFn = deleteChildSummarizerNodeFn;\n    this.gcNodeUpdated = gcNodeUpdated;\n    this.aliasMap = aliasMap;\n    this.writeGCDataAtRoot = writeGCDataAtRoot;\n    this.contexts = contexts; // Stores tracked by the Domain\n\n    this.pendingAttach = new Map(); // 0.24 back-compat attachingBeforeSummary\n\n    this.attachOpFiredForDataStore = new Set();\n    this.disposeOnce = new Lazy(() => this.contexts.dispose()); // Stores the ids of new data stores between two GC runs. This is used to notify the garbage collector of new\n    // root data stores that are added.\n\n    this.dataStoresSinceLastGC = [];\n\n    this.dispose = () => this.disposeOnce.value;\n\n    this.logger = ChildLogger.create(baseLogger);\n    this.containerRuntimeHandle = new FluidObjectHandle(this.runtime, \"/\", this.runtime.IFluidHandleContext);\n    const baseGCDetailsP = new LazyPromise( /*#__PURE__*/_asyncToGenerator(function* () {\n      return getBaseGCDetails();\n    })); // Returns the base GC details for the data store with the given id.\n\n    const dataStoreBaseGCDetails = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (dataStoreId) {\n        const baseGCDetails = yield baseGCDetailsP;\n        return baseGCDetails.get(dataStoreId);\n      });\n\n      return function dataStoreBaseGCDetails(_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }(); // Extract stores stored inside the snapshot\n\n\n    const fluidDataStores = new Map();\n\n    if (baseSnapshot) {\n      for (const [key, value] of Object.entries(baseSnapshot.trees)) {\n        fluidDataStores.set(key, value);\n      }\n    }\n\n    let unreferencedDataStoreCount = 0; // Create a context for each of them\n\n    for (const [key, value] of fluidDataStores) {\n      let dataStoreContext; // counting number of unreferenced data stores\n\n      if (value.unreferenced) {\n        unreferencedDataStoreCount++;\n      } // If we have a detached container, then create local data store contexts.\n\n\n      if (this.runtime.attachState !== AttachState.Detached) {\n        dataStoreContext = new RemoteFluidDataStoreContext({\n          id: key,\n          snapshotTree: value,\n          getBaseGCDetails: function () {\n            var _ref3 = _asyncToGenerator(function* () {\n              return dataStoreBaseGCDetails(key);\n            });\n\n            return function getBaseGCDetails() {\n              return _ref3.apply(this, arguments);\n            };\n          }(),\n          runtime: this.runtime,\n          storage: this.runtime.storage,\n          scope: this.runtime.scope,\n          createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(key, {\n            type: CreateSummarizerNodeSource.FromSummary\n          }),\n          writeGCDataAtRoot: this.writeGCDataAtRoot,\n          disableIsolatedChannels: this.runtime.disableIsolatedChannels\n        });\n      } else {\n        if (typeof value !== \"object\") {\n          throw new LoggingError(\"Snapshot should be there to load from!!\");\n        }\n\n        const snapshotTree = value;\n        dataStoreContext = new LocalFluidDataStoreContext({\n          id: key,\n          pkg: undefined,\n          runtime: this.runtime,\n          storage: this.runtime.storage,\n          scope: this.runtime.scope,\n          createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(key, {\n            type: CreateSummarizerNodeSource.FromSummary\n          }),\n          makeLocallyVisibleFn: () => this.makeDataStoreLocallyVisible(key),\n          snapshotTree,\n          isRootDataStore: undefined,\n          writeGCDataAtRoot: this.writeGCDataAtRoot,\n          disableIsolatedChannels: this.runtime.disableIsolatedChannels\n        });\n      }\n\n      this.contexts.addBoundOrRemoted(dataStoreContext);\n    }\n\n    this.containerLoadStats = {\n      containerLoadDataStoreCount: fluidDataStores.size,\n      referencedDataStoreCount: fluidDataStores.size - unreferencedDataStoreCount\n    };\n  }\n\n  aliases() {\n    return this.aliasMap;\n  }\n\n  processAttachMessage(message, local) {\n    var _a, _b;\n\n    const attachMessage = message.contents;\n    this.dataStoresSinceLastGC.push(attachMessage.id); // The local object has already been attached\n\n    if (local) {\n      assert(this.pendingAttach.has(attachMessage.id), 0x15e\n      /* \"Local object does not have matching attach message id\" */\n      );\n      (_a = this.contexts.get(attachMessage.id)) === null || _a === void 0 ? void 0 : _a.emit(\"attached\");\n      this.pendingAttach.delete(attachMessage.id);\n      return;\n    } // If a non-local operation then go and create the object, otherwise mark it as officially attached.\n\n\n    if (this.alreadyProcessed(attachMessage.id)) {\n      // TODO: dataStoreId may require a different tag from PackageData #7488\n      const error = new DataCorruptionError( // pre-0.58 error message: duplicateDataStoreCreatedWithExistingId\n      \"Duplicate DataStore created with existing id\", Object.assign(Object.assign({}, extractSafePropertiesFromMessage(message)), {\n        dataStoreId: {\n          value: attachMessage.id,\n          tag: TelemetryDataTag.PackageData\n        }\n      }));\n      throw error;\n    }\n\n    const flatBlobs = new Map();\n    let snapshotTree;\n\n    if (attachMessage.snapshot) {\n      snapshotTree = buildSnapshotTree(attachMessage.snapshot.entries, flatBlobs);\n    } // Include the type of attach message which is the pkg of the store to be\n    // used by RemoteFluidDataStoreContext in case it is not in the snapshot.\n\n\n    const pkg = [attachMessage.type];\n    const remoteFluidDataStoreContext = new RemoteFluidDataStoreContext({\n      id: attachMessage.id,\n      snapshotTree,\n      // New data stores begin with empty GC details since GC hasn't run on them yet.\n      getBaseGCDetails: function () {\n        var _ref4 = _asyncToGenerator(function* () {\n          return {};\n        });\n\n        return function getBaseGCDetails() {\n          return _ref4.apply(this, arguments);\n        };\n      }(),\n      runtime: this.runtime,\n      storage: new BlobCacheStorageService(this.runtime.storage, flatBlobs),\n      scope: this.runtime.scope,\n      createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(attachMessage.id, {\n        type: CreateSummarizerNodeSource.FromAttach,\n        sequenceNumber: message.sequenceNumber,\n        snapshot: (_b = attachMessage.snapshot) !== null && _b !== void 0 ? _b : {\n          entries: [createAttributesBlob(pkg, true\n          /* isRootDataStore */\n          , this.runtime.disableIsolatedChannels)]\n        }\n      }),\n      writeGCDataAtRoot: this.writeGCDataAtRoot,\n      disableIsolatedChannels: this.runtime.disableIsolatedChannels,\n      pkg\n    });\n    this.contexts.addBoundOrRemoted(remoteFluidDataStoreContext);\n  }\n\n  processAliasMessage(message, localOpMetadata, local) {\n    const aliasMessage = message.contents;\n\n    if (!isDataStoreAliasMessage(aliasMessage)) {\n      throw new DataCorruptionError(\"malformedDataStoreAliasMessage\", Object.assign({}, extractSafePropertiesFromMessage(message)));\n    }\n\n    const resolve = localOpMetadata;\n    const aliasResult = this.processAliasMessageCore(aliasMessage);\n\n    if (local) {\n      resolve(aliasResult);\n    }\n  }\n\n  processAliasMessageCore(aliasMessage) {\n    if (this.alreadyProcessed(aliasMessage.alias)) {\n      return false;\n    }\n\n    const context = this.contexts.get(aliasMessage.internalId);\n\n    if (context === undefined) {\n      this.logger.sendErrorEvent({\n        eventName: \"AliasFluidDataStoreNotFound\",\n        fluidDataStoreId: aliasMessage.internalId\n      });\n      return false;\n    }\n\n    const handle = new FluidObjectHandle(context, aliasMessage.internalId, this.runtime.IFluidHandleContext);\n    this.runtime.addedGCOutboundReference(this.containerRuntimeHandle, handle);\n    this.aliasMap.set(aliasMessage.alias, context.id);\n    context.setInMemoryRoot();\n    return true;\n  }\n\n  alreadyProcessed(id) {\n    return this.aliasMap.get(id) !== undefined || this.contexts.get(id) !== undefined;\n  }\n  /**\n   * Make the data stores locally visible in the container graph by moving the data store context from unbound to\n   * bound list. This data store can now be reached from the root.\n   * @param id - The id of the data store context to make visible.\n   */\n\n\n  makeDataStoreLocallyVisible(id) {\n    const localContext = this.contexts.getUnbound(id);\n    assert(!!localContext, 0x15f\n    /* \"Could not find unbound context to bind\" */\n    );\n    /**\n     * If the container is not detached, it is globally visible to all clients. This data store should also be\n     * globally visible. Move it to attaching state and send an \"attach\" op for it.\n     * If the container is detached, this data store will be part of the summary that makes the container attached.\n     */\n\n    if (this.runtime.attachState !== AttachState.Detached) {\n      localContext.emit(\"attaching\");\n      const message = localContext.generateAttachMessage();\n      this.pendingAttach.set(id, message);\n      this.submitAttachFn(message);\n      this.attachOpFiredForDataStore.add(id);\n    }\n\n    this.contexts.bind(id);\n  }\n\n  createDetachedDataStoreCore(pkg, isRoot, id = uuid()) {\n    assert(!id.includes(\"/\"), 0x30c\n    /* Id cannot contain slashes */\n    );\n    const context = new LocalDetachedFluidDataStoreContext({\n      id,\n      pkg,\n      runtime: this.runtime,\n      storage: this.runtime.storage,\n      scope: this.runtime.scope,\n      createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(id, {\n        type: CreateSummarizerNodeSource.Local\n      }),\n      makeLocallyVisibleFn: () => this.makeDataStoreLocallyVisible(id),\n      snapshotTree: undefined,\n      isRootDataStore: isRoot,\n      writeGCDataAtRoot: this.writeGCDataAtRoot,\n      disableIsolatedChannels: this.runtime.disableIsolatedChannels\n    });\n    this.contexts.addUnbound(context);\n    return context;\n  }\n\n  _createFluidDataStoreContext(pkg, id, isRoot, props) {\n    assert(!id.includes(\"/\"), 0x30d\n    /* Id cannot contain slashes */\n    );\n    const context = new LocalFluidDataStoreContext({\n      id,\n      pkg,\n      runtime: this.runtime,\n      storage: this.runtime.storage,\n      scope: this.runtime.scope,\n      createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(id, {\n        type: CreateSummarizerNodeSource.Local\n      }),\n      makeLocallyVisibleFn: () => this.makeDataStoreLocallyVisible(id),\n      snapshotTree: undefined,\n      isRootDataStore: isRoot,\n      writeGCDataAtRoot: this.writeGCDataAtRoot,\n      disableIsolatedChannels: this.runtime.disableIsolatedChannels,\n      createProps: props\n    });\n    this.contexts.addUnbound(context);\n    return context;\n  }\n\n  get disposed() {\n    return this.disposeOnce.evaluated;\n  }\n\n  resubmitDataStoreOp(content, localOpMetadata) {\n    const envelope = content;\n    const context = this.contexts.get(envelope.address);\n    assert(!!context, 0x160\n    /* \"There should be a store context for the op\" */\n    );\n    context.reSubmit(envelope.contents, localOpMetadata);\n  }\n\n  rollbackDataStoreOp(content, localOpMetadata) {\n    const envelope = content;\n    const context = this.contexts.get(envelope.address);\n    assert(!!context, 0x2e8\n    /* \"There should be a store context for the op\" */\n    );\n    context.rollback(envelope.contents, localOpMetadata);\n  }\n\n  applyStashedOp(content) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const envelope = content;\n\n      const context = _this.contexts.get(envelope.address);\n\n      assert(!!context, 0x161\n      /* \"There should be a store context for the op\" */\n      );\n      return context.applyStashedOp(envelope.contents);\n    })();\n  }\n\n  applyStashedAttachOp(message) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2.pendingAttach.set(message.id, message); // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\n\n      _this2.processAttachMessage({\n        contents: message\n      }, false);\n    })();\n  }\n\n  processFluidDataStoreOp(message, local, localMessageMetadata) {\n    const envelope = message.contents;\n    const transformed = Object.assign(Object.assign({}, message), {\n      contents: envelope.contents\n    });\n    const context = this.contexts.get(envelope.address);\n    assert(!!context, 0x162\n    /* \"There should be a store context for the op\" */\n    );\n    context.process(transformed, local, localMessageMetadata); // Notify that a GC node for the data store changed. This is used to detect if a deleted data store is\n    // being used.\n\n    this.gcNodeUpdated(`/${envelope.address}`, message.timestamp, context.isLoaded ? context.packagePath : undefined);\n  }\n\n  getDataStore(id, wait) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const context = yield _this3.contexts.getBoundOrRemoted(id, wait);\n\n      if (context === undefined) {\n        // The requested data store does not exits. Throw a 404 response exception.\n        const request = {\n          url: id\n        };\n        throw responseToException(create404Response(request), request);\n      }\n\n      return context;\n    })();\n  }\n\n  processSignal(address, message, local) {\n    const context = this.contexts.get(address);\n\n    if (!context) {\n      // Attach message may not have been processed yet\n      assert(!local, 0x163\n      /* \"Missing datastore for local signal\" */\n      );\n      this.logger.sendTelemetryEvent({\n        eventName: \"SignalFluidDataStoreNotFound\",\n        fluidDataStoreId: {\n          value: address,\n          tag: TelemetryDataTag.PackageData\n        }\n      });\n      return;\n    }\n\n    context.processSignal(message, local);\n  }\n\n  setConnectionState(connected, clientId) {\n    for (const [fluidDataStore, context] of this.contexts) {\n      try {\n        context.setConnectionState(connected, clientId);\n      } catch (error) {\n        this.logger.sendErrorEvent({\n          eventName: \"SetConnectionStateError\",\n          clientId,\n          fluidDataStore\n        }, error);\n      }\n    }\n  }\n\n  setAttachState(attachState) {\n    let eventName;\n\n    if (attachState === AttachState.Attaching) {\n      eventName = \"attaching\";\n    } else {\n      eventName = \"attached\";\n    }\n\n    for (const [, context] of this.contexts) {\n      // Fire only for bounded stores.\n      if (!this.contexts.isNotBound(context.id)) {\n        context.emit(eventName);\n      }\n    }\n  }\n\n  get size() {\n    return this.contexts.size;\n  }\n\n  summarize(fullTree, trackState, telemetryContext) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const summaryBuilder = new SummaryTreeBuilder(); // Iterate over each store and ask it to snapshot\n\n      yield Promise.all(Array.from(_this4.contexts).filter(([_, context]) => {\n        // Summarizer works only with clients with no local changes!\n        assert(context.attachState !== AttachState.Attaching, 0x165\n        /* \"Summarizer cannot work if client has local changes\" */\n        );\n        return context.attachState === AttachState.Attached;\n      }).map( /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* ([contextId, context]) {\n          const contextSummary = yield context.summarize(fullTree, trackState, telemetryContext);\n          summaryBuilder.addWithStats(contextId, contextSummary);\n        });\n\n        return function (_x2) {\n          return _ref5.apply(this, arguments);\n        };\n      }()));\n      return summaryBuilder.getSummaryTree();\n    })();\n  }\n\n  createSummary(telemetryContext) {\n    const builder = new SummaryTreeBuilder(); // Attaching graph of some stores can cause other stores to get bound too.\n    // So keep taking summary until no new stores get bound.\n\n    let notBoundContextsLength;\n\n    do {\n      const builderTree = builder.summary.tree;\n      notBoundContextsLength = this.contexts.notBoundLength(); // Iterate over each data store and ask it to snapshot\n\n      Array.from(this.contexts).filter(([key, _]) => // Take summary of bounded data stores only, make sure we haven't summarized them already\n      // and no attach op has been fired for that data store because for loader versions <= 0.24\n      // we set attach state as \"attaching\" before taking createNew summary.\n      !(this.contexts.isNotBound(key) || builderTree[key] || this.attachOpFiredForDataStore.has(key))).map(([key, value]) => {\n        let dataStoreSummary;\n\n        if (value.isLoaded) {\n          const snapshot = value.generateAttachMessage().snapshot;\n          dataStoreSummary = convertToSummaryTree(snapshot, true);\n        } else {\n          // If this data store is not yet loaded, then there should be no changes in the snapshot from\n          // which it was created as it is detached container. So just use the previous snapshot.\n          assert(!!this.baseSnapshot, 0x166\n          /* \"BaseSnapshot should be there as detached container loaded from snapshot\" */\n          );\n          dataStoreSummary = convertSnapshotTreeToSummaryTree(this.baseSnapshot.trees[key]);\n        }\n\n        builder.addWithStats(key, dataStoreSummary);\n      });\n    } while (notBoundContextsLength !== this.contexts.notBoundLength());\n\n    return builder.getSummaryTree();\n  }\n  /**\n   * Before GC runs, called by the garbage collector to update any pending GC state.\n   * The garbage collector needs to know all outbound references that are added. Since root data stores are not\n   * explicitly marked as referenced, notify GC of new root data stores that were added since the last GC run.\n   */\n\n\n  updateStateBeforeGC() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      for (const id of _this5.dataStoresSinceLastGC) {\n        const context = _this5.contexts.get(id);\n\n        assert(context !== undefined, 0x2b6\n        /* Missing data store context */\n        );\n\n        if (yield context.isRoot()) {\n          // A root data store is basically a reference from the container runtime to the data store.\n          const handle = new FluidObjectHandle(context, id, _this5.runtime.IFluidHandleContext);\n\n          _this5.runtime.addedGCOutboundReference(_this5.containerRuntimeHandle, handle);\n        }\n      }\n\n      _this5.dataStoresSinceLastGC = [];\n    })();\n  }\n  /**\n   * Generates data used for garbage collection. It does the following:\n   * 1. Calls into each child data store context to get its GC data.\n   * 2. Prefixes the child context's id to the GC nodes in the child's GC data. This makes sure that the node can be\n   *    identified as belonging to the child.\n   * 3. Adds a GC node for this channel to the nodes received from the children. All these nodes together represent\n   *    the GC data of this channel.\n   * @param fullGC - true to bypass optimizations and force full generation of GC data.\n   */\n\n\n  getGCData(fullGC = false) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const builder = new GCDataBuilder(); // Iterate over each store and get their GC data.\n\n      yield Promise.all(Array.from(_this6.contexts).filter(([_, context]) => {\n        // Get GC data only for attached contexts. Detached contexts are not connected in the GC reference\n        // graph so any references they might have won't be connected as well.\n        return context.attachState === AttachState.Attached;\n      }).map( /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator(function* ([contextId, context]) {\n          const contextGCData = yield context.getGCData(fullGC); // Prefix the child's id to the ids of its GC nodes so they can be identified as belonging to the child.\n          // This also gradually builds the id of each node to be a path from the root.\n\n          builder.prefixAndAddNodes(contextId, contextGCData.gcNodes);\n        });\n\n        return function (_x3) {\n          return _ref6.apply(this, arguments);\n        };\n      }())); // Get the outbound routes and add a GC node for this channel.\n\n      builder.addNode(\"/\", yield _this6.getOutboundRoutes());\n      return builder.getGCData();\n    })();\n  }\n  /**\n   * After GC has run, called to notify this Container's data stores of routes that are used in it.\n   * @param usedRoutes - The routes that are used in all data stores in this Container.\n   * @param gcTimestamp - The time when GC was run that generated these used routes. If any node node becomes\n   * unreferenced as part of this GC run, this should be used to update the time when it happens.\n   */\n\n\n  updateUsedRoutes(usedRoutes, gcTimestamp) {\n    var _a; // Get a map of data store ids to routes used in it.\n\n\n    const usedDataStoreRoutes = unpackChildNodesUsedRoutes(usedRoutes); // Verify that the used routes are correct.\n\n    for (const [id] of usedDataStoreRoutes) {\n      assert(this.contexts.has(id), 0x167\n      /* \"Used route does not belong to any known data store\" */\n      );\n    } // Update the used routes in each data store. Used routes is empty for unused data stores.\n\n\n    for (const [contextId, context] of this.contexts) {\n      context.updateUsedRoutes((_a = usedDataStoreRoutes.get(contextId)) !== null && _a !== void 0 ? _a : [], gcTimestamp);\n    }\n  }\n  /**\n   * When running GC in test mode, this is called to delete objects whose routes are unused. This enables testing\n   * scenarios with accessing deleted content.\n   * @param unusedRoutes - The routes that are unused in all data stores in this Container.\n   */\n\n\n  deleteUnusedRoutes(unusedRoutes) {\n    for (const route of unusedRoutes) {\n      const pathParts = route.split(\"/\"); // Delete data store only if its route (/datastoreId) is in unusedRoutes. We don't want to delete a data\n      // store based on its DDS being unused.\n\n      if (pathParts.length > 2) {\n        continue;\n      }\n\n      const dataStoreId = pathParts[1];\n      assert(this.contexts.has(dataStoreId), 0x2d7\n      /* No data store with specified id */\n      ); // Delete the contexts of unused data stores.\n\n      this.contexts.delete(dataStoreId); // Delete the summarizer node of the unused data stores.\n\n      this.deleteChildSummarizerNodeFn(dataStoreId);\n    }\n  }\n  /**\n   * Returns the outbound routes of this channel. Only root data stores are considered referenced and their paths are\n   * part of outbound routes.\n   */\n\n\n  getOutboundRoutes() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const outboundRoutes = [];\n\n      for (const [contextId, context] of _this7.contexts) {\n        const isRootDataStore = yield context.isRoot();\n\n        if (isRootDataStore) {\n          outboundRoutes.push(`/${contextId}`);\n        }\n      }\n\n      return outboundRoutes;\n    })();\n  }\n  /**\n   * Called by GC to retrieve the package path of a data store node with the given path.\n   */\n\n\n  getDataStorePackagePath(nodePath) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a; // If the node belongs to a data store, return its package path. For DDSes, we return the package path of the\n      // data store that contains it.\n\n\n      const context = _this8.contexts.get(nodePath.split(\"/\")[1]);\n\n      return (_a = yield context === null || context === void 0 ? void 0 : context.getInitialSnapshotDetails()) === null || _a === void 0 ? void 0 : _a.pkg;\n    })();\n  }\n  /**\n   * Called by GC to determine if a node is for a data store or for an object within a data store (for e.g. DDS).\n   * @returns the GC node type if the node belongs to a data store or object within data store, undefined otherwise.\n   */\n\n\n  getGCNodeType(nodePath) {\n    const pathParts = nodePath.split(\"/\");\n\n    if (!this.contexts.has(pathParts[1])) {\n      return undefined;\n    } // Data stores paths are of the format \"/dataStoreId\".\n    // Sub data store paths are of the format \"/dataStoreId/subPath/...\".\n\n\n    if (pathParts.length === 2) {\n      return GCNodeType.DataStore;\n    }\n\n    return GCNodeType.SubDataStore;\n  }\n\n}\nexport function getSummaryForDatastores(snapshot, metadata) {\n  if (!snapshot) {\n    return undefined;\n  }\n\n  if (rootHasIsolatedChannels(metadata)) {\n    const datastoresSnapshot = snapshot.trees[channelsTreeName];\n    assert(!!datastoresSnapshot, 0x168\n    /* Expected tree in snapshot not found */\n    );\n    return datastoresSnapshot;\n  } else {\n    // back-compat: strip out all non-datastore paths before giving to DataStores object.\n    const datastoresTrees = {};\n\n    for (const [key, value] of Object.entries(snapshot.trees)) {\n      if (!nonDataStorePaths.includes(key)) {\n        datastoresTrees[key] = value;\n      }\n    }\n\n    return Object.assign(Object.assign({}, snapshot), {\n      trees: datastoresTrees\n    });\n  }\n} //# sourceMappingURL=dataStores.js.map","map":null,"metadata":{},"sourceType":"module"}