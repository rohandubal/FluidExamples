{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as base64js from \"base64-js\";\nimport { assert } from \"./assert\";\n/**\n * Converts a Uint8Array to a string of the provided encoding\n * Useful when the array might be an IsoBuffer\n * @param arr - The array to convert\n * @param encoding - Optional target encoding; only \"utf8\" and \"base64\" are\n * supported, with \"utf8\" being default\n * @returns The converted string\n */\n\nexport function Uint8ArrayToString(arr, encoding) {\n  switch (encoding) {\n    case \"base64\":\n      {\n        return base64js.fromByteArray(arr);\n      }\n\n    case \"utf8\":\n    case \"utf-8\":\n    case undefined:\n      {\n        return new TextDecoder().decode(arr);\n      }\n\n    default:\n      {\n        throw new Error(\"invalid/unsupported encoding\");\n      }\n  }\n}\n/**\n * Convert base64 or utf8 string to array buffer\n * @param encoding - input string's encoding\n */\n\nexport const stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;\n/**\n * Convert binary blob to string format\n *\n * @param blob - the binary blob\n * @param encoding - output string's encoding\n * @returns the blob in string format\n */\n\nexport const bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);\n/**\n * Determines if an object is an array buffer\n * Will detect and reject TypedArrays, like Uint8Array.\n * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with\n * math properly (i.e. take into account byteOffset at minimum).\n * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or\n * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and\n * ignoring byteOffice, length)\n * @param obj - The object to determine if it is an ArrayBuffer\n */\n\nexport function isArrayBuffer(obj) {\n  const maybe = obj;\n  return obj instanceof ArrayBuffer || typeof maybe === \"object\" && maybe !== null && typeof maybe.byteLength === \"number\" && typeof maybe.slice === \"function\" && maybe.byteOffset === undefined && maybe.buffer === undefined;\n}\n/**\n * Minimal implementation of Buffer for our usages in the browser environment.\n */\n\nexport class IsoBuffer extends Uint8Array {\n  /**\n   * Convert the buffer to a string.\n   * Only supports encoding the whole string (unlike the Node Buffer equivalent)\n   * and only utf8 and base64 encodings\n   * @param encoding\n   */\n  toString(encoding) {\n    return Uint8ArrayToString(this, encoding);\n  }\n  /**\n   * @param value - string | ArrayBuffer\n   * @param encodingOrOffset - string | number\n   * @param length - number\n   */\n\n\n  static from(value, encodingOrOffset, length) {\n    if (typeof value === \"string\") {\n      return IsoBuffer.fromString(value, encodingOrOffset); // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)\n    } else if (value !== null && typeof value === \"object\" && isArrayBuffer(value.buffer)) {\n      // Support currently for full array, no view ports! (though it can be added in future)\n      assert(value.byteOffset === 0, 0x000\n      /* \"nonzero isobuffer byte offset\" */\n      );\n      assert(value.byteLength === value.buffer.byteLength, 0x001\n      /* \"unexpected isobuffer byte length\" */\n      );\n      return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);\n    } else if (isArrayBuffer(value)) {\n      return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);\n    } else {\n      throw new TypeError();\n    }\n  }\n\n  static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n    const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;\n    const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;\n\n    if (offset < 0 || offset > arrayBuffer.byteLength || validLength < 0 || validLength + offset > arrayBuffer.byteLength) {\n      throw new RangeError();\n    }\n\n    return new IsoBuffer(arrayBuffer, offset, validLength);\n  }\n\n  static fromString(str, encoding) {\n    switch (encoding) {\n      case \"base64\":\n        {\n          const sanitizedString = this.sanitizeBase64(str);\n          const encoded = base64js.toByteArray(sanitizedString);\n          return new IsoBuffer(encoded.buffer);\n        }\n\n      case \"utf8\":\n      case \"utf-8\":\n      case undefined:\n        {\n          const encoded = new TextEncoder().encode(str);\n          return new IsoBuffer(encoded.buffer);\n        }\n\n      default:\n        {\n          throw new Error(\"invalid/unsupported encoding\");\n        }\n    }\n  }\n\n  static isBuffer(obj) {\n    throw new Error(\"unimplemented\");\n  }\n  /**\n   * Sanitize a base64 string to provide to base64-js library.  base64-js\n   * is not as tolerant of the same malformed base64 as Node's Buffer is.\n   * @param str\n   */\n\n\n  static sanitizeBase64(str) {\n    let sanitizedStr = str; // Remove everything after padding - Node buffer ignores everything\n    // after any padding whereas base64-js does not\n\n    sanitizedStr = sanitizedStr.split(\"=\")[0]; // Remove invalid characters - Node buffer strips invalid characters\n    // whereas base64-js replaces them with \"A\"\n\n    sanitizedStr = sanitizedStr.replace(/[^\\w+-/]/g, \"\"); // Check for missing padding - Node buffer tolerates missing padding\n    // whereas base64-js does not\n\n    if (sanitizedStr.length % 4 !== 0) {\n      const paddingArray = [\"\", \"===\", \"==\", \"=\"];\n      sanitizedStr += paddingArray[sanitizedStr.length % 4];\n    }\n\n    return sanitizedStr;\n  }\n\n} //# sourceMappingURL=bufferBrowser.js.map","map":null,"metadata":{},"sourceType":"module"}