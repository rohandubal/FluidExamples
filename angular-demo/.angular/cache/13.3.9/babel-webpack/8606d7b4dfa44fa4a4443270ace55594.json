{"ast":null,"code":"import { assert, TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { UsageError } from \"@fluidframework/container-utils\";\nimport { ChildLogger } from \"@fluidframework/telemetry-utils\";\nimport { summarizerClientType } from \"./summarizerClientElection\";\n/**\n * Tracks clients in the Quorum. It maintains their order using their join op\n * sequence numbers.\n * Internally, the collection of clients is maintained in a doubly-linked list,\n * with pointers to both the first and last nodes.\n * The first (root) node is a placeholder to simplify logic and reduce null checking.\n */\n\nexport class OrderedClientCollection extends TypedEventEmitter {\n  constructor(logger, deltaManager, quorum) {\n    super();\n    /** Collection of ALL clients currently in the quorum, with client ids as keys. */\n\n    this.clientMap = new Map();\n    /** Placeholder head node of linked list, for simplified null checking. */\n\n    this.rootNode = {\n      sequenceNumber: -1,\n      olderClient: undefined,\n      youngerClient: undefined\n    };\n    /** Pointer to end of linked list, for optimized client adds. */\n\n    this._youngestClient = this.rootNode;\n    this.logger = ChildLogger.create(logger, \"OrderedClientCollection\");\n    const members = quorum.getMembers();\n\n    for (const [clientId, client] of members) {\n      this.addClient(clientId, client);\n    }\n\n    quorum.on(\"addMember\", (clientId, client) => {\n      const newClient = this.addClient(clientId, client);\n      this.emit(\"addClient\", newClient, deltaManager.lastSequenceNumber);\n    });\n    quorum.on(\"removeMember\", clientId => {\n      const sequenceNumber = deltaManager.lastSequenceNumber;\n      const removeClient = this.removeClient(clientId);\n\n      if (removeClient === undefined) {\n        this.logger.sendErrorEvent({\n          eventName: \"ClientNotFound\",\n          clientId,\n          sequenceNumber\n        });\n      } else {\n        this.emit(\"removeClient\", removeClient, sequenceNumber);\n      }\n    });\n  }\n\n  get count() {\n    return this.clientMap.size;\n  }\n\n  get oldestClient() {\n    return this.rootNode.youngerClient;\n  }\n\n  addClient(clientId, client) {\n    // Normal case is adding the latest client, which will bypass loop.\n    // Find where it belongs otherwise (maybe possible during initial load?).\n    assert(client.sequenceNumber > -1, 0x1f6\n    /* \"Negative client sequence number not allowed\" */\n    );\n    let currClient = this._youngestClient;\n\n    while (currClient.sequenceNumber > client.sequenceNumber) {\n      assert(currClient.olderClient !== undefined, 0x1f7\n      /* \"Previous client should always be defined\" */\n      ); // Note: If adding a client older than the elected client, it will not be automatically elected.\n\n      currClient = currClient.olderClient;\n    } // Now currClient is the node right before where the new client node should be.\n\n\n    const newClient = {\n      clientId,\n      sequenceNumber: client.sequenceNumber,\n      client: Object.assign({}, client.client),\n      olderClient: currClient,\n      youngerClient: currClient.youngerClient\n    }; // Update prev node to point to this new node.\n\n    newClient.olderClient.youngerClient = newClient;\n\n    if (newClient.youngerClient === undefined) {\n      // Update linked list end pointer to youngest client.\n      this._youngestClient = newClient;\n    } else {\n      // Update next node to point back to this new node.\n      newClient.youngerClient.olderClient = newClient;\n    }\n\n    this.clientMap.set(clientId, newClient);\n    return newClient;\n  }\n\n  removeClient(clientId) {\n    const removeClient = this.clientMap.get(clientId);\n\n    if (removeClient === undefined) {\n      return;\n    } // Update prev node to point to next node.\n\n\n    removeClient.olderClient.youngerClient = removeClient.youngerClient;\n\n    if (removeClient.youngerClient === undefined) {\n      // Update linked list end pointer to youngest client.\n      this._youngestClient = removeClient.olderClient;\n    } else {\n      // Update next node to point back to previous node.\n      removeClient.youngerClient.olderClient = removeClient.olderClient;\n    }\n\n    this.clientMap.delete(clientId);\n    return removeClient;\n  }\n  /** Returns an array of all clients being tracked in order from oldest to newest. */\n\n\n  getAllClients() {\n    const result = [];\n    let currClient = this.rootNode;\n\n    while (currClient.youngerClient !== undefined) {\n      result.push(currClient.youngerClient);\n      currClient = currClient.youngerClient;\n    }\n\n    return result;\n  }\n\n}\n/**\n * Adapter for OrderedClientCollection, with the purpose of deterministically maintaining\n * a currently elected client, excluding ineligible clients, in a distributed fashion.\n * This can be true as long as incrementElectedClient and resetElectedClient calls\n * are called under the same conditions for all clients.\n */\n\nexport class OrderedClientElection extends TypedEventEmitter {\n  constructor(logger, orderedClientCollection,\n  /** Serialized state from summary or current sequence number at time of load if new. */\n  initialState, isEligibleFn) {\n    super();\n    this.orderedClientCollection = orderedClientCollection;\n    this.isEligibleFn = isEligibleFn;\n    this._eligibleCount = 0;\n    let initialClient;\n    let initialParent;\n\n    for (const client of orderedClientCollection.getAllClients()) {\n      this.addClient(client, 0);\n\n      if (typeof initialState !== \"number\") {\n        if (client.clientId === initialState.electedClientId) {\n          initialClient = client;\n\n          if (initialState.electedParentId === undefined && client.client.details.type !== summarizerClientType) {\n            // If there was no elected parent in the serialized data, use this one.\n            initialParent = client;\n          }\n        }\n\n        if (client.clientId === initialState.electedParentId) {\n          initialParent = client;\n        }\n      }\n    }\n\n    orderedClientCollection.on(\"addClient\", (client, seq) => this.addClient(client, seq));\n    orderedClientCollection.on(\"removeClient\", (client, seq) => this.removeClient(client, seq));\n\n    if (typeof initialState === \"number\") {\n      this._electionSequenceNumber = initialState;\n    } else {\n      // Override the initially elected client with the initial state.\n      if ((initialClient === null || initialClient === void 0 ? void 0 : initialClient.clientId) !== initialState.electedClientId) {\n        // Cannot find initially elected client, so elect undefined.\n        logger.sendErrorEvent({\n          eventName: \"InitialElectedClientNotFound\",\n          electionSequenceNumber: initialState.electionSequenceNumber,\n          expectedClientId: initialState.electedClientId,\n          electedClientId: initialClient === null || initialClient === void 0 ? void 0 : initialClient.clientId,\n          clientCount: orderedClientCollection.count\n        });\n      } else if (initialClient !== undefined && !isEligibleFn(initialClient)) {\n        // Initially elected client is ineligible, so elect next eligible client.\n        initialClient = initialParent = this.findFirstEligibleParent(initialParent);\n        logger.sendErrorEvent({\n          eventName: \"InitialElectedClientIneligible\",\n          electionSequenceNumber: initialState.electionSequenceNumber,\n          expectedClientId: initialState.electedClientId,\n          electedClientId: initialClient === null || initialClient === void 0 ? void 0 : initialClient.clientId\n        });\n      }\n\n      this._electedParent = initialParent;\n      this._electedClient = initialClient;\n      this._electionSequenceNumber = initialState.electionSequenceNumber;\n    }\n  }\n\n  get eligibleCount() {\n    return this._eligibleCount;\n  }\n\n  get electionSequenceNumber() {\n    return this._electionSequenceNumber;\n  }\n  /**\n   * OrderedClientCollection tracks electedClient and electedParent separately. This allows us to handle the case\n   * where a new interactive parent client has been elected, but the summarizer is still doing work, so\n   * a new summarizer should not yet be spawned. In this case, changing electedParent will cause SummaryManager\n   * to stop the current summarizer, but a new summarizer will not be spawned until the old summarizer client has\n   * left the quorum.\n   *\n   * Details:\n   *\n   * electedParent is the interactive client that has been elected to spawn a summarizer. It is typically the oldest\n   * eligible interactive client in the quorum. Only the electedParent is permitted to spawn a summarizer.\n   * Once elected, this client will remain the electedParent until it leaves the quorum or the summarizer that\n   * it spawned stops producing summaries, at which point a new electedParent will be chosen.\n   *\n   * electedClient is the non-interactive summarizer client if one exists. If not, then electedClient is equal to\n   * electedParent. If electedParent === electedClient, this is the signal for electedParent to spawn a new\n   * electedClient. Once a summarizer client becomes electedClient, a new summarizer will not be spawned until\n   * electedClient leaves the quorum.\n   *\n   * A typical sequence looks like this:\n   * i. Begin by electing A. electedParent === A, electedClient === A.\n   * ii. SummaryManager running on A spawns a summarizer client, A'. electedParent === A, electedClient === A'\n   * iii. A' stops producing summaries. A new parent client, B, is elected. electedParent === B, electedClient === A'\n   * iv. SummaryManager running on A detects the change to electedParent and tells the summarizer to stop, but A'\n   *      is in mid-summarization. No new summarizer is spawned, as electedParent !== electedClient.\n   * v. A' completes its summary, and the summarizer and backing client are torn down.\n   * vi. A' leaves the quorum, and B takes its place as electedClient. electedParent === B, electedClient === B\n   * vii. SummaryManager running on B spawns a summarizer client, B'. electedParent === B, electedClient === B'\n   */\n\n\n  get electedClient() {\n    return this._electedClient;\n  }\n\n  get electedParent() {\n    return this._electedParent;\n  }\n  /** Tries changing the elected client, raising an event if it is different.\n   * Note that this function does no eligibility or suitability checks. If we get here, then\n   * we will set _electedClient, and we will set _electedParent if this is an interactive client.\n   */\n\n\n  tryElectingClient(client, sequenceNumber) {\n    let change = false;\n    const isSummarizerClient = (client === null || client === void 0 ? void 0 : client.client.details.type) === summarizerClientType;\n    const prevClient = this._electedClient;\n\n    if (this._electedClient !== client) {\n      // Changing the elected client. Record the sequence number and note that we have to fire an event.\n      this._electionSequenceNumber = sequenceNumber;\n      this._electedClient = client;\n      change = true;\n    }\n\n    if (this._electedParent !== client && !isSummarizerClient) {\n      // Changing the elected parent as well.\n      this._electedParent = client;\n      change = true;\n    }\n\n    if (change) {\n      this.emit(\"election\", client, sequenceNumber, prevClient);\n    }\n  }\n\n  tryElectingParent(client, sequenceNumber) {\n    if (this._electedParent !== client) {\n      this._electedParent = client;\n      this.emit(\"election\", this._electedClient, sequenceNumber, this._electedClient);\n    }\n  }\n  /**\n   * Helper function to find the first eligible parent client starting with the passed in client,\n   * or undefined if none are eligible.\n   * @param client - client to start checking\n   * @returns oldest eligible client starting with passed in client or undefined if none.\n   */\n\n\n  findFirstEligibleParent(client) {\n    let candidateClient = client;\n\n    while (candidateClient !== undefined && (!this.isEligibleFn(candidateClient) || candidateClient.client.details.type === summarizerClientType)) {\n      candidateClient = candidateClient.youngerClient;\n    }\n\n    return candidateClient;\n  }\n  /**\n   * Updates tracking for when a new client is added to the collection.\n   * Will automatically elect that new client if none is elected currently.\n   * @param client - client added to the collection\n   * @param sequenceNumber - sequence number when client was added\n   */\n\n\n  addClient(client, sequenceNumber) {\n    var _a;\n\n    if (this.isEligibleFn(client)) {\n      this._eligibleCount++;\n      const newClientIsSummarizer = client.client.details.type === summarizerClientType;\n      const electedClientIsSummarizer = ((_a = this._electedClient) === null || _a === void 0 ? void 0 : _a.client.details.type) === summarizerClientType; // Note that we allow a summarizer client to supercede an interactive client as elected client.\n\n      if (this._electedClient === undefined || !electedClientIsSummarizer && newClientIsSummarizer) {\n        this.tryElectingClient(client, sequenceNumber);\n      } else if (this._electedParent === undefined && !newClientIsSummarizer) {\n        // This is an odd case. If the _electedClient is set, the _electedParent should be as well.\n        this.tryElectingParent(client, sequenceNumber);\n      }\n    }\n  }\n  /**\n   * Updates tracking for when an existing client is removed from the collection.\n   * Will automatically elect next oldest client if currently elected is removed.\n   * @param client - client removed from the collection\n   * @param sequenceNumber - sequence number when client was removed\n   */\n\n\n  removeClient(client, sequenceNumber) {\n    var _a, _b, _c, _d, _e;\n\n    if (this.isEligibleFn(client)) {\n      this._eligibleCount--;\n\n      if (this._electedClient === client) {\n        // Removing the _electedClient. There are 2 possible cases:\n        if (this._electedParent !== client) {\n          // 1. The _electedClient is a summarizer that we've been allowing to finish its work.\n          // Let the _electedParent become the _electedClient so that it can start its own summarizer.\n          if (this._electedClient.client.details.type !== summarizerClientType) {\n            throw new UsageError(\"Elected client should be a summarizer client 1\");\n          }\n\n          this.tryElectingClient(this._electedParent, sequenceNumber);\n        } else {\n          // 2. The _electedClient is an interactive client that has left the quorum.\n          // Automatically shift to next oldest client.\n          const nextClient = (_b = this.findFirstEligibleParent((_a = this._electedParent) === null || _a === void 0 ? void 0 : _a.youngerClient)) !== null && _b !== void 0 ? _b : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);\n          this.tryElectingClient(nextClient, sequenceNumber);\n        }\n      } else if (this._electedParent === client) {\n        // Removing the _electedParent (but not _electedClient).\n        // Shift to the next oldest parent, but do not replace the _electedClient,\n        // which is a summarizer that is still doing work.\n        if (((_c = this._electedClient) === null || _c === void 0 ? void 0 : _c.client.details.type) !== summarizerClientType) {\n          throw new UsageError(\"Elected client should be a summarizer client 2\");\n        }\n\n        const nextParent = (_e = this.findFirstEligibleParent((_d = this._electedParent) === null || _d === void 0 ? void 0 : _d.youngerClient)) !== null && _e !== void 0 ? _e : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);\n        this.tryElectingParent(nextParent, sequenceNumber);\n      }\n    }\n  }\n\n  getAllEligibleClients() {\n    return this.orderedClientCollection.getAllClients().filter(this.isEligibleFn);\n  }\n  /** Advance election to the next-oldest client. This is called if the current parent is leaving the quorum,\n   * or if the current summarizer is not responsive and we want to stop it and spawn a new one.\n   */\n\n\n  incrementElectedClient(sequenceNumber) {\n    var _a, _b;\n\n    const nextClient = (_b = this.findFirstEligibleParent((_a = this._electedParent) === null || _a === void 0 ? void 0 : _a.youngerClient)) !== null && _b !== void 0 ? _b : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);\n\n    if (this._electedClient === undefined || this._electedClient === this._electedParent) {\n      this.tryElectingClient(nextClient, sequenceNumber);\n    } else {\n      // The _electedClient is a summarizer and should not be replaced until it leaves the quorum.\n      // Changing the _electedParent will stop the summarizer.\n      this.tryElectingParent(nextClient, sequenceNumber);\n    }\n  }\n  /** (Re-)start election with the oldest client in the quorum. This is called if we need to summarize\n   * and no client has been elected.\n   */\n\n\n  resetElectedClient(sequenceNumber) {\n    const firstClient = this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);\n\n    if (this._electedClient === undefined || this._electedClient === this._electedParent) {\n      this.tryElectingClient(firstClient, sequenceNumber);\n    } else {\n      // The _electedClient is a summarizer and should not be replaced until it leaves the quorum.\n      // Changing the _electedParent will stop the summarizer.\n      this.tryElectingParent(firstClient, sequenceNumber);\n    }\n  }\n\n  peekNextElectedClient() {\n    var _a, _b;\n\n    return (_b = this.findFirstEligibleParent((_a = this._electedParent) === null || _a === void 0 ? void 0 : _a.youngerClient)) !== null && _b !== void 0 ? _b : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);\n  }\n\n  serialize() {\n    var _a, _b;\n\n    return {\n      electionSequenceNumber: this.electionSequenceNumber,\n      electedClientId: (_a = this.electedClient) === null || _a === void 0 ? void 0 : _a.clientId,\n      electedParentId: (_b = this.electedParent) === null || _b === void 0 ? void 0 : _b.clientId\n    };\n  }\n\n} //# sourceMappingURL=orderedClientElection.js.map","map":null,"metadata":{},"sourceType":"module"}