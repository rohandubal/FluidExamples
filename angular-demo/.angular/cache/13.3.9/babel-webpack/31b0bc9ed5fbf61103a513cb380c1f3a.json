{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { TypedEventEmitter } from \"@fluidframework/common-utils\";\nimport { MessageType } from \"@fluidframework/protocol-definitions\";\nexport const summarizerClientType = \"summarizer\";\n/**\n * This class encapsulates logic around tracking the elected summarizer client.\n * It will handle updating the elected client when a summary ack hasn't been seen\n * for some configured number of ops.\n */\n\nexport let SummarizerClientElection = /*#__PURE__*/(() => {\n  class SummarizerClientElection extends TypedEventEmitter {\n    constructor(logger, summaryCollection, clientElection, maxOpsSinceLastSummary, electionEnabled) {\n      super();\n      this.logger = logger;\n      this.summaryCollection = summaryCollection;\n      this.clientElection = clientElection;\n      this.maxOpsSinceLastSummary = maxOpsSinceLastSummary;\n      this.electionEnabled = electionEnabled;\n      /**\n       * Used to prevent excess logging by recording the sequence number that we last reported at,\n       * and making sure we don't report another event to telemetry. If things work as intended,\n       * this is not needed, otherwise it could report an event on every op in worst case scenario.\n       */\n\n      this.lastReportedSeq = 0; // On every inbound op, if enough ops pass without seeing a summary ack (per elected client),\n      // elect a new client and log to telemetry.\n\n      this.summaryCollection.on(\"default\", ({\n        sequenceNumber\n      }) => {\n        var _a, _b, _c;\n\n        const electedClientId = this.electedClientId;\n\n        if (electedClientId === undefined) {\n          // Reset election if no elected client, but eligible clients are connected.\n          // This should be uncommon, but is possible if the initial state of the\n          // ordered client election contains an undefined client id or one not found\n          // in the quorum (the latter would already log an error).\n          if (this.clientElection.eligibleCount > 0) {\n            this.clientElection.resetElectedClient(sequenceNumber);\n          }\n\n          return;\n        }\n\n        let electionSequenceNumber = this.clientElection.electionSequenceNumber;\n        const opsWithoutSummary = sequenceNumber - ((_a = this.lastSummaryAckSeqForClient) !== null && _a !== void 0 ? _a : electionSequenceNumber);\n\n        if (opsWithoutSummary > this.maxOpsSinceLastSummary) {\n          // Log and elect a new summarizer client.\n          const opsSinceLastReport = sequenceNumber - this.lastReportedSeq;\n\n          if (opsSinceLastReport > this.maxOpsSinceLastSummary) {\n            this.logger.sendErrorEvent({\n              eventName: \"ElectedClientNotSummarizing\",\n              electedClientId,\n              lastSummaryAckSeqForClient: this.lastSummaryAckSeqForClient,\n              electionSequenceNumber,\n              nextElectedClientId: (_b = this.clientElection.peekNextElectedClient()) === null || _b === void 0 ? void 0 : _b.clientId,\n              electionEnabled: this.electionEnabled\n            });\n            this.lastReportedSeq = sequenceNumber;\n          }\n\n          if (this.electionEnabled) {\n            const previousParentId = this.electedParentId;\n            this.clientElection.incrementElectedClient(sequenceNumber); // Verify that state incremented as expected. This should be reliable,\n            // since all of OrderedClientElection is synchronous.\n\n            electionSequenceNumber = this.clientElection.electionSequenceNumber;\n\n            if (sequenceNumber > ((_c = this.lastSummaryAckSeqForClient) !== null && _c !== void 0 ? _c : electionSequenceNumber)) {\n              if (opsSinceLastReport > this.maxOpsSinceLastSummary) {\n                this.logger.sendErrorEvent({\n                  eventName: \"UnexpectedElectionSequenceNumber\",\n                  // Expected to be undefined\n                  lastSummaryAckSeqForClient: this.lastSummaryAckSeqForClient,\n                  // Expected to be same as op sequenceNumber\n                  electionSequenceNumber,\n                  sequenceNumber,\n                  previousClientId: electedClientId,\n                  previousParentId,\n                  electedParentId: this.electedParentId,\n                  electedClientId: this.electedClientId,\n                  opsSinceLastReport,\n                  maxOpsSinceLastSummary\n                });\n              }\n            }\n          }\n        }\n      }); // When a summary ack comes in, reset our op seq counter.\n\n      this.summaryCollection.on(MessageType.SummaryAck, op => {\n        this.lastSummaryAckSeqForClient = op.sequenceNumber;\n      }); // Use oldest client election for unanimously and deterministically deciding\n      // which client should summarize.\n\n      this.clientElection.on(\"election\", (client, sequenceNumber) => {\n        this.lastSummaryAckSeqForClient = undefined;\n\n        if (client === undefined && this.clientElection.eligibleCount > 0) {\n          // If no client is valid for election, reset to the oldest again.\n          // Also make extra sure not to get stuck in an infinite loop here:\n          // If there are no eligible clients, just wait until a client joins\n          // and will be auto-elected.\n          this.clientElection.resetElectedClient(sequenceNumber);\n        } // Election can trigger a change in SummaryManager state.\n\n\n        this.emit(\"electedSummarizerChanged\");\n      });\n    }\n\n    get electedClientId() {\n      var _a;\n\n      return (_a = this.clientElection.electedClient) === null || _a === void 0 ? void 0 : _a.clientId;\n    }\n\n    get electedParentId() {\n      var _a;\n\n      return (_a = this.clientElection.electedParent) === null || _a === void 0 ? void 0 : _a.clientId;\n    }\n\n    serialize() {\n      var _a;\n\n      const {\n        electedClientId,\n        electedParentId,\n        electionSequenceNumber\n      } = this.clientElection.serialize();\n      return {\n        electedClientId,\n        electedParentId,\n        electionSequenceNumber: (_a = this.lastSummaryAckSeqForClient) !== null && _a !== void 0 ? _a : electionSequenceNumber\n      };\n    }\n\n    static isClientEligible(client) {\n      const details = client.client.details;\n\n      if (details === undefined) {\n        // Very old clients back-compat\n        return true;\n      }\n\n      return SummarizerClientElection.clientDetailsPermitElection(details);\n    }\n\n  }\n\n  SummarizerClientElection.clientDetailsPermitElection = details => details.capabilities.interactive || details.type === summarizerClientType; //# sourceMappingURL=summarizerClientElection.js.map\n\n\n  return SummarizerClientElection;\n})();","map":null,"metadata":{},"sourceType":"module"}