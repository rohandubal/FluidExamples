{"ast":null,"code":"/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Runtime check to determine if a class is a DataObject type\n */\nexport const isDataObjectClass = obj => {\n  return (obj === null || obj === void 0 ? void 0 : obj.factory) !== undefined;\n};\n/**\n * Runtime check to determine if a class is a SharedObject type\n */\n\nexport const isSharedObjectClass = obj => {\n  return (obj === null || obj === void 0 ? void 0 : obj.getFactory) !== undefined;\n};\n/**\n * The ContainerSchema consists of initialObjects and dynamicObjectTypes. These types can be\n * of both SharedObject or DataObject. This function seperates the two and returns a registery\n * of DataObject types and an array of SharedObjects.\n */\n\nexport const parseDataObjectsFromSharedObjects = schema => {\n  var _a;\n\n  const registryEntries = new Set();\n  const sharedObjects = new Set();\n\n  const tryAddObject = obj => {\n    if (isSharedObjectClass(obj)) {\n      sharedObjects.add(obj.getFactory());\n    } else if (isDataObjectClass(obj)) {\n      registryEntries.add([obj.factory.type, Promise.resolve(obj.factory)]);\n    } else {\n      throw new Error(`Entry is neither a DataObject or a SharedObject`);\n    }\n  }; // Add the object types that will be initialized\n\n\n  const dedupedObjects = new Set([...Object.values(schema.initialObjects), ...((_a = schema.dynamicObjectTypes) !== null && _a !== void 0 ? _a : [])]);\n  dedupedObjects.forEach(tryAddObject);\n\n  if (registryEntries.size === 0 && sharedObjects.size === 0) {\n    throw new Error(\"Container cannot be initialized without any DataTypes\");\n  }\n\n  return [Array.from(registryEntries), Array.from(sharedObjects)];\n}; //# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module"}