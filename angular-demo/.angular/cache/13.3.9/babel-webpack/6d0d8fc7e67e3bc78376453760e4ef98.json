{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert, stringToBuffer, Uint8ArrayToString } from \"@fluidframework/common-utils\";\nimport { convertSnapshotAndBlobsToSummaryTree } from \"@fluidframework/driver-utils\";\nimport { convertWholeFlatSummaryToSnapshotTreeAndBlobs, WholeSummaryUploadManager } from \"@fluidframework/server-services-client\";\nimport { PerformanceEvent } from \"@fluidframework/telemetry-utils\";\nimport { InMemoryCache } from \"./cache\";\nconst latestSnapshotId = \"latest\";\nexport class WholeSummaryDocumentStorageService {\n  constructor(id, manager, logger, policies = {}, driverPolicies, blobCache = new InMemoryCache(), snapshotTreeCache = new InMemoryCache(), noCacheGitManager, getStorageManager = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (disableCache) {\n      return disableCache && _this.noCacheGitManager !== undefined ? _this.noCacheGitManager : _this.manager;\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }()) {\n    var _this = this;\n\n    this.id = id;\n    this.manager = manager;\n    this.logger = logger;\n    this.policies = policies;\n    this.driverPolicies = driverPolicies;\n    this.blobCache = blobCache;\n    this.snapshotTreeCache = snapshotTreeCache;\n    this.noCacheGitManager = noCacheGitManager;\n    this.getStorageManager = getStorageManager;\n    this.firstVersionsCall = true;\n  }\n\n  get repositoryUrl() {\n    return \"\";\n  }\n\n  getSummaryUploadManager() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const manager = yield _this2.getStorageManager();\n      return new WholeSummaryUploadManager(manager);\n    })();\n  }\n\n  getVersions(versionId, count) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      if (versionId !== _this3.id && versionId !== null) {\n        // Blobs/Trees in this scenario will never have multiple versions, so return versionId as is\n        return [{\n          id: versionId,\n          treeId: undefined\n        }];\n      } // If this is the first versions call for the document, we know we will want the latest summary.\n      // Fetch latest summary, cache it, and return its id.\n\n\n      if (_this3.firstVersionsCall && count === 1) {\n        _this3.firstVersionsCall = false;\n        const {\n          id: _id,\n          snapshotTree\n        } = !((_a = _this3.driverPolicies) === null || _a === void 0 ? void 0 : _a.enableDiscovery) ? yield _this3.fetchAndCacheSnapshotTree(latestSnapshotId, false) : yield _this3.fetchAndCacheSnapshotTree(latestSnapshotId, true);\n        return [{\n          id: _id,\n          treeId: snapshotTree.id\n        }];\n      } // Otherwise, get the latest version of the document as normal.\n\n\n      const id = versionId ? versionId : _this3.id;\n      const commits = yield PerformanceEvent.timedExecAsync(_this3.logger, {\n        eventName: \"getVersions\",\n        versionId: id,\n        count\n      }, /*#__PURE__*/_asyncToGenerator(function* () {\n        const manager = yield _this3.getStorageManager();\n        return manager.getCommits(id, count);\n      }));\n      return commits.map(commit => ({\n        date: commit.commit.author.date,\n        id: commit.sha,\n        treeId: commit.commit.tree.sha\n      }));\n    })();\n  }\n\n  getSnapshotTree(version) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      let requestVersion = version;\n\n      if (!requestVersion) {\n        const versions = yield _this4.getVersions(_this4.id, 1);\n\n        if (versions.length === 0) {\n          return null;\n        }\n\n        requestVersion = versions[0];\n      }\n\n      return (yield _this4.fetchAndCacheSnapshotTree(requestVersion.id)).snapshotTree;\n    })();\n  }\n\n  readBlob(blobId) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const cachedBlob = yield _this5.blobCache.get(_this5.getCacheKey(blobId));\n\n      if (cachedBlob !== undefined) {\n        return cachedBlob;\n      }\n\n      const blob = yield PerformanceEvent.timedExecAsync(_this5.logger, {\n        eventName: \"readBlob\",\n        blobId\n      }, /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (event) {\n          const manager = yield _this5.getStorageManager();\n          const response = yield manager.getBlob(blobId);\n          event.end({\n            size: response.size\n          });\n          return response;\n        });\n\n        return function (_x2) {\n          return _ref3.apply(this, arguments);\n        };\n      }());\n      const bufferValue = stringToBuffer(blob.content, blob.encoding);\n      yield _this5.blobCache.put(_this5.getCacheKey(blob.sha), bufferValue);\n      return bufferValue;\n    })();\n  }\n\n  uploadSummaryWithContext(summary, context) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const summaryHandle = yield PerformanceEvent.timedExecAsync(_this6.logger, {\n        eventName: \"uploadSummaryWithContext\"\n      }, /*#__PURE__*/_asyncToGenerator(function* () {\n        var _a;\n\n        const summaryUploadManager = yield _this6.getSummaryUploadManager();\n        return summaryUploadManager.writeSummaryTree(summary, (_a = context.ackHandle) !== null && _a !== void 0 ? _a : \"\", \"channel\");\n      }));\n      return summaryHandle;\n    })();\n  }\n\n  downloadSummary(summaryHandle) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const wholeFlatSummary = yield PerformanceEvent.timedExecAsync(_this7.logger, {\n        eventName: \"getWholeFlatSummary\",\n        treeId: summaryHandle.handle\n      }, /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* (event) {\n          var _a;\n\n          const manager = yield _this7.getStorageManager();\n          const response = yield manager.getSummary(summaryHandle.handle);\n          event.end({\n            size: (_a = response.trees[0]) === null || _a === void 0 ? void 0 : _a.entries.length\n          });\n          return response;\n        });\n\n        return function (_x3) {\n          return _ref5.apply(this, arguments);\n        };\n      }());\n      const {\n        blobs,\n        snapshotTree\n      } = convertWholeFlatSummaryToSnapshotTreeAndBlobs(wholeFlatSummary, \"\");\n      return convertSnapshotAndBlobsToSummaryTree(snapshotTree, blobs);\n    })();\n  }\n\n  createBlob(file) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const uint8ArrayFile = new Uint8Array(file);\n      return PerformanceEvent.timedExecAsync(_this8.logger, {\n        eventName: \"createBlob\",\n        size: uint8ArrayFile.length\n      }, /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator(function* (event) {\n          const manager = yield _this8.getStorageManager();\n          const response = yield manager.createBlob(Uint8ArrayToString(uint8ArrayFile, \"base64\"), \"base64\").then(r => ({\n            id: r.sha,\n            url: r.url\n          }));\n          event.end({\n            blobId: response.id\n          });\n          return response;\n        });\n\n        return function (_x4) {\n          return _ref6.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n  fetchAndCacheSnapshotTree(versionId, disableCache) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const cachedSnapshotTreeVersion = yield _this9.snapshotTreeCache.get(_this9.getCacheKey(versionId));\n\n      if (cachedSnapshotTreeVersion !== undefined) {\n        return {\n          id: cachedSnapshotTreeVersion.id,\n          snapshotTree: cachedSnapshotTreeVersion.snapshotTree\n        };\n      }\n\n      const wholeFlatSummary = yield PerformanceEvent.timedExecAsync(_this9.logger, {\n        eventName: \"getWholeFlatSummary\",\n        treeId: versionId\n      }, /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator(function* (event) {\n          var _a;\n\n          const manager = yield _this9.getStorageManager(disableCache);\n          const response = yield manager.getSummary(versionId);\n          event.end({\n            size: (_a = response.trees[0]) === null || _a === void 0 ? void 0 : _a.entries.length\n          });\n          return response;\n        });\n\n        return function (_x5) {\n          return _ref7.apply(this, arguments);\n        };\n      }());\n      const normalizedWholeSummary = convertWholeFlatSummaryToSnapshotTreeAndBlobs(wholeFlatSummary);\n      const wholeFlatSummaryId = wholeFlatSummary.id;\n      const snapshotTreeId = normalizedWholeSummary.snapshotTree.id;\n      assert(snapshotTreeId !== undefined, 0x275\n      /* \"Root tree should contain the id\" */\n      );\n      const snapshotTreeVersion = {\n        id: wholeFlatSummaryId,\n        snapshotTree: normalizedWholeSummary.snapshotTree\n      };\n      const cachePs = [_this9.snapshotTreeCache.put(_this9.getCacheKey(snapshotTreeId), snapshotTreeVersion), _this9.initBlobCache(normalizedWholeSummary.blobs)];\n\n      if (snapshotTreeId !== versionId) {\n        // versionId could be \"latest\". When summarizer checks cache for \"latest\", we want it to be available.\n        // TODO: For in-memory cache, <latest,snapshotTree> will be a shared pointer with <snapshotId,snapshotTree>,\n        // However, for something like Redis, this will cache the same value twice. Alternatively, could we simply\n        // cache with versionId?\n        cachePs.push(_this9.snapshotTreeCache.put(_this9.getCacheKey(versionId), snapshotTreeVersion));\n      }\n\n      yield Promise.all(cachePs);\n      return snapshotTreeVersion;\n    })();\n  }\n\n  initBlobCache(blobs) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const blobCachePutPs = [];\n      blobs.forEach((value, id) => {\n        const cacheKey = _this10.getCacheKey(id);\n\n        blobCachePutPs.push(_this10.blobCache.put(cacheKey, value));\n      });\n      yield Promise.all(blobCachePutPs);\n    })();\n  }\n\n  getCacheKey(blobId) {\n    return `${this.id}:${blobId}`;\n  }\n\n} //# sourceMappingURL=wholeSummaryDocumentStorageService.js.map","map":null,"metadata":{},"sourceType":"module"}