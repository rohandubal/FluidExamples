{"ast":null,"code":"import { Lazy } from \"@fluidframework/common-utils\";\n/**\n * Creates a base configuration provider based on `sessionStorage`\n *\n * @returns A lazy initialized base configuration provider with `sessionStorage` as the underlying config store\n */\n\nexport const sessionStorageConfigProvider = new Lazy(() => inMemoryConfigProvider(safeSessionStorage()));\nconst NullConfigProvider = {\n  getRawConfig: () => undefined\n};\n/**\n * Creates a base configuration provider based on the supplied `Storage` instance\n *\n * @param storage - instance of `Storage` to be used as storage media for the config\n * @returns A base configuration provider with\n * the supplied `Storage` instance as the underlying config store\n */\n\nexport const inMemoryConfigProvider = storage => {\n  if (storage !== undefined && storage !== null) {\n    return new CachedConfigProvider({\n      getRawConfig: name => {\n        var _a, _b;\n\n        try {\n          return (_b = stronglyTypedParse((_a = storage.getItem(name)) !== null && _a !== void 0 ? _a : undefined)) === null || _b === void 0 ? void 0 : _b.raw;\n        } catch (_c) {}\n\n        return undefined;\n      }\n    });\n  }\n\n  return NullConfigProvider;\n};\n\nfunction isPrimitiveType(type) {\n  switch (type) {\n    case \"boolean\":\n    case \"number\":\n    case \"string\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n/**\n * Takes any supported config type, and returns the value with a strong type. If the type of\n * the config is not a supported type undefined will be returned.\n * The user of this function should cache the result to avoid duplicated work.\n *\n * Strings will be attempted to be parsed and coerced into a strong config type.\n * if it is not possible to parsed and coerce a string to a strong config type the original string\n * will be return with a string type for the consumer to handle further if necessary.\n */\n\n\nfunction stronglyTypedParse(input) {\n  let output = input;\n  let defaultReturn; // we do special handling for strings to try and coerce\n  // them into a config type if we can. This makes it easy\n  // for config sources like sessionStorage which only\n  // holds strings\n\n  if (typeof input === \"string\") {\n    try {\n      output = JSON.parse(input); // we succeeded in parsing, but we don't support parsing\n      // for any object as we can't do it type safely\n      // so in this case, the default return will be string\n      // rather than undefined, and the consumer\n      // can parse, as we don't want to provide\n      // a false sense of security by just\n      // casting.\n\n      defaultReturn = {\n        raw: input,\n        string: input\n      };\n    } catch (_a) {}\n  }\n\n  if (output === undefined) {\n    return defaultReturn;\n  }\n\n  const outputType = typeof output;\n\n  if (isPrimitiveType(outputType)) {\n    return Object.assign(Object.assign({}, defaultReturn), {\n      raw: input,\n      [outputType]: output\n    });\n  }\n\n  if (Array.isArray(output)) {\n    const firstType = typeof output[0]; // ensure the first elements is a primitive type\n\n    if (!isPrimitiveType(firstType)) {\n      return defaultReturn;\n    } // ensue all the elements types are homogeneous\n    // aka they all have the same type as the first\n\n\n    for (const v of output) {\n      if (typeof v !== firstType) {\n        return defaultReturn;\n      }\n    }\n\n    return Object.assign(Object.assign({}, defaultReturn), {\n      raw: input,\n      [`${firstType}[]`]: output\n    });\n  }\n\n  return defaultReturn;\n}\n/** Referencing the `sessionStorage` variable can throw in some environments such as Node */\n\n\nconst safeSessionStorage = () => {\n  try {\n    return sessionStorage !== null ? sessionStorage : undefined;\n  } catch (_a) {\n    return undefined;\n  }\n};\n/**\n * Implementation of {@link IConfigProvider} which contains nested {@link IConfigProviderBase} instances\n */\n\n\nexport class CachedConfigProvider {\n  constructor(...orderedBaseProviders) {\n    this.configCache = new Map();\n    this.orderedBaseProviders = [];\n    const knownProviders = new Set();\n    const candidateProviders = [...orderedBaseProviders];\n\n    while (candidateProviders.length > 0) {\n      const baseProvider = candidateProviders.shift();\n\n      if (baseProvider !== undefined && isConfigProviderBase(baseProvider) && !knownProviders.has(baseProvider)) {\n        knownProviders.add(baseProvider);\n\n        if (baseProvider instanceof CachedConfigProvider) {\n          candidateProviders.push(...baseProvider.orderedBaseProviders);\n        } else {\n          this.orderedBaseProviders.push(baseProvider);\n        }\n      }\n    }\n  }\n\n  getBoolean(name) {\n    var _a;\n\n    return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.boolean;\n  }\n\n  getNumber(name) {\n    var _a;\n\n    return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.number;\n  }\n\n  getString(name) {\n    var _a;\n\n    return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.string;\n  }\n\n  getBooleanArray(name) {\n    var _a;\n\n    return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a[\"boolean[]\"];\n  }\n\n  getNumberArray(name) {\n    var _a;\n\n    return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a[\"number[]\"];\n  }\n\n  getStringArray(name) {\n    var _a;\n\n    return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a[\"string[]\"];\n  }\n\n  getRawConfig(name) {\n    var _a;\n\n    return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.raw;\n  }\n\n  getCacheEntry(name) {\n    if (!this.configCache.has(name)) {\n      for (const provider of this.orderedBaseProviders) {\n        const parsed = stronglyTypedParse(provider === null || provider === void 0 ? void 0 : provider.getRawConfig(name));\n\n        if (parsed !== undefined) {\n          this.configCache.set(name, parsed);\n          return parsed;\n        }\n      } // configs are immutable, if the first lookup returned no results, all lookups should\n\n\n      this.configCache.set(name, {\n        raw: undefined\n      });\n    }\n\n    return this.configCache.get(name);\n  }\n\n}\nexport function loggerIsMonitoringContext(obj) {\n  const maybeConfig = obj;\n  return isConfigProviderBase(maybeConfig === null || maybeConfig === void 0 ? void 0 : maybeConfig.config) && (maybeConfig === null || maybeConfig === void 0 ? void 0 : maybeConfig.logger) !== undefined;\n}\nexport function loggerToMonitoringContext(logger) {\n  if (loggerIsMonitoringContext(logger)) {\n    return logger;\n  }\n\n  return mixinMonitoringContext(logger, sessionStorageConfigProvider.value);\n}\nexport function mixinMonitoringContext(logger, ...configs) {\n  if (loggerIsMonitoringContext(logger)) {\n    throw new Error(\"Logger is already a monitoring context\");\n  }\n  /**\n   * this is the tricky bit we use for now to smuggle monitoring context around.\n   * To the logger we mixin both config and  itself, so mc.logger === logger as it is self-referential.\n   * We then expose it as a Monitoring context, so via types we hide the outer logger methods.\n   * To layers that expect just a logger we can pass mc.logger, but this is still a MonitoringContext\n   * so if a deeper layer then converts that logger to a monitoring context it can find the smuggled properties\n   * of the MonitoringContext and get the config provider.\n   */\n\n\n  const mc = logger;\n  mc.config = new CachedConfigProvider(...configs);\n  mc.logger = logger;\n  return mc;\n}\n\nfunction isConfigProviderBase(obj) {\n  const maybeConfig = obj;\n  return typeof (maybeConfig === null || maybeConfig === void 0 ? void 0 : maybeConfig.getRawConfig) === \"function\";\n} //# sourceMappingURL=config.js.map","map":null,"metadata":{},"sourceType":"module"}