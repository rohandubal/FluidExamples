{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { BindState, AttachState } from \"@fluidframework/container-definitions\";\nimport { DataProcessingError, UsageError } from \"@fluidframework/container-utils\";\nimport { assert, Deferred, LazyPromise, TypedEventEmitter, unreachableCase } from \"@fluidframework/common-utils\";\nimport { ChildLogger, LoggingError, raiseConnectedEvent } from \"@fluidframework/telemetry-utils\";\nimport { buildSnapshotTree } from \"@fluidframework/driver-utils\";\nimport { SummaryType } from \"@fluidframework/protocol-definitions\";\nimport { CreateSummarizerNodeSource, VisibilityState } from \"@fluidframework/runtime-definitions\";\nimport { convertSnapshotTreeToSummaryTree, convertSummaryTreeToITree, generateHandleContextPath, RequestParser, SummaryTreeBuilder, create404Response, createResponseError, exceptionToResponse } from \"@fluidframework/runtime-utils\";\nimport { GCDataBuilder, removeRouteFromAllNodes, unpackChildNodesGCDetails, unpackChildNodesUsedRoutes } from \"@fluidframework/garbage-collector\";\nimport { v4 as uuid } from \"uuid\";\nimport { summarizeChannel } from \"./channelContext\";\nimport { LocalChannelContext, LocalChannelContextBase, RehydratedLocalChannelContext } from \"./localChannelContext\";\nimport { RemoteChannelContext } from \"./remoteChannelContext\";\nexport var DataStoreMessageType = /*#__PURE__*/(() => {\n  (function (DataStoreMessageType) {\n    // Creates a new channel\n    DataStoreMessageType[\"Attach\"] = \"attach\";\n    DataStoreMessageType[\"ChannelOp\"] = \"op\";\n  })(DataStoreMessageType || (DataStoreMessageType = {}));\n\n  return DataStoreMessageType;\n})();\n\n/**\n * Base data store class\n */\nexport class FluidDataStoreRuntime extends TypedEventEmitter {\n  constructor(dataStoreContext, sharedObjectRegistry, existing) {\n    var _this;\n\n    super();\n    _this = this;\n    this.dataStoreContext = dataStoreContext;\n    this.sharedObjectRegistry = sharedObjectRegistry;\n    this._disposed = false;\n    this.contexts = new Map();\n    this.contextsDeferred = new Map();\n    this.pendingAttach = new Map();\n    this.deferredAttached = new Deferred();\n    this.localChannelContextQueue = new Map();\n    this.notBoundedChannelContextSet = new Set(); // A list of handles that are bound when the data store is not visible. We have to make them visible when the data\n    // store becomes visible.\n\n    this.pendingHandlesToMakeVisible = new Set();\n    assert(!dataStoreContext.id.includes(\"/\"), 0x30e\n    /* Id cannot contain slashes. DataStoreContext should have validated this. */\n    );\n    this.logger = ChildLogger.create(dataStoreContext.logger, \"FluidDataStoreRuntime\", {\n      all: {\n        dataStoreId: uuid()\n      }\n    });\n    this.id = dataStoreContext.id;\n    this.options = dataStoreContext.options;\n    this.deltaManager = dataStoreContext.deltaManager;\n    this.quorum = dataStoreContext.getQuorum();\n    this.audience = dataStoreContext.getAudience();\n    const tree = dataStoreContext.baseSnapshot;\n    this.channelsBaseGCDetails = new LazyPromise( /*#__PURE__*/_asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      const baseGCDetails = yield (_c = (_b = (_a = _this.dataStoreContext).getBaseGCDetails) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : _this.dataStoreContext.getInitialGCSummaryDetails();\n      return unpackChildNodesGCDetails(baseGCDetails);\n    })); // Must always receive the data store type inside of the attributes\n\n    if ((tree === null || tree === void 0 ? void 0 : tree.trees) !== undefined) {\n      Object.keys(tree.trees).forEach(path => {\n        // Issue #4414\n        if (path === \"_search\") {\n          return;\n        }\n\n        let channelContext; // If already exists on storage, then create a remote channel. However, if it is case of rehydrating a\n        // container from snapshot where we load detached container from a snapshot, isLocalDataStore would be\n        // true. In this case create a RehydratedLocalChannelContext.\n\n        if (dataStoreContext.isLocalDataStore) {\n          channelContext = new RehydratedLocalChannelContext(path, this.sharedObjectRegistry, this, this.dataStoreContext, this.dataStoreContext.storage, this.logger, (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata), address => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle), tree.trees[path]); // This is the case of rehydrating a detached container from snapshot. Now due to delay loading of\n          // data store, if the data store is loaded after the container is attached, then we missed making\n          // the channel visible. So do it now. Otherwise, add it to local channel context queue, so\n          // that it can be make it visible later with the data store.\n\n          if (dataStoreContext.attachState !== AttachState.Detached) {\n            channelContext.makeVisible();\n          } else {\n            this.localChannelContextQueue.set(path, channelContext);\n          }\n        } else {\n          channelContext = new RemoteChannelContext(this, dataStoreContext, dataStoreContext.storage, (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata), address => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle), path, tree.trees[path], this.sharedObjectRegistry, undefined\n          /* extraBlobs */\n          , this.dataStoreContext.getCreateChildSummarizerNodeFn(path, {\n            type: CreateSummarizerNodeSource.FromSummary\n          }), /*#__PURE__*/_asyncToGenerator(function* () {\n            return _this.getChannelBaseGCDetails(path);\n          }));\n        }\n\n        const deferred = new Deferred();\n        deferred.resolve(channelContext);\n        this.contexts.set(path, channelContext);\n        this.contextsDeferred.set(path, deferred);\n      });\n    }\n\n    this.attachListener(); // If exists on storage or loaded from a snapshot, it should already be bound.\n\n    this.bindState = existing ? BindState.Bound : BindState.NotBound;\n    this._attachState = dataStoreContext.attachState;\n    /**\n     * If existing flag is false, this is a new data store and is not visible. The existing flag can be true in two\n     * conditions:\n     * 1. It's a local data store that is created when a detached container is rehydrated. In this case, the data\n     *    store is locally visible because the snapshot it is loaded from contains locally visible data stores only.\n     * 2. It's a remote data store that is created when an attached container is loaded is loaded from snapshot or\n     *    when an attach op comes in. In both these cases, the data store is already globally visible.\n     */\n\n    if (existing) {\n      this.visibilityState = dataStoreContext.attachState === AttachState.Detached ? VisibilityState.LocallyVisible : VisibilityState.GloballyVisible;\n    } else {\n      this.visibilityState = VisibilityState.NotVisible;\n    } // If it's existing we know it has been attached.\n\n\n    if (existing) {\n      this.deferredAttached.resolve();\n    }\n  }\n  /**\n   * Loads the data store runtime\n   * @param context - The data store context\n   * @param sharedObjectRegistry - The registry of shared objects used by this data store\n   * @param existing - If loading from an existing file.\n   */\n\n\n  static load(context, sharedObjectRegistry, existing) {\n    return new FluidDataStoreRuntime(context, sharedObjectRegistry, existing);\n  }\n\n  get IFluidRouter() {\n    return this;\n  }\n\n  get connected() {\n    return this.dataStoreContext.connected;\n  }\n\n  get clientId() {\n    return this.dataStoreContext.clientId;\n  }\n\n  get clientDetails() {\n    return this.dataStoreContext.clientDetails;\n  }\n\n  get isAttached() {\n    return this.attachState !== AttachState.Detached;\n  }\n\n  get attachState() {\n    return this._attachState;\n  }\n\n  get absolutePath() {\n    return generateHandleContextPath(this.id, this.routeContext);\n  }\n\n  get routeContext() {\n    return this.dataStoreContext.IFluidHandleContext;\n  }\n\n  get IFluidHandleContext() {\n    return this;\n  }\n\n  get rootRoutingContext() {\n    return this;\n  }\n\n  get channelsRoutingContext() {\n    return this;\n  }\n\n  get objectsRoutingContext() {\n    return this;\n  }\n\n  get disposed() {\n    return this._disposed;\n  }\n\n  dispose() {\n    if (this._disposed) {\n      return;\n    }\n\n    this._disposed = true;\n    this.emit(\"dispose\");\n    this.removeAllListeners();\n  }\n\n  resolveHandle(request) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2.request(request);\n    })();\n  }\n\n  request(request) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const parser = RequestParser.create(request);\n        const id = parser.pathParts[0];\n\n        if (id === \"_channels\" || id === \"_custom\") {\n          return _this3.request(parser.createSubRequest(1));\n        } // Check for a data type reference first\n\n\n        if (_this3.contextsDeferred.has(id) && parser.isLeaf(1)) {\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const value = yield _this3.contextsDeferred.get(id).promise;\n            const channel = yield value.getChannel();\n            return {\n              mimeType: \"fluid/object\",\n              status: 200,\n              value: channel\n            };\n          } catch (error) {\n            _this3.logger.sendErrorEvent({\n              eventName: \"GetChannelFailedInRequest\"\n            }, error);\n\n            return createResponseError(500, `Failed to get Channel: ${error}`, request);\n          }\n        } // Otherwise defer to an attached request handler\n\n\n        return create404Response(request);\n      } catch (error) {\n        return exceptionToResponse(error);\n      }\n    })();\n  }\n\n  getChannel(id) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      _this4.verifyNotClosed(); // TODO we don't assume any channels (even root) in the runtime. If you request a channel that doesn't exist\n      // we will never resolve the promise. May want a flag to getChannel that doesn't wait for the promise if\n      // it doesn't exist\n\n\n      if (!_this4.contextsDeferred.has(id)) {\n        _this4.contextsDeferred.set(id, new Deferred());\n      } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n      const context = yield _this4.contextsDeferred.get(id).promise;\n      const channel = yield context.getChannel();\n      return channel;\n    })();\n  }\n\n  createChannel(id = uuid(), type) {\n    if (id.includes(\"/\")) {\n      throw new UsageError(`Id cannot contain slashes: ${id}`);\n    }\n\n    this.verifyNotClosed();\n    assert(!this.contexts.has(id), 0x179\n    /* \"createChannel() with existing ID\" */\n    );\n    this.notBoundedChannelContextSet.add(id);\n    const context = new LocalChannelContext(id, this.sharedObjectRegistry, type, this, this.dataStoreContext, this.dataStoreContext.storage, this.logger, (content, localOpMetadata) => this.submitChannelOp(id, content, localOpMetadata), address => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle));\n    this.contexts.set(id, context);\n\n    if (this.contextsDeferred.has(id)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.contextsDeferred.get(id).resolve(context);\n    } else {\n      const deferred = new Deferred();\n      deferred.resolve(context);\n      this.contextsDeferred.set(id, deferred);\n    }\n\n    assert(!!context.channel, 0x17a\n    /* \"Channel should be loaded when created!!\" */\n    );\n    return context.channel;\n  }\n  /**\n   * Binds a channel with the runtime. If the runtime is attached we will attach the channel right away.\n   * If the runtime is not attached we will defer the attach until the runtime attaches.\n   * @param channel - channel to be registered.\n   */\n\n\n  bindChannel(channel) {\n    assert(this.notBoundedChannelContextSet.has(channel.id), 0x17b\n    /* \"Channel to be binded should be in not bounded set\" */\n    );\n    this.notBoundedChannelContextSet.delete(channel.id); // If our data store is attached, then attach the channel.\n\n    if (this.isAttached) {\n      this.attachChannel(channel);\n      return;\n    }\n    /**\n     * If this channel is already waiting to be made visible, do nothing. This can happen during attachGraph() when\n     * a channel's graph is attached. It calls bindToContext on the shared object which will end up back here.\n     */\n\n\n    if (this.pendingHandlesToMakeVisible.has(channel.handle)) {\n      return;\n    }\n\n    this.bind(channel.handle); // If our data store is local then add the channel to the queue\n\n    if (!this.localChannelContextQueue.has(channel.id)) {\n      this.localChannelContextQueue.set(channel.id, this.contexts.get(channel.id));\n    }\n  }\n  /**\n   * This function is called when a data store becomes root. It does the following:\n   * 1. Marks the data store locally visible in the container.\n   * 2. Attaches the graph of all the handles bound to it.\n   * 3. Calls into the data store context to mark it visible in the container too. If the container is globally\n   *    visible, it will mark us globally visible. Otherwise, it will mark us globally visible when it becomes\n   *    globally visible.\n   */\n\n\n  makeVisibleAndAttachGraph() {\n    if (this.visibilityState !== VisibilityState.NotVisible) {\n      return;\n    }\n\n    this.visibilityState = VisibilityState.LocallyVisible;\n    this.pendingHandlesToMakeVisible.forEach(handle => {\n      handle.attachGraph();\n    });\n    this.pendingHandlesToMakeVisible.clear();\n    this.bindToContext();\n  }\n  /**\n   * This function is called when a handle to this data store is added to a visible DDS.\n   */\n\n\n  attachGraph() {\n    this.makeVisibleAndAttachGraph();\n  }\n  /**\n   * Binds this runtime to the container\n   * This includes the following:\n   * 1. Sending an Attach op that includes all existing state\n   * 2. Attaching the graph if the data store becomes attached.\n   */\n\n\n  bindToContext() {\n    if (this.bindState !== BindState.NotBound) {\n      return;\n    }\n\n    this.bindState = BindState.Binding;\n    this.dataStoreContext.bindToContext();\n    this.bindState = BindState.Bound;\n  }\n\n  bind(handle) {\n    // If visible, attach the incoming handle's graph. Else, this will be done when we become visible.\n    if (this.visibilityState !== VisibilityState.NotVisible) {\n      handle.attachGraph();\n      return;\n    }\n\n    this.pendingHandlesToMakeVisible.add(handle);\n  }\n\n  setConnectionState(connected, clientId) {\n    this.verifyNotClosed();\n\n    for (const [, object] of this.contexts) {\n      object.setConnectionState(connected, clientId);\n    }\n\n    raiseConnectedEvent(this.logger, this, connected, clientId);\n  }\n\n  getQuorum() {\n    return this.quorum;\n  }\n\n  getAudience() {\n    return this.audience;\n  }\n\n  uploadBlob(blob) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      _this5.verifyNotClosed();\n\n      return _this5.dataStoreContext.uploadBlob(blob);\n    })();\n  }\n\n  process(message, local, localOpMetadata) {\n    var _this6 = this;\n\n    this.verifyNotClosed();\n\n    try {\n      // catches as data processing error whether or not they come from async pending queues\n      switch (message.type) {\n        case DataStoreMessageType.Attach:\n          {\n            const attachMessage = message.contents;\n            const id = attachMessage.id; // If a non-local operation then go and create the object\n            // Otherwise mark it as officially attached.\n\n            if (local) {\n              assert(this.pendingAttach.has(id), 0x17c\n              /* \"Unexpected attach (local) channel OP\" */\n              );\n              this.pendingAttach.delete(id);\n            } else {\n              assert(!this.contexts.has(id), 0x17d);\n              const flatBlobs = new Map();\n              const snapshotTree = buildSnapshotTree(attachMessage.snapshot.entries, flatBlobs);\n              const remoteChannelContext = new RemoteChannelContext(this, this.dataStoreContext, this.dataStoreContext.storage, (content, localContentMetadata) => this.submitChannelOp(id, content, localContentMetadata), address => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle), id, snapshotTree, this.sharedObjectRegistry, flatBlobs, this.dataStoreContext.getCreateChildSummarizerNodeFn(id, {\n                type: CreateSummarizerNodeSource.FromAttach,\n                sequenceNumber: message.sequenceNumber,\n                snapshot: attachMessage.snapshot\n              }), /*#__PURE__*/_asyncToGenerator(function* () {\n                return _this6.getChannelBaseGCDetails(id);\n              }), attachMessage.type);\n              this.contexts.set(id, remoteChannelContext);\n\n              if (this.contextsDeferred.has(id)) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this.contextsDeferred.get(id).resolve(remoteChannelContext);\n              } else {\n                const deferred = new Deferred();\n                deferred.resolve(remoteChannelContext);\n                this.contextsDeferred.set(id, deferred);\n              }\n            }\n\n            break;\n          }\n\n        case DataStoreMessageType.ChannelOp:\n          this.processChannelOp(message, local, localOpMetadata);\n          break;\n\n        default:\n      }\n\n      this.emit(\"op\", message);\n    } catch (error) {\n      throw DataProcessingError.wrapIfUnrecognized(error, \"fluidDataStoreRuntimeFailedToProcessMessage\", message);\n    }\n  }\n\n  processSignal(message, local) {\n    this.emit(\"signal\", message, local);\n  }\n\n  isChannelAttached(id) {\n    return (// Added in createChannel\n      // Removed when bindChannel is called\n      !this.notBoundedChannelContextSet.has(id) // Added in bindChannel only if this is not attached yet\n      // Removed when this is attached by calling attachGraph\n      && !this.localChannelContextQueue.has(id) // Added in attachChannel called by bindChannel\n      // Removed when attach op is broadcast\n      && !this.pendingAttach.has(id)\n    );\n  }\n  /**\n   * Returns the outbound routes of this channel. Currently, all contexts in this channel are considered\n   * referenced and are hence outbound. This will change when we have root and non-root channel contexts.\n   * The only root contexts will be considered as referenced.\n   */\n\n\n  getOutboundRoutes() {\n    const outboundRoutes = [];\n\n    for (const [contextId] of this.contexts) {\n      outboundRoutes.push(`${this.absolutePath}/${contextId}`);\n    }\n\n    return outboundRoutes;\n  }\n  /**\n   * Updates the GC nodes of this channel. It does the following:\n   * - Adds a back route to self to all its child GC nodes.\n   * - Adds a node for this channel.\n   * @param builder - The builder that contains the GC nodes for this channel's children.\n   */\n\n\n  updateGCNodes(builder) {\n    // Add a back route to self in each child's GC nodes. If any child is referenced, then its parent should\n    // be considered referenced as well.\n    builder.addRouteToAllNodes(this.absolutePath); // Get the outbound routes and add a GC node for this channel.\n\n    builder.addNode(\"/\", this.getOutboundRoutes());\n  }\n  /**\n   * Generates data used for garbage collection. This includes a list of GC nodes that represent this channel\n   * including any of its child channel contexts. Each node has a set of outbound routes to other GC nodes in the\n   * document. It does the following:\n   * 1. Calls into each child context to get its GC data.\n   * 2. Prefixes the child context's id to the GC nodes in the child's GC data. This makes sure that the node can be\n   *    identified as belonging to the child.\n   * 3. Adds a GC node for this channel to the nodes received from the children. All these nodes together represent\n   *    the GC data of this channel.\n   * @param fullGC - true to bypass optimizations and force full generation of GC data.\n   */\n\n\n  getGCData(fullGC = false) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const builder = new GCDataBuilder(); // Iterate over each channel context and get their GC data.\n\n      yield Promise.all(Array.from(_this7.contexts).filter(([contextId, _]) => {\n        // Get GC data only for attached contexts. Detached contexts are not connected in the GC reference\n        // graph so any references they might have won't be connected as well.\n        return _this7.isChannelAttached(contextId);\n      }).map( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* ([contextId, context]) {\n          const contextGCData = yield context.getGCData(fullGC); // Prefix the child's id to the ids of its GC nodes so they can be identified as belonging to the child.\n          // This also gradually builds the id of each node to be a path from the root.\n\n          builder.prefixAndAddNodes(contextId, contextGCData.gcNodes);\n        });\n\n        return function (_x) {\n          return _ref4.apply(this, arguments);\n        };\n      }()));\n\n      _this7.updateGCNodes(builder);\n\n      return builder.getGCData();\n    })();\n  }\n  /**\n   * After GC has run, called to notify this channel of routes that are used in it. It calls the child contexts to\n   * update their used routes.\n   * @param usedRoutes - The routes that are used in all contexts in this channel.\n   * @param gcTimestamp - The time when GC was run that generated these used routes. If any node becomes unreferenced\n   * as part of this GC run, this should be used to update the time when it happens.\n   */\n\n\n  updateUsedRoutes(usedRoutes, gcTimestamp) {\n    var _a; // Get a map of channel ids to routes used in it.\n\n\n    const usedContextRoutes = unpackChildNodesUsedRoutes(usedRoutes); // Verify that the used routes are correct.\n\n    for (const [id] of usedContextRoutes) {\n      assert(this.contexts.has(id), 0x17e\n      /* \"Used route does not belong to any known context\" */\n      );\n    } // Update the used routes in each context. Used routes is empty for unused context.\n\n\n    for (const [contextId, context] of this.contexts) {\n      context.updateUsedRoutes((_a = usedContextRoutes.get(contextId)) !== null && _a !== void 0 ? _a : [], gcTimestamp);\n    }\n  }\n  /**\n   * Called when a new outbound reference is added to another node. This is used by garbage collection to identify\n   * all references added in the system.\n   * @param srcHandle - The handle of the node that added the reference.\n   * @param outboundHandle - The handle of the outbound node that is referenced.\n   */\n\n\n  addedGCOutboundReference(srcHandle, outboundHandle) {\n    var _a, _b;\n\n    (_b = (_a = this.dataStoreContext).addedGCOutboundReference) === null || _b === void 0 ? void 0 : _b.call(_a, srcHandle, outboundHandle);\n  }\n  /**\n   * Returns the base GC details for the channel with the given id. This is used to initialize its GC state.\n   * @param channelId - The id of the channel context that is asked for the initial GC details.\n   * @returns the requested channel's base GC details.\n   */\n\n\n  getChannelBaseGCDetails(channelId) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      let channelBaseGCDetails = (yield _this8.channelsBaseGCDetails).get(channelId);\n\n      if (channelBaseGCDetails === undefined) {\n        channelBaseGCDetails = {};\n      } else if (((_a = channelBaseGCDetails.gcData) === null || _a === void 0 ? void 0 : _a.gcNodes) !== undefined) {\n        // Note: if the child channel has an explicit handle route to its parent, it will be removed here and\n        // expected to be added back by the parent when getGCData is called.\n        removeRouteFromAllNodes(channelBaseGCDetails.gcData.gcNodes, _this8.absolutePath);\n      } // Currently, channel context's are always considered used. So, it there are no used routes for it, we still\n      // need to mark it as used. Add self-route (empty string) to the channel context's used routes.\n\n\n      if (channelBaseGCDetails.usedRoutes === undefined || channelBaseGCDetails.usedRoutes.length === 0) {\n        channelBaseGCDetails.usedRoutes = [\"\"];\n      }\n\n      return channelBaseGCDetails;\n    })();\n  }\n  /**\n   * Returns a summary at the current sequence number.\n   * @param fullTree - true to bypass optimizations and force a full summary tree\n   * @param trackState - This tells whether we should track state from this summary.\n   * @param telemetryContext - summary data passed through the layers for telemetry purposes\n   */\n\n\n  summarize(fullTree = false, trackState = true, telemetryContext) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const summaryBuilder = new SummaryTreeBuilder(); // Iterate over each data store and ask it to summarize\n\n      yield Promise.all(Array.from(_this9.contexts).filter(([contextId, _]) => {\n        const isAttached = _this9.isChannelAttached(contextId); // We are not expecting local dds! Summary may not capture local state.\n\n\n        assert(isAttached, 0x17f\n        /* \"Not expecting detached channels during summarize\" */\n        ); // If the object is registered - and we have received the sequenced op creating the object\n        // (i.e. it has a base mapping) - then we go ahead and summarize\n\n        return isAttached;\n      }).map( /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* ([contextId, context]) {\n          const contextSummary = yield context.summarize(fullTree, trackState, telemetryContext);\n          summaryBuilder.addWithStats(contextId, contextSummary);\n        });\n\n        return function (_x2) {\n          return _ref5.apply(this, arguments);\n        };\n      }()));\n      return summaryBuilder.getSummaryTree();\n    })();\n  }\n\n  getAttachSummary(telemetryContext) {\n    /**\n     * back-compat 0.59.1000 - getAttachSummary() is called when making a data store globally visible (previously\n     * attaching state). Ideally, attachGraph() should have already be called making it locally visible. However,\n     * before visibility state was added, this may not have been the case and getAttachSummary() could be called:\n     * 1) Before attaching the data store - When a detached container is attached.\n     * 2) After attaching the data store - When a data store is created and bound in an attached container.\n     *\n     * The basic idea is that all local object should become locally visible before they are globally visible.\n     */\n    this.attachGraph();\n    /**\n     * This assert cannot be added now due to back-compat. To be uncommented when the following issue is fixed -\n     * https://github.com/microsoft/FluidFramework/issues/9688.\n     *\n     * assert(this.visibilityState === VisibilityState.LocallyVisible,\n     *   \"The data store should be locally visible when generating attach summary\",\n     * );\n     */\n\n    const summaryBuilder = new SummaryTreeBuilder(); // Craft the .attributes file for each shared object\n\n    for (const [contextId, context] of this.contexts) {\n      if (!(context instanceof LocalChannelContextBase)) {\n        throw new LoggingError(\"Should only be called with local channel handles\");\n      }\n\n      if (!this.notBoundedChannelContextSet.has(contextId)) {\n        let summaryTree;\n\n        if (context.isLoaded) {\n          const contextSummary = context.getAttachSummary(telemetryContext);\n          assert(contextSummary.summary.type === SummaryType.Tree, 0x180\n          /* \"getAttachSummary should always return a tree\" */\n          );\n          summaryTree = {\n            stats: contextSummary.stats,\n            summary: contextSummary.summary\n          };\n        } else {\n          // If this channel is not yet loaded, then there should be no changes in the snapshot from which\n          // it was created as it is detached container. So just use the previous snapshot.\n          assert(!!this.dataStoreContext.baseSnapshot, 0x181\n          /* \"BaseSnapshot should be there as detached container loaded from snapshot\" */\n          );\n          summaryTree = convertSnapshotTreeToSummaryTree(this.dataStoreContext.baseSnapshot.trees[contextId]);\n        }\n\n        summaryBuilder.addWithStats(contextId, summaryTree);\n      }\n    }\n\n    return summaryBuilder.getSummaryTree();\n  }\n\n  submitMessage(type, content, localOpMetadata) {\n    this.submit(type, content, localOpMetadata);\n  }\n\n  submitSignal(type, content) {\n    this.verifyNotClosed();\n    return this.dataStoreContext.submitSignal(type, content);\n  }\n  /**\n   * Will return when the data store is attached.\n   */\n\n\n  waitAttached() {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this10.deferredAttached.promise;\n    })();\n  }\n  /**\n   * Attach channel should only be called after the data store has been attached\n   */\n\n\n  attachChannel(channel) {\n    this.verifyNotClosed(); // If this handle is already attached no need to attach again.\n\n    if (channel.handle.isAttached) {\n      return;\n    }\n\n    channel.handle.attachGraph();\n    assert(this.isAttached, 0x182\n    /* \"Data store should be attached to attach the channel.\" */\n    );\n    assert(this.visibilityState === VisibilityState.GloballyVisible, 0x2d0\n    /* \"Data store should be globally visible to attach channels.\" */\n    );\n    const summarizeResult = summarizeChannel(channel, true\n    /* fullTree */\n    , false\n    /* trackState */\n    ); // Attach message needs the summary in ITree format. Convert the ISummaryTree into an ITree.\n\n    const snapshot = convertSummaryTreeToITree(summarizeResult.summary);\n    const message = {\n      id: channel.id,\n      snapshot,\n      type: channel.attributes.type\n    };\n    this.pendingAttach.set(channel.id, message);\n    this.submit(DataStoreMessageType.Attach, message);\n    const context = this.contexts.get(channel.id);\n    context.makeVisible();\n  }\n\n  submitChannelOp(address, contents, localOpMetadata) {\n    const envelope = {\n      address,\n      contents\n    };\n    this.submit(DataStoreMessageType.ChannelOp, envelope, localOpMetadata);\n  }\n\n  submit(type, content, localOpMetadata = undefined) {\n    this.verifyNotClosed();\n    this.dataStoreContext.submitMessage(type, content, localOpMetadata);\n  }\n  /**\n   * For messages of type MessageType.Operation, finds the right channel and asks it to resubmit the message.\n   * For all other messages, just submit it again.\n   * This typically happens when we reconnect and there are unacked messages.\n   * @param content - The content of the original message.\n   * @param localOpMetadata - The local metadata associated with the original message.\n   */\n\n\n  reSubmit(type, content, localOpMetadata) {\n    this.verifyNotClosed();\n\n    switch (type) {\n      case DataStoreMessageType.ChannelOp:\n        {\n          // For Operations, find the right channel and trigger resubmission on it.\n          const envelope = content;\n          const channelContext = this.contexts.get(envelope.address);\n          assert(!!channelContext, 0x183\n          /* \"There should be a channel context for the op\" */\n          );\n          channelContext.reSubmit(envelope.contents, localOpMetadata);\n          break;\n        }\n\n      case DataStoreMessageType.Attach:\n        // For Attach messages, just submit them again.\n        this.submit(type, content, localOpMetadata);\n        break;\n\n      default:\n        unreachableCase(type);\n    }\n  }\n  /**\n   * Revert a local op.\n   * @param content - The content of the original message.\n   * @param localOpMetadata - The local metadata associated with the original message.\n   */\n\n\n  rollback(type, content, localOpMetadata) {\n    this.verifyNotClosed();\n\n    switch (type) {\n      case DataStoreMessageType.ChannelOp:\n        {\n          // For Operations, find the right channel and trigger resubmission on it.\n          const envelope = content;\n          const channelContext = this.contexts.get(envelope.address);\n          assert(!!channelContext, 0x2ed\n          /* \"There should be a channel context for the op\" */\n          );\n          channelContext.rollback(envelope.contents, localOpMetadata);\n          break;\n        }\n\n      default:\n        throw new LoggingError(`Can't rollback ${type} message`);\n    }\n  }\n\n  applyStashedOp(content) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      const envelope = content;\n\n      const channelContext = _this11.contexts.get(envelope.address);\n\n      assert(!!channelContext, 0x184\n      /* \"There should be a channel context for the op\" */\n      );\n      yield channelContext.getChannel();\n      return channelContext.applyStashedOp(envelope.contents);\n    })();\n  }\n\n  setChannelDirty(address) {\n    this.verifyNotClosed();\n    this.dataStoreContext.setChannelDirty(address);\n  }\n\n  processChannelOp(message, local, localOpMetadata) {\n    this.verifyNotClosed();\n    const envelope = message.contents;\n    const transformed = Object.assign(Object.assign({}, message), {\n      contents: envelope.contents\n    });\n    const channelContext = this.contexts.get(envelope.address);\n    assert(!!channelContext, 0x185\n    /* \"Channel not found\" */\n    );\n    channelContext.processOp(transformed, local, localOpMetadata);\n    return channelContext;\n  }\n\n  attachListener() {\n    this.setMaxListeners(Number.MAX_SAFE_INTEGER);\n    this.dataStoreContext.once(\"attaching\", () => {\n      /**\n       * back-compat 0.59.1000 - Ideally, attachGraph() should have already been called making the data store\n       * locally visible. However, before visibility state was added, this may not have been the case and data\n       * store can move to \"attaching\" state in 2 scenarios:\n       * 1) Before attachGraph() is called - When a data store is created and bound in an attached container.\n       * 2) After attachGraph() is called - When a detached container is attached.\n       *\n       * The basic idea is that all local object should become locally visible before they are globally visible.\n       */\n      this.attachGraph();\n      this._attachState = AttachState.Attaching;\n      assert(this.visibilityState === VisibilityState.LocallyVisible, 0x2d1\n      /* \"Data store should be locally visible before it can become globally visible.\" */\n      ); // Mark the data store globally visible and make its child channels visible as well.\n\n      this.visibilityState = VisibilityState.GloballyVisible;\n      this.localChannelContextQueue.forEach(channel => {\n        channel.makeVisible();\n      });\n      this.localChannelContextQueue.clear(); // This promise resolution will be moved to attached event once we fix the scheduler.\n\n      this.deferredAttached.resolve();\n      this.emit(\"attaching\");\n    });\n    this.dataStoreContext.once(\"attached\", () => {\n      assert(this.visibilityState === VisibilityState.GloballyVisible, 0x2d2\n      /* \"Data store should be globally visible when its attached.\" */\n      );\n      this._attachState = AttachState.Attached;\n      this.emit(\"attached\");\n    });\n  }\n\n  verifyNotClosed() {\n    if (this._disposed) {\n      throw new LoggingError(\"Runtime is closed\");\n    }\n  }\n\n}\n/**\n * Mixin class that adds request handler to FluidDataStoreRuntime\n * Request handler is only called when data store can't resolve request, i.e. for custom requests.\n * @param Base - base class, inherits from FluidDataStoreRuntime\n * @param requestHandler - request handler to mix in\n */\n\nexport const mixinRequestHandler = (requestHandler, Base = FluidDataStoreRuntime) => class RuntimeWithRequestHandler extends Base {\n  request(request) {\n    var _superprop_getRequest = () => super.request,\n        _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const response = yield _superprop_getRequest().call(_this12, request);\n\n      if (response.status === 404) {\n        return requestHandler(request, _this12);\n      }\n\n      return response;\n    })();\n  }\n\n};\n/**\n * Mixin class that adds await for DataObject to finish initialization before we proceed to summary.\n * @param handler - handler that returns info about blob to be added to summary.\n * Or undefined not to add anything to summary.\n * @param Base - base class, inherits from FluidDataStoreRuntime\n */\n\nexport const mixinSummaryHandler = (handler, Base = FluidDataStoreRuntime) => class RuntimeWithSummarizerHandler extends Base {\n  addBlob(summary, path, content) {\n    const firstName = path.shift();\n\n    if (firstName === undefined) {\n      throw new LoggingError(\"Path can't be empty\");\n    }\n\n    let blob = {\n      type: SummaryType.Blob,\n      content\n    };\n    summary.stats.blobNodeCount++;\n    summary.stats.totalBlobSize += content.length;\n\n    for (const name of path.reverse()) {\n      blob = {\n        type: SummaryType.Tree,\n        tree: {\n          [name]: blob\n        }\n      };\n      summary.stats.treeNodeCount++;\n    }\n\n    summary.summary.tree[firstName] = blob;\n  }\n\n  summarize(...args) {\n    var _superprop_getSummarize = () => super.summarize,\n        _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      const summary = yield _superprop_getSummarize().call(_this13, ...args);\n      const content = yield handler(_this13);\n\n      if (content !== undefined) {\n        _this13.addBlob(summary, content.path, content.content);\n      }\n\n      return summary;\n    })();\n  }\n\n}; //# sourceMappingURL=dataStoreRuntime.js.map","map":null,"metadata":{},"sourceType":"module"}