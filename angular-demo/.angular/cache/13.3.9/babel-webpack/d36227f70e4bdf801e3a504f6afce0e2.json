{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sdeshpande\\\\Documents\\\\FluidExamples\\\\angular-demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { assert } from \"@fluidframework/common-utils\";\nimport { readAndParse } from \"@fluidframework/driver-utils\";\nimport { SummaryType } from \"@fluidframework/protocol-definitions\";\nimport { channelsTreeName } from \"@fluidframework/runtime-definitions\";\nimport { gcTreeKey } from \"./garbageCollection\";\nexport function getAttributesFormatVersion(attributes) {\n  if (attributes.summaryFormatVersion) {\n    /**\n     * Version 2+: Introduces .channels trees for isolation of\n     * channel trees from data store objects.\n     */\n    return attributes.summaryFormatVersion;\n  } else if (attributes.snapshotFormatVersion === \"0.1\") {\n    /**\n     * Version 1: from this version the pkg within the data store\n     * attributes blob is a JSON array rather than a string.\n     */\n    return 1;\n  }\n  /**\n   * Version 0: format version is missing from summary.\n   * This indicates it is an older version.\n   */\n\n\n  return 0;\n}\nexport function hasIsolatedChannels(attributes) {\n  return !!attributes.summaryFormatVersion && !attributes.disableIsolatedChannels;\n}\n/**\n * Extracts the properties from an ISequencedDocumentMessage as defined by ISummaryMetadataMessage. This message is\n * added to the metadata blob in summary.\n */\n\nexport const extractSummaryMetadataMessage = message => message === undefined ? undefined : {\n  clientId: message.clientId,\n  clientSequenceNumber: message.clientSequenceNumber,\n  minimumSequenceNumber: message.minimumSequenceNumber,\n  referenceSequenceNumber: message.referenceSequenceNumber,\n  sequenceNumber: message.sequenceNumber,\n  timestamp: message.timestamp,\n  type: message.type\n};\nexport function getMetadataFormatVersion(metadata) {\n  var _a;\n  /**\n   * Version 2+: Introduces runtime sequence number for data verification.\n   *\n   * Version 1+: Introduces .metadata blob and .channels trees for isolation of\n   * data store trees from container-level objects.\n   * Also introduces enableGC option stored in the summary.\n   *\n   * Version 0: metadata blob missing; format version is missing from summary.\n   * This indicates it is an older version.\n   */\n\n\n  return (_a = metadata === null || metadata === void 0 ? void 0 : metadata.summaryFormatVersion) !== null && _a !== void 0 ? _a : 0;\n}\nexport const aliasBlobName = \".aliases\";\nexport const metadataBlobName = \".metadata\";\nexport const chunksBlobName = \".chunks\";\nexport const electedSummarizerBlobName = \".electedSummarizer\";\nexport const blobsTreeName = \".blobs\";\nexport function rootHasIsolatedChannels(metadata) {\n  return !!metadata && !metadata.disableIsolatedChannels;\n}\nexport function getGCVersion(metadata) {\n  var _a;\n\n  if (!metadata) {\n    // Force to 0/disallowed in prior versions\n    return 0;\n  }\n\n  return (_a = metadata.gcFeature) !== null && _a !== void 0 ? _a : 0;\n}\nexport const protocolTreeName = \".protocol\";\n/**\n * List of tree IDs at the container level which are reserved.\n * This is for older versions of summaries that do not yet have an\n * isolated data stores namespace. Without the namespace, this must\n * be used to prevent name collisions with data store IDs.\n */\n\nexport const nonDataStorePaths = [protocolTreeName, \".logTail\", \".serviceProtocol\", blobsTreeName, gcTreeKey];\nexport const dataStoreAttributesBlobName = \".component\";\n/**\n * Modifies summary tree and stats to put tree under .channels tree.\n *\n * @param summarizeResult - Summary tree and stats to modify\n *\n * @example\n * Converts from:\n * ```typescript\n * {\n *     type: SummaryType.Tree,\n *     tree: { a: {...}, b: {...}, c: {...} },\n * }\n * ```\n *\n * to:\n *\n * ```typescript\n * {\n *     type: SummaryType.Tree,\n *     tree: {\n *         \".channels\": {\n *             type: SummaryType.Tree,\n *             tree: { a: {...}, b: {...}, c: {...} }\n *         },\n *     },\n * }\n * ```\n * And adds +1 to treeNodeCount in stats.\n */\n\nexport function wrapSummaryInChannelsTree(summarizeResult) {\n  summarizeResult.summary = {\n    type: SummaryType.Tree,\n    tree: {\n      [channelsTreeName]: summarizeResult.summary\n    }\n  };\n  summarizeResult.stats.treeNodeCount++;\n}\nexport function getFluidDataStoreAttributes(_x, _x2) {\n  return _getFluidDataStoreAttributes.apply(this, arguments);\n} //# sourceMappingURL=summaryFormat.js.map\n\nfunction _getFluidDataStoreAttributes() {\n  _getFluidDataStoreAttributes = _asyncToGenerator(function* (storage, snapshot) {\n    const attributes = yield readAndParse(storage, snapshot.blobs[dataStoreAttributesBlobName]); // Use the snapshotFormatVersion to determine how the pkg is encoded in the snapshot.\n    // For snapshotFormatVersion = \"0.1\" (1) or above, pkg is jsonified, otherwise it is just a string.\n    // However the feature of loading a detached container from snapshot, is added when the\n    // snapshotFormatVersion is at least \"0.1\" (1), so we don't expect it to be anything else.\n\n    const formatVersion = getAttributesFormatVersion(attributes);\n    assert(formatVersion > 0, 0x1d5\n    /* Invalid snapshot format version */\n    );\n    return attributes;\n  });\n  return _getFluidDataStoreAttributes.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}